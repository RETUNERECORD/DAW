
<!DOCTYPE html>
<html lang="en">
<head>
<meta name="facebook-domain-verification" content="w7u3kncvv0jv4uxd97elo875ebzjyk" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="HandheldFriendly" content="true">
<meta name="MobileOptimized" content="width">
<link rel="apple-touch-icon" sizes="96x96" href="/assets/icon/black/96.png">
<link rel="apple-touch-icon" sizes="128x128" href="/assets/icon/black/128.png">
<link rel="apple-touch-icon" href="/assets/icon/black/96.png">
<link rel="apple-touch-startup-image" href="//assets/icon/black/512.png">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9GXFP1S3C"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Y9GXFP1S3C');
</script>



<script data-ad-client="ca-pub-9978497384789328" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<title>squencer.netlify.app</title>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, user-scalable=yes"/>

<meta name="description" content="A free and Open-Source DAW (digital audio workstation)"/>

<meta property="og:type" content="website"/>
<meta property="og:title" content="squencer.netlify.app"/>
<meta property="og:image" content="https://squencer.netlify.app/assets/og-image.jpg"/>
<meta property="og:image:width" content="800"/>
<meta property="og:image:height" content="400"/>
<meta property="og:description" content="a free and open source DAW (digital audio workstation)"/>
<meta name="theme-color" content="#8AC0D1"/>
<link rel="manifest" href="manifest.json"/>
<link rel="shortcut icon" href="../assets/favicon.png"/>
<style>
.gsuiDragshield {
	position: absolute;
	z-index: 2147483647;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	pointer-events: none;
}
.gsuiDragshield-show {
	pointer-events: auto;
}
:root {
	--gsuiIcon-color-after: currentColor;
	--gsuiIcon-opacity-after: .6;
}

/* .......................................................................... */
.gsuiIcon {
	position: relative;
	display: inline-block;
	font-family: "FontAwesome";
	font-size: 1em;
	font-style: normal;
	font-weight: normal;
	font-variant: normal;
	text-rendering: auto;
	-moz-osx-font-smoothing: grayscale;
	-webkit-font-smoothing: antialiased;
}
.gsuiIconB {
	font-family: "FontAwesomeBrands";
}
.gsuiIcon::before {
	pointer-events: none;
}
.gsuiIcon:not( .gsuiIconB )::before {
	position: absolute;
}
.gsuiIcon::after {
	color: var( --gsuiIcon-color-after );
	opacity: var( --gsuiIcon-opacity-after );
	pointer-events: none;
}
.gsuiIcon:not( [ data-spin="on" ] )[ data-icon="" ],
.gsuiIcon:not( [ data-spin="on" ] ):not( [ data-icon ] ),
.gsuiIconB::after {
	display: none;
}

/* .......................................................................... */
.gsuiIcon.gsuiIcon.gsuiIcon[ data-spin="on" ] {
	line-height: 1;
}
.gsuiIcon.gsuiIcon.gsuiIcon[ data-spin="on" ]::before {
	content: "\f3f4";
	animation: .7s infinite linear gsuiIcon-spin;
	opacity: 1;
}
.gsuiIcon.gsuiIcon.gsuiIcon[ data-spin="on" ]::after {
	display: inline-block;
	content: "\10f3f4";
	animation: .7s infinite linear gsuiIcon-spin;
	opacity: .4;
}

@keyframes gsuiIcon-spin {
	from { transform: rotate( 0deg ); }
	to { transform: rotate( 360deg ); }
}

/* .......................................................................... */
.gsuiIcon[ data-icon="github" ]::before { content: "\f09b"; }
.gsuiIcon[ data-icon="github" ]::after { content: "\10f09b"; }
.gsuiIcon[ data-icon="github" ]:hover::before { content: "\f113"; }
.gsuiIcon[ data-icon="github" ]:hover::after { content: "\10f113"; }
.gsuiIcon[ data-icon="codepen" ]::before { content: "\f1cb"; }
.gsuiIcon[ data-icon="codepen" ]::after { content: "\10f1cb"; }
.gsuiIcon[ data-icon="discord" ]::before { content: "\f392"; }
.gsuiIcon[ data-icon="discord" ]::after { content: "\10f392"; }
.gsuiIcon[ data-icon="patreon" ]::before { content: "\f3d9"; }
.gsuiIcon[ data-icon="patreon" ]::after { content: "\10f3d9"; }
.gsuiIcon[ data-icon="twitter" ]::before { content: "\f099"; }
.gsuiIcon[ data-icon="twitter" ]::after { content: "\10f099"; }
.gsuiIcon[ data-icon="youtube" ]::before { content: "\f167"; }
.gsuiIcon[ data-icon="youtube" ]::after { content: "\10f167"; }
.gsuiIcon[ data-icon="facebook" ]::before { content: "\f09a"; }
.gsuiIcon[ data-icon="facebook" ]::after { content: "\10f09a"; }
.gsuiIcon[ data-icon="wordpress" ]::before { content: "\f411"; }
.gsuiIcon[ data-icon="wordpress" ]::after { content: "\10f411"; }

/* .......................................................................... */
.gsuiIcon[ data-icon="arrow-left" ]::before { content: "\f355"; }
.gsuiIcon[ data-icon="arrow-left" ]::after { content: "\10f355"; }
.gsuiIcon[ data-icon="arrow-right" ]::before { content: "\f356"; }
.gsuiIcon[ data-icon="arrow-right" ]::after { content: "\10f356"; }
.gsuiIcon[ data-icon="arrows" ]::before { content: "\f0b2"; }
.gsuiIcon[ data-icon="arrows" ]::after { content: "\10f0b2"; }
.gsuiIcon[ data-icon="arrows-v" ]::before { content: "\f338"; }
.gsuiIcon[ data-icon="arrows-v" ]::after { content: "\10f338"; }
.gsuiIcon[ data-icon="arrows-h" ]::before { content: "\f337"; }
.gsuiIcon[ data-icon="arrows-h" ]::after { content: "\10f337"; }
.gsuiIcon[ data-icon="arrow-dropdown" ]::before { content: "\f34a"; }
.gsuiIcon[ data-icon="arrow-dropdown" ]::after { content: "\10f34a"; }

.gsuiIcon[ data-icon="sort" ]::before { content: "\f0dc"; }
.gsuiIcon[ data-icon="sort" ]::after { content: "\10f0dc"; }
.gsuiIcon[ data-icon="caret-up" ]::before { content: "\f0d8"; }
.gsuiIcon[ data-icon="caret-up" ]::after { content: "\10f0d8"; }
.gsuiIcon[ data-icon="caret-down" ]::before { content: "\f0d7"; }
.gsuiIcon[ data-icon="caret-down" ]::after { content: "\10f0d7"; }
.gsuiIcon[ data-icon="caret-left" ]::before { content: "\f0d9"; }
.gsuiIcon[ data-icon="caret-left" ]::after { content: "\10f0d9"; }
.gsuiIcon[ data-icon="caret-right" ]::before { content: "\f0da"; }
.gsuiIcon[ data-icon="caret-right" ]::after { content: "\10f0da"; }

.gsuiIcon[ data-icon="osc-sine" ]::before { content: "\f899"; }
.gsuiIcon[ data-icon="osc-sine" ]::after { content: "\10f899"; }
.gsuiIcon[ data-icon="osc-triangle" ]::before { content: "\f89a"; }
.gsuiIcon[ data-icon="osc-triangle" ]::after { content: "\10f89a"; }
.gsuiIcon[ data-icon="osc-square" ]::before { content: "\f83e"; }
.gsuiIcon[ data-icon="osc-square" ]::after { content: "\10f83e"; }

.gsuiIcon[ data-icon="undo" ]::before { content: "\f2ea"; }
.gsuiIcon[ data-icon="undo" ]::after { content: "\10f2ea"; }
.gsuiIcon[ data-icon="redo" ]::before { content: "\f2f9"; }
.gsuiIcon[ data-icon="redo" ]::after { content: "\10f2f9"; }
.gsuiIcon[ data-icon="undo" ]:hover::before { content: "\f0e2"; }
.gsuiIcon[ data-icon="undo" ]:hover::after { content: "\10f0e2"; }
.gsuiIcon[ data-icon="redo" ]:hover::before { content: "\f01e"; }
.gsuiIcon[ data-icon="redo" ]:hover::after { content: "\10f01e"; }

.gsuiIcon[ data-icon="play" ]::before { content: "\f04b"; opacity: .6; }
.gsuiIcon[ data-icon="play" ]::after { content: "\10f04b"; opacity: 1; }
.gsuiIcon[ data-icon="stop" ]::before { content: "\f04d"; opacity: .6; }
.gsuiIcon[ data-icon="stop" ]::after { content: "\10f04d"; opacity: 1; }
.gsuiIcon[ data-icon="loop" ]::before { content: "\f364"; }
.gsuiIcon[ data-icon="loop" ]::after { content: "\10f364"; }
.gsuiIcon[ data-icon="pause" ]::before { content: "\f04c"; opacity: .6; }
.gsuiIcon[ data-icon="pause" ]::after { content: "\10f04c"; opacity: 1; }
.gsuiIcon[ data-icon="eject" ]::before { content: "\f052"; }
.gsuiIcon[ data-icon="eject" ]::after { content: "\10f052"; }
.gsuiIcon[ data-icon="toggle" ]::before { content: "\f111"; opacity: .6; }
.gsuiIcon[ data-icon="toggle" ]::after { content: "\10f111"; opacity: 1; }

.gsuiIcon[ data-icon="circle" ]::before { content: "\f111"; opacity: .6; }
.gsuiIcon[ data-icon="circle" ]::after { content: "\10f111"; opacity: 1; }
.gsuiIcon[ data-icon="square" ]::before { content: "\f0c8"; opacity: .6; }
.gsuiIcon[ data-icon="square" ]::after { content: "\10f0c8"; opacity: 1; }
.gsuiIcon[ data-icon="triangle" ]::before { content: "\f2ec"; opacity: .6; }
.gsuiIcon[ data-icon="triangle" ]::after { content: "\10f2ec"; opacity: 1; }
.gsuiIcon[ data-icon="diamond" ]::before { content: "\f219"; opacity: .6; }
.gsuiIcon[ data-icon="diamond" ]::after { content: "\10f219"; opacity: 1; }
.gsuiIcon[ data-icon="heart" ]::before { content: "\f004"; opacity: .6; }
.gsuiIcon[ data-icon="heart" ]::after { content: "\10f004"; opacity: 1; }
.gsuiIcon[ data-icon="hexagon" ]::before { content: "\f312"; opacity: .6; }
.gsuiIcon[ data-icon="hexagon" ]::after { content: "\10f312"; opacity: 1; }
.gsuiIcon[ data-icon="octagon" ]::before { content: "\f306"; opacity: .6; }
.gsuiIcon[ data-icon="octagon" ]::after { content: "\10f306"; opacity: 1; }

.gsuiIcon[ data-icon="mute" ]::before { content: "\f2e2"; }
.gsuiIcon[ data-icon="mute" ]::after { content: "\10f2e2"; }
.gsuiIcon[ data-icon="unmute" ]::before { content: "\f028"; }
.gsuiIcon[ data-icon="unmute" ]::after { content: "\10f028"; }

.gsuiIcon[ data-icon="close" ]::before { content: "\f00d"; font-size: 1.15em; }
.gsuiIcon[ data-icon="close" ]::after { content: "\10f00d"; font-size: 1.15em; }
.gsuiIcon[ data-icon="restore" ]::before { content: "\f2d2"; }
.gsuiIcon[ data-icon="restore" ]::after { content: "\10f2d2"; }
.gsuiIcon[ data-icon="minimize" ]::before { content: "\f2d1"; }
.gsuiIcon[ data-icon="minimize" ]::after { content: "\10f2d1"; opacity: 1; }
.gsuiIcon[ data-icon="maximize" ]::before { content: "\f2d0"; }
.gsuiIcon[ data-icon="maximize" ]::after { content: "\10f2d0"; opacity: 0; }

.gsuiIcon[ data-icon="save" ]::before { content: "\f0c7"; }
.gsuiIcon[ data-icon="save" ]::after { content: "\10f0c7"; opacity: .4; }
.gsuiIcon[ data-icon="render" ]::before { content: "\f0e7"; }
.gsuiIcon[ data-icon="render" ]::after { content: "\10f0e7"; }
.gsuiIcon[ data-icon="upload" ]::before { content: "\f382"; opacity: 0; }
.gsuiIcon[ data-icon="upload" ]::after { content: "\10f382"; opacity: 1; }
.gsuiIcon[ data-icon="upload" ]:hover::before { content: "\f0ee"; opacity: 0; }
.gsuiIcon[ data-icon="upload" ]:hover::after { content: "\10f0ee"; opacity: 1; }
.gsuiIcon[ data-icon="export" ]::before { content: "\f019"; }
.gsuiIcon[ data-icon="export" ]::after { content: "\10f019"; }
.gsuiIcon[ data-icon="folder-open" ]::before { content: "\f07c"; }
.gsuiIcon[ data-icon="folder-open" ]::after { content: "\10f07c"; }
.gsuiIcon[ data-icon="folder-tree" ]::before { content: "\f802"; }
.gsuiIcon[ data-icon="folder-tree" ]::after { content: "\10f802"; }
.gsuiIcon[ data-icon="file-export" ]::before { content: "\f56e"; }
.gsuiIcon[ data-icon="file-export" ]::after { content: "\10f56e"; }
.gsuiIcon[ data-icon="file-corrupt" ]::before { content: "\f877"; }
.gsuiIcon[ data-icon="file-corrupt" ]::after { content: "\10f877"; }

.gsuiIcon[ data-icon="login" ]::before { content: "\f090"; }
.gsuiIcon[ data-icon="login" ]::after { content: "\10f090"; }
.gsuiIcon[ data-icon="login" ]:hover::before { content: "\f2f6"; }
.gsuiIcon[ data-icon="login" ]:hover::after { content: "\10f2f6"; }
.gsuiIcon[ data-icon="logout" ]::before { content: "\f08b"; }
.gsuiIcon[ data-icon="logout" ]::after { content: "\10f08b"; }
.gsuiIcon[ data-icon="logout" ]:hover::before { content: "\f2f5"; }
.gsuiIcon[ data-icon="logout" ]:hover::after { content: "\10f2f5"; }
.gsuiIcon[ data-icon="profile" ]::before { content: "\f2bd"; }
.gsuiIcon[ data-icon="profile" ]::after { content: "\10f2bd"; }
.gsuiIcon[ data-icon="musician" ]::before { content: "\f8eb"; }
.gsuiIcon[ data-icon="musician" ]::after { content: "\10f8eb"; }

.gsuiIcon[ data-icon="speed" ]::before { content: "\f625"; opacity: 0; }
.gsuiIcon[ data-icon="speed" ]::after { content: "\10f625"; opacity: 1; }
.gsuiIcon[ data-icon="clock" ]::before { content: "\f017"; }
.gsuiIcon[ data-icon="clock" ]::after { content: "\10f017"; opacity: .3; }
.gsuiIcon[ data-icon="history" ]::before { content: "\f1da"; }
.gsuiIcon[ data-icon="history" ]::after { content: "\10f1da"; }

.gsuiIcon[ data-icon="keys" ]::before { content: "\f8d5"; }
.gsuiIcon[ data-icon="keys" ]::after { content: "\10f8d5"; }
.gsuiIcon[ data-icon="drums" ]::before { content: "\f2a1"; }
.gsuiIcon[ data-icon="drums" ]::after { content: "\10f2a1"; }
.gsuiIcon[ data-icon="mixer" ]::before { content: "\f3f1"; }
.gsuiIcon[ data-icon="mixer" ]::after { content: "\10f3f1"; }
.gsuiIcon[ data-icon="music" ]::before { content: "\f001"; }
.gsuiIcon[ data-icon="music" ]::after { content: "\10f001"; }
.gsuiIcon[ data-icon="musics" ]::before { content: "\f8c9"; }
.gsuiIcon[ data-icon="musics" ]::after { content: "\10f8c9"; }
.gsuiIcon[ data-icon="effects" ]::before { content: "\f5fd"; }
.gsuiIcon[ data-icon="effects" ]::after { content: "\10f5fd"; }
.gsuiIcon[ data-icon="waveform" ]::before { content: "\f8f2"; }
.gsuiIcon[ data-icon="waveform" ]::after { content: "\10f8f2"; }
.gsuiIcon[ data-icon="oscillator" ]::before { content: "\f83e"; }
.gsuiIcon[ data-icon="oscillator" ]::after { content: "\10f83e"; opacity: 1; }
.gsuiIcon[ data-icon="glissando" ]::before { content: "\f667"; }
.gsuiIcon[ data-icon="glissando" ]::after { content: "\10f667"; }

.gsuiIcon[ data-icon="plus" ]::before { content: "\f067"; }
.gsuiIcon[ data-icon="plus" ]::after { content: "\10f067"; opacity: .7; }
.gsuiIcon[ data-icon="minus" ]::before { content: "\f068"; }
.gsuiIcon[ data-icon="minus" ]::after { content: "\10f068"; opacity: 1; }
.gsuiIcon[ data-icon="minus-oct" ]::before { content: "\f308"; }
.gsuiIcon[ data-icon="minus-oct" ]::after { content: "\10f308"; }

.gsuiIcon[ data-icon="check" ]::before { content: "\f00c"; }
.gsuiIcon[ data-icon="check" ]::after { content: "\10f00c"; }
.gsuiIcon[ data-icon="warning" ]::before { content: "\f071"; }
.gsuiIcon[ data-icon="warning" ]::after { content: "\10f071"; }
.gsuiIcon[ data-icon="redirect" ]::before { content: "\f5eb"; }
.gsuiIcon[ data-icon="redirect" ]::after { content: "\10f5eb"; opacity: .4; }

.gsuiIcon[ data-icon="pen" ]::before { content: "\f304"; }
.gsuiIcon[ data-icon="pen" ]::after { content: "\10f304"; }
.gsuiIcon[ data-icon="crop" ]::before { content: "\f125"; }
.gsuiIcon[ data-icon="crop" ]::after { content: "\10f125"; }
.gsuiIcon[ data-icon="erase" ]::before { content: "\f12d"; }
.gsuiIcon[ data-icon="erase" ]::after { content: "\10f12d"; }
.gsuiIcon[ data-icon="list" ]::before { content: "\f0ca"; }
.gsuiIcon[ data-icon="list" ]::after { content: "\10f0ca"; }

.gsuiIcon[ data-icon="local" ]::before { content: "\f8e6"; }
.gsuiIcon[ data-icon="local" ]::after { content: "\10f8e6"; opacity: .2; }
.gsuiIcon[ data-icon="cloud" ]::before { content: "\f8ae"; opacity: .2; }
.gsuiIcon[ data-icon="cloud" ]::after { content: "\10f8ae"; opacity: 1; }

.gsuiIcon[ data-icon="cookie" ]::before { content: "\f563"; }
.gsuiIcon[ data-icon="cookie" ]::after { content: "\10f563"; }
.gsuiIcon[ data-icon="cookie" ]:hover::before { content: "\f564"; }
.gsuiIcon[ data-icon="cookie" ]:hover::after { content: "\10f564"; }

.gsuiIcon[ data-icon="link" ]::before { content: "\f0c1"; }
.gsuiIcon[ data-icon="link" ]::after { content: "\10f0c1"; }
.gsuiIcon[ data-icon="unlink" ]::before { content: "\f127"; }
.gsuiIcon[ data-icon="unlink" ]::after { content: "\10f127"; }

.gsuiIcon[ data-icon="public" ]::before { content: "\f7a2"; }
.gsuiIcon[ data-icon="public" ]::after { content: "\10f7a2"; opacity: .4; }
.gsuiIcon[ data-icon="private" ]::before { content: "\f30d"; }
.gsuiIcon[ data-icon="private" ]::after { content: "\10f30d"; }

.gsuiIcon[ data-icon="grip-h" ]::before { content: "\f58d"; }
.gsuiIcon[ data-icon="grip-h" ]::after { content: "\10f58d"; }
.gsuiIcon[ data-icon="grip-v" ]::before { content: "\f58e"; }
.gsuiIcon[ data-icon="grip-v" ]::after { content: "\10f58e"; }

.gsuiIcon[ data-icon="clone" ]::before { content: "\f24d"; }
.gsuiIcon[ data-icon="clone" ]::after { content: "\10f24d"; }

.gsuiIcon[ data-icon="drumcut" ] { transform: rotate( 90deg ); }
.gsuiIcon[ data-icon="drumcut" ]::before { content: "\f052"; }
.gsuiIcon[ data-icon="drumcut" ]::after { content: "\10f052"; }
.gsuiIcon[ data-icon="drumprops" ] { transform: rotate( -90deg ); }
.gsuiIcon[ data-icon="drumprops" ]::before { content: "\f884"; }
.gsuiIcon[ data-icon="drumprops" ]::after { content: "\10f884"; }

.gsuiIcon[ data-icon="smiley" ]::before { content: "\f581"; opacity: 0; }
.gsuiIcon[ data-icon="smiley" ]::after { content: "\10f581"; opacity: 1; }

.gsuiIcon[ data-icon="bug" ]::before { content: "\f188"; }
.gsuiIcon[ data-icon="bug" ]::after { content: "\10f188"; }

.gsuiIcon[ data-icon="mouse" ]::before { content: "\f245"; }
.gsuiIcon[ data-icon="mouse" ]::after { content: "\10f245"; opacity: 1; }

.gsuiIcon[ data-icon="magnet" ]::before { content: "\f076"; }
.gsuiIcon[ data-icon="magnet" ]::after { content: "\10f076"; }

.gsuiIcon[ data-icon="tint" ]::before { content: "\f043"; }
.gsuiIcon[ data-icon="tint" ]::after { content: "\10f043"; }

.gsuiIcon[ data-icon="settings" ]::before { content: "\f013"; }
.gsuiIcon[ data-icon="settings" ]::after { content: "\10f013"; }
.gsuiIcon[ data-icon="help" ]::before { content: "\f0fa"; }
.gsuiIcon[ data-icon="help" ]::after { content: "\10f0fa"; }
.gsuiIcon[ data-icon="changelog" ]::before { content: "\f70e"; }
.gsuiIcon[ data-icon="changelog" ]::after { content: "\10f70e"; }
.gsuiIcon[ data-icon="about" ]::before { content: "\f30e"; }
.gsuiIcon[ data-icon="about" ]::after { content: "\10f30e"; }

.gsuiIcon[ data-icon="rocket" ]::before { content: "\f135"; }
.gsuiIcon[ data-icon="rocket" ]::after { content: "\10f135"; }

.gsuiIcon[ data-icon="keyboard" ]::before { content: "\f11c"; }
.gsuiIcon[ data-icon="keyboard" ]::after { content: "\10f11c"; }
.gsuiEnvelope {
	--gsuiEnvelope-bg: #666;
	--gsuiEnvelope-txt: #fff;
	--gsuiEnvelope-head-bg: #111738;
	--gsuiEnvelope-wave-bg: #0004;
	--gsuiEnvelope-wave-off: #777;
	--gsuiEnvelope-ctrls-bg: #555;
	--gsuiEnvelope-ctrls-color: #ff9;
	--gsuiEnvelope-toggle-off: #fff3;
}
.gsuiEnvelope {
	display: grid;
	height: 100%;
	box-sizing: border-box;
	grid-gap: 6px;
	grid-template:
		"head head   head  head  head     head    head" 24px
		".    attack hold  decay substain release .   " 28px
		".    graph  graph graph graph    graph   .   " 1fr
		".    .      .     .     .        .       .   " 0
		/0    1fr    1fr   1fr   1fr      1fr     0;
	color: var( --gsuiEnvelope-txt );
	font-family: var( --gsui-font );
	background-color: var( --gsuiEnvelope-bg );
	--gsuiSlider-lineColor: var( --gsuiEnvelope-ctrls-color );
	--gsuiSlider-lineBgColor: var( --gsuiEnvelope-ctrls-bg );
}

/* .......................................................................... */
.gsuiEnvelope-prop {
	display: flex;
	flex-direction: column;
}
.gsuiEnvelope-propLabel {
	display: flex;
	align-self: center;
	align-items: baseline;
	height: 20px;
	font-size: 12px;
	opacity: .5;
	user-select: none;
}
.gsuiEnvelope-propValue::before {
	content: "?";
	margin: 0 2px;
}
.gsuiEnvelope-propValue {
	font-family: var( --gsui-font-number );
}
.gsuiEnvelope-propContent {
	flex: 1;
	position: relative;
}

/* .......................................................................... */
.gsuiEnvelope-attack {
	grid-area: attack;
}
.gsuiEnvelope-hold {
	grid-area: hold;
}
.gsuiEnvelope-decay {
	grid-area: decay;
}
.gsuiEnvelope-substain {
	grid-area: substain;
}
.gsuiEnvelope-release {
	grid-area: release;
}
.gsuiEnvelope .gsuiSlider-eventCatcher {
	top: -26px;
	bottom: -6px;
}

/* .......................................................................... */
.gsuiEnvelope-head {
	grid-area: head;
	display: flex;
	align-items: center;
	background-color: var( --gsuiEnvelope-head-bg );
	user-select: none;
}
.gsuiEnvelope-title {
	font-size: 14px;
	opacity: .3;
}
.gsuiEnvelope-toggle {
	display: flex;
	align-items: center;
	justify-content: center;
	align-self: normal;
	border: 0;
	margin: 0;
	outline: 0;
	padding: 0;
	width: 24px;
	color: var( --gsuiEnvelope-toggle-off );
	font-size: 8px;
	cursor: pointer;
	background: none;
	transition: .2s color;
}
.gsuiEnvelope-enable .gsuiEnvelope-toggle {
	color: var( --gsuiEnvelope-ctrls-color );
}
.gsuiEnvelope-toggleCheckbox {
	display: none;
}

/* .......................................................................... */
.gsuiEnvelope-graph {
	grid-area: graph;
	position: relative;
	overflow: hidden;
	border-radius: 4px;
	background-color: var( --gsuiEnvelope-wave-bg );
}
.gsuiEnvelope-graph svg {
	position: absolute;
	/*top: 6px;*/
	/*height: calc( 100% - 12px );*/
	color: var( --gsuiEnvelope-wave-off );
	stroke-width: 2px;
	transition: color .2s;
}
.gsuiEnvelope-enable svg {
	color: var( --gsuiEnvelope-ctrls-color );
}
.gsuiLFO {
	--gsuiLFO-bg: #666;
	--gsuiLFO-txt: #fff;
	--gsuiLFO-head-bg: #111738;
	--gsuiLFO-wave-bg: #0004;
	--gsuiLFO-wave-off: #777;
	--gsuiLFO-ctrls-bg: #555;
	--gsuiLFO-ctrls-color: #ff9;
	--gsuiLFO-toggle-off: #fff3;
}
.gsuiLFO {
	display: grid;
	height: 100%;
	box-sizing: border-box;
	grid-gap: 6px;
	grid-template:
		"head head head  head   head  head  head" 24px
		".    type delay attack speed amp   .   " 28px
		".    type graph graph  graph graph .   " 1fr
		".    .    .     .      .     .     .   " 0
		/0    32px 1fr   1fr    1fr   1fr   0;
	color: var( --gsuiLFO-txt );
	font-family: var( --gsui-font );
	background-color: var( --gsuiLFO-bg );
	--gsuiSlider-lineColor: var( --gsuiLFO-ctrls-color );
	--gsuiSlider-lineBgColor: var( --gsuiLFO-ctrls-bg );
}

/* .......................................................................... */
.gsuiLFO-prop {
	display: flex;
	flex-direction: column;
}
.gsuiLFO-propLabel {
	display: flex;
	align-self: center;
	align-items: baseline;
	height: 20px;
	font-size: 12px;
	opacity: .5;
	user-select: none;
}
.gsuiLFO-propValue::before {
	content: "?";
	margin: 0 2px;
}
.gsuiLFO-propValue {
	font-family: var( --gsui-font-number );
}
.gsuiLFO-propContent {
	flex: 1;
	position: relative;
}

/* .......................................................................... */
.gsuiLFO-btn {
	position: relative;
	cursor: pointer;
}
.gsuiLFO-btnInput {
	position: absolute;
	visibility: hidden;
}
.gsuiLFO-btnIcon {
	position: absolute;
	top: 0;
	left: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	height: 100%;
	background-color: var( --gsuiLFO-ctrls-bg );
}

/* .......................................................................... */
.gsuiLFO-delay {
	grid-area: delay;
}
.gsuiLFO-attack {
	grid-area: attack;
}
.gsuiLFO-amp {
	grid-area: amp;
}
.gsuiLFO-speed {
	grid-area: speed;
}
.gsuiLFO .gsuiSlider-eventCatcher {
	top: -26px;
	bottom: -6px;
}

/* .......................................................................... */
.gsuiLFO-head {
	grid-area: head;
	display: flex;
	align-items: center;
	background-color: var( --gsuiLFO-head-bg );
	user-select: none;
}
.gsuiLFO-title {
	font-size: 14px;
	opacity: .3;
}
.gsuiLFO-toggle {
	align-self: normal;
	border: 0;
	margin: 0;
	outline: 0;
	padding: 0;
	width: 24px;
	color: var( --gsuiLFO-toggle-off );
	font-size: 8px;
	background: none;
	transition: .2s color;
}
.gsuiLFO-enable .gsuiLFO-toggle {
	color: var( --gsuiLFO-ctrls-color );
}

/* .......................................................................... */
.gsuiLFO-graph {
	grid-area: graph;
	position: relative;
	overflow: hidden;
	border-radius: 4px;
	background-color: var( --gsuiLFO-wave-bg );
}
.gsuiLFO-ampSigns {
	position: absolute;
	display: flex;
	flex-direction: column;
	top: 0;
	left: 0;
	bottom: 0;
	width: 10px;
}
.gsuiLFO-ampSign {
	flex: 1;
}
.gsuiLFO-enable .gsuiLFO-ampSign {
	color: var( --gsuiLFO-ctrls-color );
}
.gsuiLFO-ampSignIcon {
	color: var( --gsuiLFO-wave-off );
	font-size: 11px;
}
.gsuiLFO-enable .gsuiLFO-ampSignIcon {
	color: var( --gsuiLFO-ctrls-color );
}
.gsuiLFO-ampSignRadio:checked + .gsuiLFO-ampSignIcon {
	color: var( --gsuiLFO-ctrls-bg );
	background-color: var( --gsuiLFO-wave-off );
}
.gsuiLFO-enable .gsuiLFO-ampSignRadio:checked + .gsuiLFO-ampSignIcon {
	background-color: var( --gsuiLFO-ctrls-color );
}
.gsuiLFO-wave {
	position: absolute;
	top: 0;
	left: 8px;
	right: -2px;
	bottom: 0;
	pointer-events: none;
}
.gsuiLFO-wave .gsuiPeriodicWave {
	position: absolute;
	top: 6px;
	height: calc( 100% - 12px );
	color: var( --gsuiLFO-wave-off );
	stroke-width: 2px;
	transition: color .2s;
}
.gsuiLFO-enable .gsuiPeriodicWave {
	color: var( --gsuiLFO-ctrls-color );
}

/* .......................................................................... */
.gsuiLFO-type {
	grid-area: type;
}
.gsuiLFO-type .gsuiLFO-propContent {
	display: flex;
	overflow: hidden;
	border-radius: 4px;
	flex-direction: column;
}
.gsuiLFO-typeBtn {
	flex: 1;
}
.gsuiLFO-typeSVG {
	fill: none;
	stroke: var( --gsuiLFO-wave-off );
	stroke-width: 2px;
	background-color: var( --gsuiLFO-ctrls-bg );
	transition: .2s;
	transition-property: stroke, background-color;
}
.gsuiLFO-enable .gsuiLFO-typeSVG {
	stroke: var( --gsuiLFO-ctrls-color );
}
.gsuiLFO-typeSVG path {
	transform: scale( .6 );
	transform-origin: center;
}
.gsuiLFO-typeRadio:checked + .gsuiLFO-typeSVG {
	stroke: var( --gsuiLFO-ctrls-bg );
	background-color: var( --gsuiLFO-wave-off );
}
.gsuiLFO-enable .gsuiLFO-typeRadio:checked + .gsuiLFO-typeSVG {
	background-color: var( --gsuiLFO-ctrls-color );
}
:root {
	--gsuiDrumrow-bg: #555;
	--gsuiDrumrow-slider-bg: #444;
	--gsuiDrumrow-pan: #d9f;
	--gsuiDrumrow-gain: #ff9;
	--gsuiDrumrow-detune: #fff;
	--gsuiDrumrow-border: #0002;
	--gsuiDrumrow-color: #fff;
	--gsuiDrumrow-grip-bg: #0001;
	--gsuiDrumrow-toggle-bg: #ffa;
	--gsuiDrumrow-toggleOff-bg: #fff3;
	--gsuiDrumrow-prop-bgHover: #fff2;
}
.gsuiDrumrows {
	display: flex;
	flex-direction: column;
	font-size: var( --gsuiTimewindow-lineH );
}
.gsuiDrumrows::-webkit-scrollbar {
	display: none;
}

/* .......................................................................... */
.gsuiDrumrows-drop {
	display: none;
	height: 1em;
	order: 1;
	align-items: center;
	justify-content: center;
	pointer-events: none;
}
.gsuiDrumrows-dragover > .gsuiDrumrows-drop {
	display: flex;
}
.gsuiDrumrows-dropIn {
	font-size: 24px;
	opacity: .5;
}

/* .......................................................................... */
.gsuiDrumrow {
	--grip-w: 16px;
	--toggle-w: 20px;
	--name-h: 16px;
	--propsExpand-w: 16px;
	--delete-w: 14px;
	--slider-w: 7px;
	--props-h: 1.5em;
	position: relative;
	box-sizing: border-box;
	height: calc( 1em + 1px );
	min-height: calc( 1em + 1px );
	margin-top: -1px;
	border: 0 solid var( --gsuiDrumrow-border );
	border-width: 1px 0;
	background-color: var( --gsuiDrumrow-bg );
	transition: .2s height, .2s min-height, .1s filter;
}
.gsuiDrumrow-mute {
	--gsuiDrumrow-toggle-bg: var( --gsuiDrumrow-toggleOff-bg );
	filter: brightness( .8 ) contrast( .8 );
}
.gsuiDrumrow-open {
	height: calc( 1em + 1px + var( --props-h ) );
	min-height: calc( 1em + 1px + var( --props-h ) );
}

/* .......................................................................... */
.gsuiDrumrow-main {
	position: absolute;
	box-sizing: border-box;
	top: 0;
	left: var( --grip-w );
	right: 0;
	height: 1em;
	min-height: 1em;
	border-bottom: 1px dashed var( --gsuiDrumrow-border );
}
.gsuiDrumrow-props {
	position: absolute;
	overflow: hidden;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 1em;
	left: var( --grip-w );
	right: 0;
	bottom: 0;
}
.gsuiDrumrow-prop {
	outline: 0;
	font-size: 11px;
	font-weight: bold;
	font-family: inherit;
	cursor: pointer;
}
.gsuiDrumrow-propPan { --color: var( --gsuiDrumrow-pan ); }
.gsuiDrumrow-propGain { --color: var( --gsuiDrumrow-gain ); }
.gsuiDrumrow-propDetune { --color: var( --gsuiDrumrow-detune ); }
.gsuiDrumrow-prop + .gsuiDrumrow-prop {
	margin-left: 4px;
}
.gsuiDrumrow-propRadio {
	position: absolute;
	visibility: hidden;
}
.gsuiDrumrow-propSpan {
	color: var( --color );
	padding: 2px 4px;
	border-radius: 3px;
	opacity: 0;
	transition: .1s background-color, .2s opacity;
}
.gsuiDrumrow-propSpanValue {
	font-size: 14px;
	font-family: var( --gsui-font-number );
}
.gsuiDrumrow-open .gsuiDrumrow-propSpan {
	opacity: 1;
}
.gsuiDrumrow-propSpan:focus,
.gsuiDrumrow-propSpan:hover {
	background-color: var( --gsuiDrumrow-prop-bgHover );
}
.gsuiDrumrow-propRadio:checked + .gsuiDrumrow-propSpan {
	color: var( --gsuiDrumrow-bg );
	background-color: var( --color );
}

/* .......................................................................... */
.gsuiDrumrow-grip {
	position: absolute;
	width: var( --grip-w );
	top: 0;
	left: 0;
	bottom: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 12px;
	cursor: grab;
	background-color: var( --gsuiDrumrow-grip-bg );
}
.gsuiDrumrow-grip .gsuiIcon {
	pointer-events: none;
	opacity: .4;
}
.gsuiDrumrow-btnToggle {
	position: absolute;
	left: 0;
	width: var( --toggle-w );
	height: var( --name-h );
	top: 0;
	border: 0;
	outline: 0;
	padding: 0;
	font-size: 8px;
	color: var( --gsuiDrumrow-toggle-bg );
	cursor: pointer;
	background: none;
	transition: .1s opacity;
}
.gsuiDrumrow-name {
	position: absolute;
	top: 0;
	left: var( --toggle-w );
	right: calc( var( --delete-w ) + var( --propsExpand-w ) + 6px );
	height: var( --name-h );
	line-height: var( --name-h );
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	font-size: 12px;
	font-weight: bold;
	pointer-events: none;
}
.gsuiDrumrow-nameInfo {
	font-style: italic;
	font-weight: normal;
	opacity: .7;
}

/* .......................................................................... */
.gsuiDrumrow-waveWrap {
	position: absolute;
	overflow: hidden;
	top: var( --name-h );
	left: 0;
	right: calc( var( --slider-w ) * 3 + 8px );
	bottom: 0;
	pointer-events: none;
}
.gsuiDrumrow-wave {
	position: absolute;
	top: 0;
	width: 100%;
	height: 100%;
	fill: currentColor;
	opacity: .5;
}
.gsuiDrumrow-startCursor {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	border-right: 2px solid;
	background-image: linear-gradient( 90deg, transparent 0%, currentColor 300% );
	animation-name: gsuiDrumrow-startCursor-anim;
	animation-duration: inherit;
	animation-fill-mode: forwards;
	animation-timing-function: linear;
}
.gsuiDrumrow-mute .gsuiDrumrow-startCursor {
	visibility: hidden;
}
@keyframes gsuiDrumrow-startCursor-anim {
	from { left: -100%; }
	to { left: 100%; }
}

/* .......................................................................... */
.gsuiDrumrow-detune,
.gsuiDrumrow-pan,
.gsuiDrumrow-gain {
	--gsuiSlider-lineBgColor: var( --gsuiDrumrow-slider-bg );
	position: absolute;
	top: var( --name-h );
	width: var( --slider-w );
	bottom: 2px;
}
.gsuiDrumrow .gsuiSlider-eventCatcher {
	top: -2px;
	left: -2px;
	right: -2px;
	bottom: -2px;
}
.gsuiDrumrow-detune {
	--gsuiSlider-lineColor: var( --gsuiDrumrow-detune );
	right: calc( 2 * var( --slider-w ) + 6px );
}
.gsuiDrumrow-pan {
	--gsuiSlider-lineColor: var( --gsuiDrumrow-pan );
	right: calc( var( --slider-w ) + 4px );
}
.gsuiDrumrow-gain {
	--gsuiSlider-lineColor: var( --gsuiDrumrow-gain );
	right: 2px;
}

/* .......................................................................... */
.gsuiDrumrow.gsuiDrumrows-dragover .gsuiDrumrow-btnToggle,
.gsuiDrumrow.gsuiDrumrows-dragover .gsuiDrumrow-name,
.gsuiDrumrow.gsuiDrumrows-dragover .gsuiDrumrow-waveWrap {
	opacity: 0;
}
.gsuiDrumrow .gsuiDrumrows-drop {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}
.gsuiDrumrow-btnProps,
.gsuiDrumrow-btnDelete {
	position: absolute;
	right: 0;
	border: 0;
	outline: 0;
	padding: 0;
	width: var( --delete-w );
	height: var( --name-h );
	color: inherit;
	cursor: pointer;
	font-size: 12px;
	background: none;
	opacity: .3;
	transition: .1s opacity;
}
.gsuiDrumrow-btnProps {
	right: calc( var( --delete-w ) + 2px );
	width: var( --propsExpand-w );
	opacity: .5;
}
.gsuiDrumrow-open .gsuiDrumrow-btnProps {
	text-shadow: 0 0 6px;
	opacity: .8;
}
.gsuiDrumrow .gsuiDrumrow-btnProps:hover,
.gsuiDrumrow .gsuiDrumrow-btnProps:focus,
.gsuiDrumrow .gsuiDrumrow-btnDelete:hover,
.gsuiDrumrow .gsuiDrumrow-btnDelete:focus {
	opacity: 1;
}
:root {
	--gsuiDrums-color: #fff;
	--gsuiDrums-drum-bg: #5acd;
	--gsuiDrums-drum-color: #000;
	--gsuiDrums-drumprop-bg: #0002;
	--gsuiDrums-drumprop-color: #0004;
	--gsuiDrums-drumcut-bg: #48ad;
	--gsuiDrums-line-border: #2e4145;
	--gsuiDrums-line-mute-bg: #0003;
	--gsuiDrums-loop-bg: #000;
	--gsuiDrums-currentTime-bg: #ff91;
	--gsuiDrums-drumHover-border: #5ac;
	--gsuiDrums-drumHover-bg: #5ac3;
	--gsuiDrums-shadow-bg: #000a;
}
.gsuiDrums {
	display: block;
	height: 100%;
	color: var( --gsuiDrums-color );
}

/* .......................................................................... */
.gsuiDrums .gsuiTimewindow-currentTime {
	margin-left: 0;
	opacity: .1;
}
.gsuiDrums .gsuiTimewindow-step {
	display: none;
}

/* .......................................................................... */
.gsuiDrums-shadow {
	position: absolute;
	z-index: 1;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: var( --gsuiDrums-shadow-bg );
	opacity: 0;
	visibility: hidden;
	transition: .2s;
	transition-property: opacity, visibility;
}
.gsuiDrums-shadowed .gsuiDrums-shadow {
	opacity: 1;
	visibility: visible;
}

/* .......................................................................... */
.gsuiDrums-line.gsuiReorder-dragging {
	opacity: .5;
	background: #B82587;
}
.gsuiDrums-line {
	position: relative;
	width: 1000000px;
	font-size: var( --gsuiTimewindow-lineH );
	height: 1em;
	box-sizing: border-box;
	border-bottom: 1px solid var( --gsuiDrums-line-border );
	transition: .2s height, .1s filter, .1s background-color;
}
.gsuiDrums-lineOpen {
	height: calc( 1em + 1.5em );
}
.gsuiDrums-line.gsuiDrumrow-mute {
	filter: brightness( .8 ) contrast( .8 );
	background-color: var( --gsuiDrums-line-mute-bg );
}
.gsuiDrums-lineDrums {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	height: 1em;
}
.gsuiDrums-lineIn {
	height: 100%;
	box-sizing: border-box;
	border-bottom: 1px dashed var( --gsuiDrums-line-border );
	font-size: var( --gsuiTimewindow-pxperbeat );
	cursor: pointer;
}
.gsuiDrums-lineProps {
	position: absolute;
	top: 1em;
	left: 0;
	right: 0;
	bottom: 0;
}

/* .......................................................................... */
.gsuiDrums-drumHover,
.gsuiDrums-drumcutHover {
	position: absolute;
	z-index: 1;
	background: #B82587;
}
.gsuiDrums-drumHover {
	height: 66%;
}
.gsuiDrums-drumcutHover {
	bottom: 0;
	height: 34%;
}
.gsuiDrums-drumcutHoverIn,
.gsuiDrums-drumHoverIn {
	box-sizing: border-box;
	height: 100%;
	margin: 0 1px 1px 0;
	border: 2px solid var( --gsuiDrums-drumHover-border );
	border-radius: 4px;
	background-color: var( --gsuiDrums-drumHover-bg );
	pointer-events: none;
}

/* .......................................................................... */
.gsuiDrums-drum,
.gsuiDrums-drumcut {
	position: absolute;
	width: 1em;
}
.gsuiDrums-drum {
	height: 66%;
}
.gsuiDrums-drumcut {
	bottom: 1px;
	height: calc( 34% - 2px );
}
.gsuiDrums-previewDeleted,
.gsuiDrums-preview {
	opacity: .4;
}
.gsuiDrums-drumIn,
.gsuiDrums-drumcutIn {
	display: flex;
	align-items: center;
	flex-direction: column;
	justify-content: center;
	height: 100%;
	margin: 0 1px 1px 0;
	border-radius: 2px;
	color: var( --gsuiDrums-drum-color );
	background-color: var( --gsuiDrums-drum-bg );
	pointer-events: none;
}
.gsuiDrums-drumcutIn {
	font-size: 10px;
	background-color: var( --gsuiDrums-drumcut-bg );
}
.gsuiDrums-drumcutIn .gsuiIcon {
	opacity: .7;
}
.gsuiDrums-drumProp {
	position: relative;
	width: 100%;
	height: 3px;
	background-color: var( --gsuiDrums-drumprop-bg );
	transition: .1s height;
}
.gsuiDrums-lineOpen[ data-prop="pan" ] .gsuiDrums-drumProp[ data-value="pan" ],
.gsuiDrums-lineOpen[ data-prop="gain" ] .gsuiDrums-drumProp[ data-value="gain" ],
.gsuiDrums-lineOpen[ data-prop="detune" ] .gsuiDrums-drumProp[ data-value="detune" ] {
	height: 6px;
}
.gsuiDrums-drumProp + .gsuiDrums-drumProp {
	margin-top: 2px;
}
.gsuiDrums-drumPropValue {
	position: absolute;
	height: 100%;
	background-color: var( --gsuiDrums-drumprop-color );
}
.gsuiClock {
	--gsuiClock-bg: #444;
	--gsuiClock-color: #ddd;
}
.gsuiClock {
	display: flex;
	user-select: none;
	color: var( --gsuiClock-color );
	border-radius: 4px;
	font-size: 22px;
}

.gsuiClock-relative {
	position: relative;
	padding-left: 8px;
	border-top-left-radius: inherit;
	border-bottom-left-radius: inherit;
	background-color: var( --gsuiClock-bg );
}
.gsuiClock-absolute {
	display: flex;
	position: absolute;
	white-space: nowrap;
	align-items: baseline;
	padding-top: 3px;
	font-family: var( --gsui-font-number );
}

.gsuiClock-modes {
	position: relative;
	display: flex;
	margin: 0;
	border: 0;
	outline: 0;
	padding: 6px 8px;
	border-top-right-radius: inherit;
	border-bottom-right-radius: inherit;
	cursor: pointer;
	color: inherit;
	font-size: inherit;
	background-color: var( --gsuiClock-bg );
	flex-direction: column;
	justify-content: space-between;
}
.gsuiClock-modes:focus {
	box-shadow: 0 0 1px 2px #69b;
}
.gsuiClock-mode {
	width: 8px;
	height: 8px;
	border: 2px solid;
	border-radius: 2px;
	box-sizing: border-box;
	opacity: .5;
}
.gsuiClock[ mode="beat" ] .gsuiClock-beat,
.gsuiClock[ mode="second" ] .gsuiClock-second {
	opacity: 1;
	background-color: currentColor;
}

.gsuiClock-b::before {
	content: ":";
	margin: 0 .1em;
}
.gsuiClock-c {
	font-size: 14px;
	opacity: .5;
}
.gsuiClock-c::before {
	content: ".";
	margin: 0 .2em;
}
.gsuiMixer {
	--gsuiMixer-bg: initial;
	--gsuiMixerChannel-bg: #555;
	--gsuiMixerChannel-bg2: #C7C7C7;
	--gsuiMixerChannel-color: #fff;
	--gsuiMixerChannel-selected-bg: #666;
	--gsuiMixerChannel-width: 52px;
	--gsuiMixerChannel-pan-color: #FF47E7;
	--gsuiMixerChannel-gain-color: #00DDFF;
	--gsuiMixerChannel-connect-input-color: #f99;
	--gsuiMixerChannel-connect-output-color: #ff9;
	--gsuiMixerChannel-toggle-bg: #ffa;
	--gsuiMixerChannel-toggleOff-bg: #fff2;
	--gsuiMixerChannel-analyser-bg: #222;
	--gsuiMixerChannel-name-font: var( --font-default );
}
.gsuiMixer {
	height: 100%;
	position: relative;
	color: var( --gsuiMixerChannel-color );
	background-color: var( --gsuiMixer-bg );
	user-select: none;
	-webkit-user-select: none;
}

.gsuiMixer-panMain,
.gsuiMixer-panChannels {
	position: absolute;
	overflow: hidden;
	top: 0;
	left: 0;
	bottom: 0;
}

/* .gsuiMixer-panChannels */
/* .......................................................................... */
.gsuiMixer-panChannels {
	left: calc( var( --gsuiMixerChannel-width ) + 6px );
	right: 0;
	display: grid;
	overflow-x: scroll;
	grid-auto-flow: column;
	grid-auto-columns: min-content;
}
.gsuiMixer-panChannels::after {
	order: 2147483647;
	content: ".";
	opacity: 0;
	margin-left: 16px;
}
.gsuiMixer-panChannels .gsuiMixerChannel:nth-child( odd ) {
	--gsuiMixerChannel-bg: var( --gsuiMixerChannel-bg2 );
}

/* .gsuiMixer-addChan */
/* .......................................................................... */
.gsuiMixer-addChan {
	position: relative;
	order: 2147483646;
	width: 52px;
	border: 0;
	padding: 0;
	outline: 0;
	font-size: 18px;
	color: inherit;
	cursor: pointer;
	border-radius: 2px;
	background: none;
	opacity: .4;
	transition: .2s opacity;
}
.gsuiMixer-addChan:focus,
.gsuiMixer-addChan:hover {
	opacity: .6;
}
.gsuiMixer-addChan::before {
	content: "";
	top: 6px;
	left: 6px;
	right: 6px;
	bottom: 6px;
	opacity: .4;
	border: 2px dashed;
	position: absolute;
}

/* .gsuiMixerChannel */
/* .......................................................................... */
.gsuiMixerChannel {
	display: flex;
	position: relative;
	align-items: center;
	flex-direction: column;
	height: 100%;
	width: var( --gsuiMixerChannel-width );
	min-width: var( --gsuiMixerChannel-width );
	background-color: var( --gsuiMixerChannel-bg );
	--gsuiSlider-lineBgColor: rgba( 0, 0, 0, .2 );
}
.gsuiMixer .gsuiMixerChannel.gsuiMixer-selected {
	--gsuiMixerChannel-bg: var( --gsuiMixerChannel-selected-bg );
}
.gsuiMixerChannel-muted {
	--gsuiMixerChannel-toggle-bg: var( --gsuiMixerChannel-toggleOff-bg );
}
.gsuiMixerChannel-muted .gsuiSlider {
	--gsuiSlider-lineColor: rgba( 255, 255, 255, .3 );
}

/* .......................................................................... */
.gsuiMixerChannel-delete {
	display: flex;
	position: absolute;
	align-items: center;
	justify-content: center;
	top: 2px;
	right: 2px;
	border: 0;
	opacity: 0;
	padding: 0;
	outline: 0;
	color: inherit;
	cursor: pointer;
	font-size: 12px;
	line-height: 1em;
	background: none;
	transition: opacity .2s;
}
.gsuiMixer-panMain .gsuiMixerChannel-delete {
	display: none;
}
.gsuiMixerChannel:hover .gsuiMixerChannel-delete {
	opacity: .5;
}
.gsuiMixerChannel .gsuiMixerChannel-delete:focus,
.gsuiMixerChannel .gsuiMixerChannel-delete:hover {
	opacity: 1;
}

/* .......................................................................... */
.gsuiMixerChannel-nameWrap {
	display: flex;
	align-items: center;
	justify-content: center;
	box-sizing: border-box;
	overflow: hidden;
	width: 100%;
	border: 0;
	outline: 0;
	padding: 3px;
	color: inherit;
	height: 34px;
	min-height: 34px;
	font-size: 12px;
	font-family: var( --gsuiMixerChannel-name-font );
	background-color: transparent;
}
.gsuiMixerChannel-name {
	display: block;
	overflow: hidden;
	word-wrap: break-word;
	text-align: center;
	font-size: 10px;
	padding-right: .15ch;
	user-select: none;
	-webkit-user-select: none;
}
.gsuiMixerChannel.gsuiMixer-selected .gsuiMixerChannel-name {
	font-weight: bold;
}
.gsuiMixerChannel-muted .gsuiMixerChannel-name {
	opacity: .5;
}
.gsuiMixer-panMain .gsuiMixerChannel-name {
	font-style: italic;
}

/* .......................................................................... */
.gsuiMixerChannel-analyserWrap {
	position: relative;
	flex: 10;
	width: 100%;
	max-height: 160px;
}
.gsuiMixer-selected .gsuiMixerChannel-analyserWrap {
	box-shadow: 0 -2px var( --gsuiMixerChannel-gain-color );
}
.gsuiMixerChannel-analyser {
	position: absolute;
	width: 100%;
	height: 100%;
	opacity: .8;
	background: #B82587;
}

/* .......................................................................... */
.gsuiMixerChannel-toggle {
	width: 100%;
	border: 0;
	padding: 0;
	outline: 0;
	font-size: 8px;
	min-height: 18px;
	cursor: pointer;
	color: var( --gsuiMixerChannel-toggle-bg );
	background: none;
}

/* .......................................................................... */
.gsuiMixerChannel-pan {
	width: 100%;
	height: 24px;
	min-height: 24px;
	z-index: 1;
	overflow: hidden;
	--gsuiSlider-lineColor: var( --gsuiMixerChannel-pan-color );
}
.gsuiMixerChannel-gain {
	flex: 1;
	width: 6px;
	height: 48px;
	margin-top: 6px;
	min-height: 32px;
	--gsuiSlider-lineColor: var( --gsuiMixerChannel-gain-color );
}
.gsuiMixerChannel-gain .gsuiSlider-eventCatcher {
	left: -12px;
	right: -12px;
}

/* .......................................................................... */
.gsuiMixerChannel-connect {
	width: 100%;
	border: 0;
	padding: 0;
	outline: 0;
	z-index: 1;
	height: 16px;
	min-height: 16px;
	cursor: pointer;
	font-size: 16px;
	background-color: transparent;
}
.gsuiMixerChannel-connectA {
	color: var( --gsuiMixerChannel-connect-output-color );
}
.gsuiMixerChannel-connectB {
	color: var( --gsuiMixerChannel-connect-input-color );
}

/* .......................................................................... */
.gsuiMixerChannel-grip {
	width: 100%;
	height: 18px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 12px;
	cursor: grab;
	opacity: .6;
	background: #B82587;
}
.gsuiMixer-panMain .gsuiMixerChannel-grip {
	visibility: hidden;
	pointer-events: none;
}
.gsuiCurves {
	display: block;
	position: relative;
	height: 100%;
}
.gsuiCurves-svg {
	position: absolute;
	width: 100%;
	height: 100%;
}
.gsuiCurves-markText {
	fill: currentColor;
	font-size: 10px;
	opacity: .2;
}
.gsuiCurves-markBg {
	fill: currentColor;
	opacity: .025;
}
.gsuiCurves-line {
	stroke: currentColor;
	stroke-width: 2;
	stroke-dasharray: 4;
	opacity: .1;
}
.gsuiCurves-curve {
	fill: none;
	stroke: currentColor;
	stroke-width: 3;
}
:root {
	--gsuiEffects-color: #fff;
}

.gsuiEffects {
	display: flex;
	flex-direction: column;
	color: var( --gsuiEffects-color );
}

/* .......................................................................... */
.gsuiEffects-list {
	display: flex;
	overflow: auto;
	flex-direction: column;
}

/* .......................................................................... */
.gsuiEffects-addBtn {
	position: relative;
	order: 2147483646;
	border: 0;
	outline: 0;
	width: 100%;
	height: 52px;
	color: inherit;
	font-size: 18px;
	cursor: pointer;
	border-radius: 2px;
	background: none;
	opacity: .4;
	transition: .2s opacity;
}
.gsuiEffects-addBtn:focus,
.gsuiEffects-addBtn:hover {
	opacity: .6;
}
.gsuiEffects-addBtn::before {
	content: "";
	top: 6px;
	left: 6px;
	right: 6px;
	bottom: 6px;
	opacity: .4;
	border: 2px dashed;
	position: absolute;
}
.gsuiEffects-addSelect {
	order: 2147483647;
	width: 100%;
	height: calc( 2 * 24px );
	border: 0;
	font: inherit;
	color: inherit;
	background: #B818A3;
	transition: .1s;
	transition-property: height, visibility;
}
.gsuiEffects-addSelect option {
	box-sizing: border-box;
	padding: 4px;
	height: 24px;
	font-size: 12px;
}
.gsuiEffects-addBtn:not( :focus ) + .gsuiEffects-addSelect:not( :focus ) {
	height: 0;
	visibility: hidden;
}

/* .......................................................................... */
.gsuiEffects-fx-head {
	display: flex;
	height: 36px;
	font-size: 12px;
	line-height: 36px;
	background: #B818A3;
}
.gsuiEffects-fx-expand,
.gsuiEffects-fx-toggle,
.gsuiEffects-fx-remove {
	width: 20px;
	border: 0;
	padding: 0;
	outline: 0;
	color: inherit;
	cursor: pointer;
	font-size: inherit;
	background-color: transparent;
}
.gsuiEffects-fx-grip {
	width: 16px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 12px;
	cursor: grab;
	opacity: .6;
	background: #B818A3;
}
.gsuiEffects-fx-expand {
	font-size: 14px;
}
.gsuiEffects-fx-toggle {
	font-size: 8px;
	color: #222;
}
.gsuiEffects-fx-enable .gsuiEffects-fx-toggle {
	color: #ffa;
}
.gsuiEffects-fx-name {
	flex: 1;
	opacity: .5;
}
.gsuiEffects-fx-enable .gsuiEffects-fx-name {
	opacity: 1;
}
.gsuiEffects-fx-remove {
	width: 32px;
	opacity: .3;
	transition: .1s opacity;
}
.gsuiEffects-fx-remove:hover,
.gsuiEffects-fx-remove:focus {
	opacity: 1;
}
.gsuiEffects-fx-content {
	height: 0;
	opacity: 0;
	overflow: hidden;
	transition: .1s;
	transition-property: height, opacity;
}
.gsuiEffects-fx-expanded .gsuiEffects-fx-content {
	opacity: 1;
}
.gsuiFxFilter {
	--gsuiFxFilter-bg: #666;
	--gsuiFxFilter-inputBg: #555;
	--gsuiFxFilter-Q: #d7b;
	--gsuiFxFilter-gain: #ff9;
	--gsuiFxFilter-detune: #fff;
	--gsuiFxFilter-frequency: #8c8;
}
.gsuiFxFilter {
	display: grid;
	box-sizing: border-box;
	height: 100%;
	color: inherit;
	padding: 8px;
	grid-gap: 8px;
	grid-template:
		"type graph     gain Q     " 1fr
		"type graph     gain detune" 1fr
		".    frequency .    .     " 8px
		/32px 1fr       8px  50px;
	background-color: #666;
	--gsuiSlider-lineBgColor: var( --gsuiFxFilter-inputBg );
}

/* .......................................................................... */
.gsuiFxFilter-area {
	display: flex;
	flex-direction: column;
}
.gsuiFxFilter-area-label {
	align-self: center;
	height: 20px;
	font-size: 12px;
	opacity: .5;
}
.gsuiFxFilter-area-content {
	flex: 1;
	position: relative;
}

/* .......................................................................... */
.gsuiFxFilter-areaType {
	grid-area: type;
}
.gsuiFxFilter-areaGraph {
	grid-area: graph;
}
.gsuiFxFilter-areaGain {
	grid-area: gain;
	--gsuiSlider-lineColor: var( --gsuiFxFilter-gain );
}
.gsuiFxFilter-areaQ {
	grid-area: Q;
	--gsuiSlider-lineColor: var( --gsuiFxFilter-Q );
}
.gsuiFxFilter-areaDetune {
	grid-area: detune;
	--gsuiSlider-lineColor: var( --gsuiFxFilter-detune );
}
.gsuiFxFilter-areaFrequency {
	grid-area: frequency;
	--gsuiSlider-lineColor: var( --gsuiFxFilter-frequency );
}
.gsuiFxFilter-areaQ gsui-slider,
.gsuiFxFilter-areaDetune gsui-slider {
	min-height: 40px;
}

/* .......................................................................... */
.gsuiFxFilter-areaGain .gsuiSlider-eventCatcher,
.gsuiFxFilter-areaFrequency .gsuiSlider-eventCatcher {
	top: -8px;
	left: -8px;
	right: -8px;
	bottom: -8px;
}

/* .......................................................................... */
.gsuiFxFilter-areaGraph .gsuiFxFilter-area-label {
	align-self: flex-start;
}
.gsuiFxFilter-areaGraph .gsuiFxFilter-area-content {
	border-radius: 4px;
	background-color: rgba( 0, 0, 0, .5 );
}
.gsuiFxFilter .gsuiCurves-curve {
	color: currentColor;
	opacity: .25;
}
.gsuiFxFilter-enable .gsuiCurves-curve {
	color: var( --gsuiFxFilter-frequency );
	opacity: 1;
}

/* .......................................................................... */
.gsuiFxFilter-areaType .gsuiFxFilter-area-content {
	display: flex;
	overflow: hidden;
	border-radius: 4px;
	flex-direction: column;
}
.gsuiFxFilter-areaType-btn {
	position: relative;
	flex: 1;
	border: 0;
	outline: 0;
	padding: 0;
	cursor: pointer;
	stroke: #ff9;
	stroke-width: 1.5px;
	background-color: var( --gsuiFxFilter-inputBg );
}
.gsuiFxFilter-areaType-btn:hover,
.gsuiFxFilter-areaType-btn:focus {
	stroke-width: 2px;
}
.gsuiFxFilter-areaType-btnSelected {
	stroke: #222;
	background-color: #ff9;
}
.gsuiFxFilter-areaType-btn svg {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	fill: transparent;
	stroke: inherit;
	stroke-width: inherit;
	pointer-events: none;
}
.gsuiReorder-dragging {
	opacity: 0;
	transition: none;
}
:root {
	--gsuiDragline-color: #fff;
	--gsuiDragline-dotSize: 8px;
	--gsuiDragline-dotRad: 50%;
	--gsuiDragline-lineSize: 4px;
}

/* ................................................................ */
.gsuiDragline {
	position: absolute;
	max-width: 0;
	max-height: 0;
	color: var( --gsuiDragline-color );
}
.gsuiDragline-dragging,
.gsuiDragline-dragging .gsuiDragline-to {
	pointer-events: none;
}

/* ................................................................ */
.gsuiDragline-main {
	position: relative;
	pointer-events: none;
}

/* ................................................................ */
.gsuiDragline-line {
	position: absolute;
	bottom: 0;
	right: 0;
	width: 0;
	height: 0;
	fill: none;
	stroke: currentColor;
	stroke-width: var( --gsuiDragline-lineSize );
	stroke-linecap: round;
}
.gsuiDragline-down .gsuiDragline-line {
	top: 0;
	bottom: auto;
}
.gsuiDragline-right .gsuiDragline-line {
	left: 0;
	right: auto;
}

/* ................................................................ */
.gsuiDragline-to {
	position: absolute;
	width: var( --gsuiDragline-dotSize );
	height: var( --gsuiDragline-dotSize );
	margin: calc( var( --gsuiDragline-dotSize ) / -2 );
	cursor: pointer;
	border-radius: var( --gsuiDragline-dotRad );
	pointer-events: all;
	background-color: var( --gsuiDragline-color );
	transition: .2s background-color;
}
.gsuiDragline-down .gsuiDragline-to { bottom: 0; }
.gsuiDragline-right .gsuiDragline-to { right: 0; }
.gsuiDragline-main:not( .gsuiDragline-down ) .gsuiDragline-to { top: 0; }
.gsuiDragline-main:not( .gsuiDragline-right ) .gsuiDragline-to { left: 0; }

/* ................................................................ */
.gsuiDragline-drop {
	position: relative;
	max-width: 0;
	max-height: 0;
}
.gsuiDragline-drop::before {
	content: "";
	position: absolute;
	width: 0;
	height: 0;
	margin: 0;
	background-color: var( --gsuiDragline-color );
	transition: .2s all;
}
.gsuiDragline-dropActive::before {
	width: var( --gsuiDragline-dotSize );
	height: var( --gsuiDragline-dotSize );
	margin: calc( var( --gsuiDragline-dotSize ) / -2 );
	cursor: pointer;
	border-radius: var( --gsuiDragline-dotRad );
}
.gsuiDragline-dropActive:hover::before {
	transform: scale( 2 );
}
.gsuiBeatlines {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	pointer-events: none;
	background-repeat: no-repeat;
}
:root {
	--gsuiBlocksManager-timeline-height: 32px;
	--gsuiBlocksManager-selection-bgColor: #b226;
	--gsuiBlocksManager-selection-borderColor: #f44;
	--gsuiBlocksManager-blockColor: #5acc;
	--gsuiBlocksManager-blockSelectedColor: #f88c;
}

/* .......................................................................... */
.gsuiBlocksManager-selection {
	position: absolute;
	box-sizing: border-box;
	top: 0;
	z-index: 2;
	border: 2px solid var( --gsuiBlocksManager-selection-borderColor );
	border-radius: 4px;
	background-color: var( --gsuiBlocksManager-selection-bgColor );
	transition: .2s;
	transition-property: opacity, visibility;
}
.gsuiBlocksManager-selection-hidden {
	opacity: 0;
	visibility: hidden;
}

/* .......................................................................... */
.gsuiBlocksManager-block {
	position: absolute;
	z-index: 1;
	height: 100%;
	border-radius: 2px;
	background-color: var( --gsuiBlocksManager-blockColor );
	transition: .1s;
	transition-property: opacity, background-color;
}
.gsuiBlocksManager-block-selected {
	--gsuiBlocksManager-blockColor: var( --gsuiBlocksManager-blockSelectedColor );
}
.gsuiBlocksManager-block-hidden {
	z-index: 0;
	opacity: .3;
}
.gsuiBlocksManager-block-crop {
	position: absolute;
	z-index: 2;
	width: 50%;
	height: 100%;
	max-width: 8px;
	border-radius: inherit;
	background-color: #000;
	opacity: 0;
	transition: .1s opacity;
}
.gsuiBlocksManager-block-cropA {
	left: 0;
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}
.gsuiBlocksManager-block-cropB {
	right: 0;
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}
.gsuiBlocksManager-block:hover .gsuiBlocksManager-block-crop,
.gsuiBlocksManager-block.gsui-hover .gsuiBlocksManager-block-crop {
	opacity: .12;
}
.gsuiBlocksManager-block .gsuiBlocksManager-block-crop:hover,
.gsuiBlocksManager-block .gsuiBlocksManager-block-crop.gsui-hover {
	opacity: .25;
}
.gsuiPatternroll {
	display: flex;
}

.gsuiPatternroll-block {
	display: flex;
	flex-direction: column;
	white-space: nowrap;
	color: var( --gsuiPatterns-pattern-color );
	--gsuiPatterns-pattern-color: #444;
}
.gsui-mute .gsuiPatternroll-block {
	opacity: .5;
}
.gsuiPatternroll-block-header {
	position: relative;
	box-sizing: border-box;
	z-index: 1;
	display: flex;
	border-radius: inherit;
	flex-direction: column;
	justify-content: center;
	padding: 0 4px;
	font-size: 11px;
	font-weight: bold;
	background-color: #fff3;
	pointer-events: none;
	user-select: none;
	-webkit-user-select: none;
}
.gsuiPatternroll-block-name {
	overflow: hidden;
	text-overflow: ellipsis;
}
.gsuiPatternroll-block-content {
	flex: 1;
	position: relative;
	pointer-events: none;
}
.gsuiPatternroll-block-content:empty {
	display: none;
}
.gsuiPatternroll-block-content svg {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	opacity: .8;
	fill: currentColor;
}

.gsui-row-small .gsuiPatternroll-block-header {
	background-color: inherit;
}
.gsui-row-small .gsuiPatternroll-block-header,
.gsui-row-small .gsuiPatternroll-block-content {
	position: absolute;
	width: 100%;
	height: 100%;
}

.gsuiPatternroll-block-placeholder {
	flex: 1;
	display: none;
	align-items: center;
	pointer-events: none;
	font-size: 14px;
	opacity: .5;
}
.gsuiPatternroll-block-content:empty + .gsuiPatternroll-block-placeholder {
	display: flex;
}
.gsuiPatternroll-block-placeholderIcon {
	margin: 0 8px;
}
.gsuiPatternroll-block-placeholderText {
	overflow: hidden;
	text-overflow: ellipsis;
	user-select: none;
	-webkit-user-select: none;
}
.gsuiPianoroll {
	display: flex;
	height: 500px;
	--gsuiDragline-dotSize: 10px;
	--gsuiDragline-dotRad: 2px;
	--gsuiDragline-lineSize: 3px;
}
.gsuiPianoroll:focus {
	outline: 1px solid var( --gsuiBlocksManager-blockColor );
}

/* .......................................................................... */
.gsuiPianoroll .gsuiKeys {
	z-index: 0;
	font-size: var( --gsuiTimewindow-lineH );
}
.gsuiPianoroll .gsuiTimewindow-rows {
	font-size: var( --gsuiTimewindow-lineH );
}
.gsuiPianoroll .gsuiKey-row > div {
	font-size: var( --gsuiTimewindow-pxperbeat );
}

/* .......................................................................... */
.gsuiPianoroll .gsuiTimewindow-panelContentDown {
	display: flex;
	align-items: center;
	justify-content: center;
}
.gsuiPianoroll-slidersSelect {
	border: 0;
	outline: 0;
	font: inherit;
	color: inherit;
	cursor: pointer;
	font-size: 12px;
	user-select: none;
	border-radius: 4px;
	background-color: #fff2;
	scrollbar-width: none;
	opacity: .5;
	transition: .1s opacity;
}
.gsuiPianoroll-slidersSelect::-webkit-scrollbar {
	display: none;
}
.gsuiPianoroll-slidersSelect:focus,
.gsuiPianoroll-slidersSelect:hover {
	opacity: 1;
}
.gsuiPianoroll-slidersSelect option {
	padding: 2px;
}
.gsuiPianoroll-block {
	--gsuiDragline-color: var( --gsuiBlocksManager-blockColor );
}
.gsuiPianoroll-block::after {
	content: attr( data-key );
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	left: 0;
	width: 16px;
	max-width: 100%;
	height: 100%;
	color: #000;
	font-size: 11px;
	font-weight: bold;
	opacity: .4;
	pointer-events: none;
}

/* .......................................................................... */
.gsuiPianoroll-block-env {
	position: absolute;
	height: 100%;
	pointer-events: none;
}
.gsuiPianoroll-block-attack {
	left: 0;
}
.gsuiPianoroll-block-release {
	right: 0;
}
.gsuiPianoroll-block-prevLinked .gsuiPianoroll-block-attack,
.gsuiPianoroll-block-nextLinked .gsuiPianoroll-block-release {
	display: none;
}

/* .......................................................................... */
.gsuiPianoroll-block-envHandle {
	position: absolute;
	width: 6px;
	height: 6px;
	bottom: 100%;
	cursor: pointer;
	border-radius: 2px;
	pointer-events: initial;
	background-color: var( --gsuiBlocksManager-blockColor );
	filter: brightness( 1.3 );
	opacity: 0;
	transition: .1s opacity;
}
.gsuiPianoroll-block-attack .gsuiPianoroll-block-envHandle {
	right: -3px;
}
.gsuiPianoroll-block-release .gsuiPianoroll-block-envHandle {
	left: -3px;
}
.gsuiPianoroll-block-envHandle.gsui-hover,
.gsuiPianoroll-block:hover .gsuiPianoroll-block-envHandle,
.gsuiPianoroll-block.gsui-hover .gsuiPianoroll-block-envHandle {
	opacity: .8;
}

/* .......................................................................... */
.gsuiPianoroll-block-envBg {
	height: 100%;
	opacity: .3;
	transition: opacity .1s;
}
.gsuiPianoroll-block-envHandle.gsui-hover + .gsuiPianoroll-block-envBg {
	opacity: .5;
}
.gsuiPianoroll-block-attack .gsuiPianoroll-block-envBg {
	border-top-left-radius: 2px;
	background-image: linear-gradient(
		to bottom right,
		#000 50%,
		transparent calc( 50% + 1px )
	);
}
.gsuiPianoroll-block-release .gsuiPianoroll-block-envBg {
	border-top-right-radius: 2px;
	background-image: linear-gradient(
		to bottom left,
		#000 50%,
		transparent calc( 50% + 1px )
	);
}

/* .......................................................................... */
.gsuiPianoroll-block .gsuiDragline {
	top: 50%;
	right: 0;
}

/* .......................................................................... */
.gsuiPianoroll-block .gsuiDragline-drop {
	top: 50%;
	left: 0;
}
.gsuiPianoroll-block .gsuiDragline-drop::before {
	left: 0;
}
.gsuiPianoroll-block .gsuiDragline-dropActive::before {
	left: -4px;
}

/* .gsuiDragline-to */
/* .......................................................................... */
.gsuiPianoroll-block:not( :hover ):not( .gsui-hover ) .gsuiDragline:not( .gsuiDragline-dragging ) .gsuiDragline-to {
	background-color: transparent;
}
.gsuiPianoroll-block:hover      .gsuiDragline:not( .gsuiDragline-linked ) .gsuiDragline-to,
.gsuiPianoroll-block.gsui-hover .gsuiDragline:not( .gsuiDragline-linked ) .gsuiDragline-to {
	transform: translateX( 2px );
}
.gsuiPianoroll-block:hover      .gsuiDragline-linked .gsuiDragline-to,
.gsuiPianoroll-block.gsui-hover .gsuiDragline-linked .gsuiDragline-to {
	transform: translateX( -2px );
}
:root {
	--gsuiKeys-blackRow-bg: #0000001a;
	--gsuiKeys-blackRow-hover-bg: #00000026;
	--gsuiKeys-whiteRow-hover-bg: #ffffff08;
}

.gsuiKeys {
	--gsuiKeys-blackKey-gradA: #333;
	--gsuiKeys-blackKey-gradB: #444;
	--gsuiKeys-whiteKey-gradA: #888;
	--gsuiKeys-whiteKey-gradB: #eee;
	--gsuiKeys-activeKey-gradA: #353b52;
	--gsuiKeys-activeKey-gradB: #7886bd;
}
.gsuiKeys {
	display: block;
	position: relative;
	user-select: none;
	-webkit-user-select: none;
}

.gsuiKeys,
.gsuiKey {
	background-image: linear-gradient(
		90deg,
		var( --gsuiKeys-whiteKey-gradA ),
		var( --gsuiKeys-whiteKey-gradB ) );
}

.gsuiKey .gsuiKey-row {
	display: none;
}
.gsuiKey-row {
	position: absolute;
	box-sizing: border-box;
	z-index: 0;
	width: 100%;
	height: 1em;
}
.gsuiKeyBlack-row {
	background-color: var( --gsuiKeys-blackRow-bg );
}
.gsuiKey-row:hover { background-color: var( --gsuiKeys-whiteRow-hover-bg ); }
.gsuiKeyBlack-row:hover { background-color: var( --gsuiKeys-blackRow-hover-bg ); }

.gsuiKey[ data-key="0" ],
.gsuiKey[ data-key="5" ],
.gsuiKey-row[ data-key="0" ],
.gsuiKey-row[ data-key="5" ] {
	border-bottom: 1px solid #0003;
}
.gsuiKey-row > div {
	position: absolute;
	top: 0;
	bottom: 0;
	width: 100%;
}

.gsuiKey {
	box-sizing: border-box;
	position: absolute;
	left: 0;
	right: 0;
	height: 1.5em;
}
.gsuiKeyBlack {
	position: absolute;
	z-index: 1;
	width: 65%;
	height: 1em;
	border-radius: 0 .1em .1em 0;
	background-image: linear-gradient(
		90deg,
		var( --gsuiKeys-blackKey-gradA ),
		var( --gsuiKeys-blackKey-gradB )
	);
}
.gsuiKey[ data-key="0" ] {
	filter: brightness( .9 );
}
.gsuiKey[ data-key="0" ]::after {
	counter-increment: octave -1;
	content: "C" counter( octave );
	position: absolute;
	right: .25em;
	bottom: 0;
	color: #000;
	font-size: calc( 6px + .25em );
	font-family: monospace;
}
.gsuiKey.gsui-active {
	background-image: linear-gradient(
		90deg,
		var( --gsuiKeys-activeKey-gradA ),
		var( --gsuiKeys-activeKey-gradB )
	);
}

.gsuiKey:last-child {
	border-bottom: 0;
}
.gsuiKey[ data-key="9" ],
.gsuiKey[ data-key="7" ],
.gsuiKey[ data-key="2" ] {
	height: 2em;
}
.gsuiKey[ data-key="9" ],
.gsuiKey[ data-key="7" ],
.gsuiKey[ data-key="5" ],
.gsuiKey[ data-key="2" ],
.gsuiKey[ data-key="0" ] {
	margin-top: -.5em;
}
.gsuiOscillator {
	--gsuiOscillator-txt: #fff;
	--gsuiOscillator-txt-low: #fff7;
	--gsuiOscillator-bg: #666;
	--gsuiOscillator-pan: #d9f;
	--gsuiOscillator-gain: #ff9;
	--gsuiOscillator-pan-a: #faa;
	--gsuiOscillator-pan-b: #aaf;
	--gsuiOscillator-detune: #fff;
	--gsuiOscillator-slider-bg: #0003;
	--gsuiOscillator-grip-bg: #0002;
	--gsuiOscillator-wave-bg: #0006;
	--gsuiOscillator-wave-option: #444;
	--gsuiOscillator-wave-optionNative: #333;
}
.gsuiOscillator {
	display: grid;
	position: relative;
	box-sizing: border-box;
	height: 60px;
	color: var( --gsuiOscillator-txt );
	font-family: var( --gsui-font, sans-serif );
	background-color: var( --gsuiOscillator-bg );
	grid-template:
		"grip .   .        .        .          .      .    .    ." 6px
		"grip .   wavePrev waveNext waveSelect detune pan  gain ." 1fr
		"grip .   wave     wave     wave       detune pan  gain ." 1fr
		"grip .   wave     wave     wave       detune pan  gain ." 1fr
		"grip .   .        .        .          .      .    .    ." 6px
		/20px 6px 14px     14px     1fr        48px   48px 48px 8px;
	--gsuiSlider-lineBgColor: var( --gsuiOscillator-slider-bg );
}

/* .......................................................................... */
.gsuiOscillator-grip {
	grid-area: grip;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 12px;
	cursor: grab;
	opacity: .6;
	background-color: var( --gsuiOscillator-grip-bg );
}

/* .......................................................................... */
.gsuiOscillator-pan    { grid-area: pan;    color: var( --gsuiOscillator-pan ); }
.gsuiOscillator-gain   { grid-area: gain;   color: var( --gsuiOscillator-gain ); }
.gsuiOscillator-detune { grid-area: detune; color: var( --gsuiOscillator-detune ); }
.gsuiOscillator-prop {
	position: relative;
	margin-left: 6px;
	--gsuiSlider-lineColor: currentColor;
}
.gsuiOscillator-sliderWrap {
	box-sizing: border-box;
	height: 100%;
}
.gsuiOscillator-sliderValue {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	font-family: var( --gsui-font-number, monospace );
	font-size: 14px;
	pointer-events: none;
}

/* .......................................................................... */
.gsuiOscillator-wave {
	grid-area: wave;
	position: relative;
	flex: 1;
	border-radius: 0 0 3px 3px;
	background-color: var( --gsuiOscillator-wave-bg );
}
.gsuiOscillator-wave .gsuiPeriodicWave {
	position: absolute;
}
.gsuiOscillator-wave .gsuiPeriodicWave:first-child { color: var( --gsuiOscillator-pan-a ); }
.gsuiOscillator-wave .gsuiPeriodicWave:last-child { color: var( --gsuiOscillator-pan-b ); }
.gsuiOscillator-wave polyline {
	stroke-opacity: .8;
}

/* .......................................................................... */
.gsuiOscillator-remove,
.gsuiOscillator-waveBtn,
.gsuiOscillator-waveSelect {
	border: 0;
	padding: 0;
	outline: 0;
	cursor: pointer;
	color: var( --gsuiOscillator-txt-low );
	background-color: var( --gsuiOscillator-wave-bg );
	transition: .1s color;
}
.gsuiOscillator-waveBtn {
	width: 14px;
	font-size: 16px;
	text-align: center;
}
.gsuiOscillator-wavePrev {
	grid-area: wavePrev;
	border-top-left-radius: 3px;
}
.gsuiOscillator-waveNext {
	grid-area: waveNext;
}
.gsuiOscillator-remove {
	position: absolute;
	top: 0;
	right: 2px;
	outline: 0;
	font-size: 12px;
	background: none;
}
.gsuiOscillator-waveBtn:focus,
.gsuiOscillator-waveBtn:hover,
.gsuiOscillator-waveSelect:focus,
.gsuiOscillator-waveSelect:hover,
.gsuiOscillator-remove:focus,
.gsuiOscillator-remove:hover {
	color: var( --gsuiOscillator-txt );
}

/* .......................................................................... */
.gsuiOscillator-waveSelect {
	grid-area: waveSelect;
	padding-left: 6px;
	font-size: 12px;
	font-family: inherit;
	border-top-right-radius: 3px;
	-moz-appearance: none;
	-webkit-appearance: none;
}
.gsuiOscillator-waveOpt {
	background-color: var( --gsuiOscillator-wave-option );
}
.gsuiOscillator-waveOptNative {
	background-color: var( --gsuiOscillator-wave-optionNative );
}
.gsuiPeriodicWave,
.gsuiPeriodicWave svg {
	width: 100%;
	height: 100%;
}
.gsuiPeriodicWave polyline {
	stroke: currentColor;
	fill: none;
}
.gsuiSynthesizer {
	--gsuiSynthesizer-bg: initial;
	--gsuiSynthesizer-color: #fff;
	--gsuiSynthesizer-head-bg: #555;
}
.gsuiSynthesizer {
	overflow: auto;
	position: relative;
	box-sizing: border-box;
	color: var( --gsuiSynthesizer-color );
	scrollbar-width: thin;
	scrollbar-color: #ddd #222;
}

/* .......................................................................... */
.gsuiSynthesizer-head {
	display: flex;
	align-items: center;
	padding-right: 8px;
	font-size: 14px;
	line-height: 1em;
	user-select: none;
	background-color: var( --gsuiSynthesizer-head-bg );
}
.gsuiSynthesizer-headTitle {
	opacity: .3;
	line-height: 24px;
	margin-left: 6px;
}
.gsuiSynthesizer-label {
	width: 42px;
	margin-left: 6px;
	text-align: center;
	font-size: 12px;
	opacity: .5;
}
.gsuiSynthesizer-labelPitch {
	margin-left: auto;
}

/* .......................................................................... */
.gsuiSynthesizer-env,
.gsuiSynthesizer-lfo {
	height: 118px;
}
.gsuiSynthesizer-env {
	display: none;
}

/* .......................................................................... */
.gsuiSynthesizer-headOscs {
	height: 24px;
}
.gsuiSynthesizer-oscList {
	display: grid;
	grid-auto-flow: row;
	grid-auto-rows: min-content;
	counter-reset: count-osc;
	background-color: var( --gsuiSynthesizer-bg );
}

/* .......................................................................... */
.gsuiSynthesizer .gsuiOscillator {
	transition: .2s filter;
}
.gsuiSynthesizer .gsuiOscillator:hover {
	filter: brightness( 1.05 );
}
.gsuiSynthesizer .gsuiOscillator:only-of-type .gsuiOscillator-remove {
	display: none;
}

/* .......................................................................... */
.gsuiSynthesizer-newOsc {
	position: relative;
	order: 2147483647;
	border: 0;
	height: 52px;
	color: inherit;
	font-size: 18px;
	cursor: pointer;
	border-radius: 2px;
	background: none;
	opacity: .4;
	transition: .2s opacity;
}
.gsuiSynthesizer-newOsc:focus,
.gsuiSynthesizer-newOsc:hover {
	opacity: .6;
}
.gsuiSynthesizer-newOsc::before {
	content: "";
	top: 6px;
	left: 6px;
	right: 6px;
	bottom: 6px;
	opacity: .4;
	border: 2px dashed;
	position: absolute;
}
:root {
	--gsuiDotline-color: #000;
	--gsuiDotline-lineWidth: 1px;
	--gsuiDotline-dotBg: transparent;
	--gsuiDotline-dotSize: 12px;
	--gsuiDotline-dotSizeHover: calc( var( --gsuiDotline-dotSize ) * 2 );
	--gsuiDotline-dotHandleSize: 10px;
}

.gsuiDotline {
	position: relative;
	overflow: hidden;
	color: var( --gsuiDotline-color );
	stroke: currentColor;
	stroke-width: var( --gsuiDotline-lineWidth );
}

.gsuiDotline svg {
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
}
.gsuiDotline polyline {
	fill: none;
}

.gsuiDotline-dot {
	position: absolute;
	z-index: 1;
	box-sizing: border-box;
	width: var( --gsuiDotline-dotSize );
	height: var( --gsuiDotline-dotSize );
	margin:
		calc( var( --gsuiDotline-dotSize ) / -2 ) 0 0
		calc( var( --gsuiDotline-dotSize ) / -2 );
	border-radius: 50%;
	border: 2px solid;
	background-color: var( --gsuiDotline-dotBg );
	transition: .2s;
	transition-property: width, height, margin-left, margin-top;
}
.gsuiDotline-dot:hover,
.gsuiDotline-dotSelected {
	--gsuiDotline-dotSize: var( --gsuiDotline-dotSizeHover );
}
.gsuiDotline-dot::before {
	content: "";
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	border: var( --gsuiDotline-dotHandleSize ) solid transparent;
	margin: calc( var( --gsuiDotline-dotHandleSize ) * -1 );
	border-radius: 50%;
}
:root {
	--gsuiPanels-bd: 1px solid #222;
	--gsuiPanels-extendSize: 4px;
	--gsuiPanels-extendColor: #222;
}
.gsuiPanels-cursor {
	position: fixed;
	z-index: 2147483647;
	left: 0;
	right: 0;
	top: 0;
	bottom: 0;
}

.gsuiPanels-x,
.gsuiPanels-y {
	display: flex;
}
.gsuiPanels-y {
	flex-direction: column;
}
.gsuiPanels-x > div:not( .gsuiPanels-extend ),
.gsuiPanels-y > div:not( .gsuiPanels-extend ) {
	position: relative;
}
.gsuiPanels-last {
	flex: 1 !important;
}
.gsuiPanels-x > div,
.gsuiPanels-y > div {
	box-sizing: border-box;
}
.gsuiPanels-x > div + div:not( .gsuiPanels-extend ) { border-left: var( --gsuiPanels-bd ); }
.gsuiPanels-y > div + div:not( .gsuiPanels-extend ) { border-top: var( --gsuiPanels-bd ); }

.gsuiPanels-noselect {
	user-select: none;
	-ms-user-select: none;
	-moz-user-select: none;
	-webkit-user-select: none;
}

/* .gsuiPanels-extend ------------------------------------------------------- */
.gsuiPanels-extend {
	position: absolute;
	z-index: 999;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	transition: background-color .2s;
}
.gsuiPanels-extend.gsui-hover,
.gsuiPanels-extend:hover {
	background-color: var( --gsuiPanels-extendColor );
}
.gsuiPanels-x > div > .gsuiPanels-extend {
	cursor: col-resize;
	width: var( --gsuiPanels-extendSize );
	margin-left: calc( var( --gsuiPanels-extendSize ) / -2 );
}
.gsuiPanels-y > div > .gsuiPanels-extend {
	cursor: row-resize;
	height: var( --gsuiPanels-extendSize );
	margin-top: calc( var( --gsuiPanels-extendSize ) / -2 );
}
#gsuiPopup {
	--gsuiPopup-dur: .4s;
	--gsuiPopup-bg: #555;
	--gsuiPopup-btn-bg: #999;
	--gsuiPopup-btnOk-bg: #67a;
	--gsuiPopup-radius: 4px;
	--gsuiPopup-padding: 10px;
	--gsuiPopup-minWidth: 250px;
	--gsuiPopup-header-bg: #333;
	--gsuiPopup-header-fontSize: 16px;
	--gsuiPopup-body-fontSize: 14px;
	--gsuiPopup-overlay-bg: #0009;
}
#gsuiPopup {
	display: flex;
	position: fixed;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	z-index: 2147483647;
	color: #fff;
	background-color: var( --gsuiPopup-overlay-bg );
	backdrop-filter: blur( 10px );
	transition: var( --gsuiPopup-dur );
	transition-property: visibility, opacity;
}
#gsuiPopup:not( .gsuiPopup-show ) {
	opacity: 0;
	visibility: hidden;
}

#gsuiPopupWindow {
	overflow: hidden;
	min-width: var( --gsuiPopup-minWidth );
	border-radius: var( --gsuiPopup-radius );
	background-color: var( --gsuiPopup-bg );
	outline: 0;
	box-shadow: 0 0 50px #000;
}
#gsuiPopupWindow:focus {
	box-shadow:
		0 0 1px 2px #69b,
		0 0 50px #000;
}
.gsuiPopup-noCancel #gsuiPopupCancel,
.gsuiPopup-noText #gsuiPopupInputText {
	display: none;
}

#gsuiPopupHead {
	padding: var( --gsuiPopup-padding );
	font-size: var( --gsuiPopup-header-fontSize );
	background-color: var( --gsuiPopup-header-bg );
}
#gsuiPopupBody {
	font-size: var( --gsuiPopup-body-fontSize );
	padding: var( --gsuiPopup-padding );
}
#gsuiPopupContent:not( :empty ) + #gsuiPopupMessage,
#gsuiPopupContent:not( :empty ) ~ input {
	display: none;
}

#gsuiPopupInputText,
#gsuiPopupBtns input {
	padding: .6em 1.25em;
	border: 0;
	border-radius: 2px;
}
#gsuiPopupWindow input,
#gsuiPopupWindow select {
	outline: 0;
}
#gsuiPopupWindow input:focus,
#gsuiPopupWindow select:focus {
	box-shadow: 0 0 1px 2px #69b;
}
#gsuiPopupInputText {
	box-sizing: border-box;
	margin-top: var( --gsuiPopup-padding );
	padding: .6em;
	width: 100%;
	font-size: 18px;
}
#gsuiPopupBtns {
	margin-top: var( --gsuiPopup-padding );
	text-align: center;
}
#gsuiPopupBtns input {
	color: #fff;
	font-weight: bold;
	font-family: inherit;
	background-color: var( --gsuiPopup-btn-bg );
	cursor: pointer;
}
#gsuiPopupBtns input + input {
	margin-left: var( --gsuiPopup-padding );
}
#gsuiPopupBtns #gsuiPopupOk {
	background-color: var( --gsuiPopup-btnOk-bg );
}
#gsuiPopupWindow input[ type="text" ] {
	color: #fff;
	background-color: rgba( 255, 255, 255, .1 );
}
.gsuiSlider {
	display: block;
	position: relative;
	width: 100%;
	height: 100%;
	user-select: none;
}

.gsuiSlider-disable {
	cursor: not-allowed;
	--gsuiSlider-lineColor: #fff;
}
.gsuiSlider-disable .gsuiSlider-lineColor,
.gsuiSlider-disable .gsuiSlider-svgLineColor {
	opacity: .25;
}

.gsuiSlider-line,
.gsuiSlider-eventCatcher {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}

.gsuiSlider-input,
.gsuiSlider-linear .gsuiSlider-svg,
.gsuiSlider-circular .gsuiSlider-line {
	display: none;
}

.gsuiSlider-line {
	overflow: hidden;
	border-radius: var( --gsuiSlider-lineRadius, 2px );
	background-color: var( --gsuiSlider-lineBgColor, #000 );
}
.gsuiSlider-lineColor {
	position: absolute;
	background-color: var( --gsuiSlider-lineColor, #fff );
}

.gsuiSlider-svg {
	position: absolute;
	width: 100%;
	height: 100%;
}
.gsuiSlider-svgLine,
.gsuiSlider-svgLineColor {
	fill: none;
	transform-origin: center;
}
.gsuiSlider-svgLine { stroke: var( --gsuiSlider-lineBgColor, #000 ); }
.gsuiSlider-svgLineColor { stroke: var( --gsuiSlider-lineColor, #fff ); }
.gsuiSliderGroup {
	--gsuiSliderGroup-currentTime-color: #ff9;
	--gsuiSliderGroup-slider-width: 6px;
	--gsuiSliderGroup-slider-bg: #0002;
	--gsuiSliderGroup-slider-color: var( --gsuiBlocksManager-blockColor );
	--gsuiSliderGroup-slider-color-selected: var( --gsuiBlocksManager-blockSelectedColor );
	--gsuiSliderGroup-loop-color: #0004;
}
.gsuiSliderGroup {
	display: block;
	position: relative;
	overflow: hidden;
	height: 100%;
	z-index: 0;
}
.gsuiSliderGroup-slidersWrap {
	position: absolute;
	width: 100%;
	top: 0;
	bottom: 0;
	overflow: auto;
	scrollbar-width: none;
}
.gsuiSliderGroup-slidersWrap::-webkit-scrollbar {
	display: none;
}
.gsuiSliderGroup-sliders {
	position: absolute;
	width: 1000000px;
	height: 100%;
	user-select: none;
}

/* slider */
/* .......................................................................... */
.gsuiSliderGroup-slider {
	position: absolute;
	overflow: hidden;
	top: 0;
	bottom: 0;
	cursor: pointer;
}
.gsuiSliderGroup-slider::before {
	content: "";
	position: absolute;
	height: 100%;
	width: var( --gsuiSliderGroup-slider-width );
	background-color: var( --gsuiSliderGroup-slider-bg );
}
.gsuiSliderGroup-slidersSelected .gsuiSliderGroup-slider:not( .gsuiSliderGroup-sliderSelected ) {
	pointer-events: none;
}
.gsuiSliderGroup-sliderInner {
	position: absolute;
	width: var( --gsuiSliderGroup-slider-width );
	color: var( --gsuiSliderGroup-slider-color );
	background-color: currentColor;
}
.gsuiSliderGroup-sliderSelected .gsuiSliderGroup-sliderInner {
	color: var( --gsuiSliderGroup-slider-color-selected );
}
.gsuiSliderGroup-sliderInner::after {
	content: "";
	position: absolute;
	box-sizing: border-box;
	left: var( --gsuiSliderGroup-slider-width );
	width: 1000000px;
	height: 100%;
	border: 0 solid;
	border-width: 1px 0 0;
	opacity: .6;
}
.gsuiSliderGroup-sliderInnerDown::after {
	border-width: 0 0 1px;
}

/* currentTime, loopA/B */
/* .......................................................................... */
.gsuiSliderGroup-loop,
.gsuiSliderGroup-currentTime {
	position: absolute;
	z-index: 1000000; /* 1. */
	top: 0;
	bottom: 0;
	pointer-events: none;
}
.gsuiSliderGroup-currentTime {
	width: 2px;
	margin-left: -1px;
	background-color: var( --gsuiSliderGroup-currentTime-color );
}
.gsuiSliderGroup-loop {
	background-color: transparent;
	transition: .2s background-color;
}
.gsuiSliderGroup-loopA { left: 0; }
.gsuiSliderGroup-loopB { right: 0; }
.gsuiSliderGroup-loopOn {
	background-color: var( --gsuiSliderGroup-loop-color );
}

/*
1.
	z-index: 1million; because all the sliders will have undefined high z-index.
	and we don't put the max value to not interfere with the popup z-index etc.
*/
.gsuiTimeline {
	--gsuiTimeline-bg: #222;
	--gsuiTimeline-color: #fff;
	--gsuiTimeline-loop-bg: #656586;
	--gsuiTimeline-lines-bg: #ffffff07;
	--gsuiTimeline-cursor-fill: #fff;
	--gsuiTimeline-loopBorder-bg: #fff;
}
.gsuiTimeline {
	position: relative;
	display: block;
	height: 100%;
	color: var( --gsuiTimeline-color );
	background-color: var( --gsuiTimeline-bg );
	--gsuiTimeline-beats-offset: 0;
	--gsuiTimeline-beats-incr: 1;
}

/* .......................................................................... */
.gsuiTimeline-steps {
	position: absolute;
	top: calc( 50% - 1px );
	width: 100%;
	height: 2px;
	pointer-events: none;
	background-repeat: no-repeat;
}

/* .......................................................................... */
.gsuiTimeline-beats {
	display: flex;
	height: 100%;
	counter-reset: beat calc( var( --gsuiTimeline-beats-offset ) - var( --gsuiTimeline-beats-incr ) + 1 );
	pointer-events: none;
}
.gsuiTimeline-beat {
	counter-increment: beat var( --gsuiTimeline-beats-incr );
	display: inline-block;
	margin-left: calc( var( --gsuiTimeline-beats-incr ) * 1em );
	opacity: var( --gsuiTimeline-beats-opacity, 0 );
}
.gsuiTimeline-beat:first-child {
	margin-left: calc( var( --gsuiTimeline-beats-offset ) * 1em );
}
.gsuiTimeline-beat::before {
	content: counter( beat );
	position: absolute;
	top: 0;
	bottom: 0;
	width: 52px;
	margin-left: -26px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 12px;
}
.gsuiTimeline-measure {
	font-weight: bold;
	opacity: 1;
}

/* .......................................................................... */
.gsuiTimeline-loopLine,
.gsuiTimeline-timeLine {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 50%;
	transition: .2s background-color;
}
.gsuiTimeline-loopLine:hover,
.gsuiTimeline-timeLine:hover,
.gsuiTimeline-draggingLoopBody .gsuiTimeline-loopLine,
.gsuiTimeline-draggingLoopHandleA .gsuiTimeline-loopLine,
.gsuiTimeline-draggingLoopHandleB .gsuiTimeline-loopLine,
.gsuiTimeline-draggingTime .gsuiTimeline-timeLine {
	background-color: var( --gsuiTimeline-lines-bg );
}
.gsuiTimeline-timeLine {
	top: 50%;
	bottom: 0;
}

/* .......................................................................... */
.gsuiTimeline-cursor,
.gsuiTimeline-cursorPreview {
	position: absolute;
	margin-left: -8px;
	bottom: 1px;
	fill: var( --gsuiTimeline-cursor-fill );
	stroke: var( --gsuiTimeline-cursor-fill );
	stroke-width: 2px;
	stroke-linejoin: round;
	pointer-events: none;
}
.gsuiTimeline-cursorPreview {
	opacity: .5;
}

/* .......................................................................... */
.gsuiTimeline-loop {
	position: absolute;
	height: 6px;
	transition: .1s;
	transition-property: opacity, visibility;
	opacity: 0;
	visibility: hidden;
}
.gsuiTimeline-looping .gsuiTimeline-loop {
	opacity: 1;
	visibility: visible;
}
.gsuiTimeline-loopBody {
	height: 100%;
	transition: filter .2s;
	background-color: var( --gsuiTimeline-loop-bg );
}
.gsuiTimeline-loopBody:hover,
.gsuiTimeline-draggingLoopBody .gsuiTimeline-loopBody {
	filter: brightness( 1.2 );
}
.gsuiTimeline-loopHandleA { left: -5px; }
.gsuiTimeline-loopHandleB { right: -5px; }
.gsuiTimeline-loopHandle {
	position: absolute;
	top: 0;
	bottom: -6px;
	width: 25%;
	min-width: 7px;
	max-width: 12px;
}
.gsuiTimeline-loopBorderA { left: 0; }
.gsuiTimeline-loopBorderB { right: 0; }
.gsuiTimeline-loopBorder {
	position: absolute;
	top: 0;
	bottom: 0;
	width: 2px;
	transition: .2s;
	transition-property: bottom, background-color;
	pointer-events: none;
}
.gsuiTimeline-loopHandle:hover + .gsuiTimeline-loopBorder,
.gsuiTimeline-draggingLoopHandleA .gsuiTimeline-loopBorderA,
.gsuiTimeline-draggingLoopHandleB .gsuiTimeline-loopBorderB {
	bottom: -3px;
	background-color: var( --gsuiTimeline-loopBorder-bg );
}
.gsuiTimewindow {
	--gsuiTimewindow-bg: #456168;
	--gsuiTimewindow-color: #fff;
	--gsuiTimewindow-loop-bg: #0004;
	--gsuiTimewindow-panel-bg: #555;
	--gsuiTimewindow-panel-border: #222;
	--gsuiTimewindow-panelUp-bg: #444;
	--gsuiTimewindow-currentTime-fill: #ff9;
}
.gsuiTimewindow {
	position: relative;
	z-index: 0;
	display: flex;
	align-items: start;
	width: 100%;
	height: 100%;
	overflow: auto;
	color: var( --gsuiTimewindow-color );
	background-color: var( --gsuiTimewindow-bg );
	scrollbar-width: none;
}
.gsuiTimewindow::-webkit-scrollbar {
	display: none;
}

/* .......................................................................... */
.gsuiTimewindow-panel,
.gsuiTimewindow-main {
	display: flex;
	min-height: 100%;
	flex-direction: column;
}
.gsuiTimewindow-main {
	z-index: 0;
}
.gsuiTimewindow-panel {
	position: sticky;
	z-index: 1;
	left: 0;
	background-color: var( --gsuiTimewindow-panel-bg );
	box-shadow: 1px 0 var( --gsuiTimewindow-panel-border );
}
.gsuiTimewindow-panelUp,
.gsuiTimewindow-time {
	position: sticky;
	z-index: 2;
	top: 0;
	height: 32px;
}
.gsuiTimewindow-panelUp {
	display: flex;
	align-items: center;
	justify-content: flex-end;
	padding-right: 4px;
	background-color: var( --gsuiTimewindow-panelUp-bg );
	background-image: var( --gsuiWindow-bgImg );
}
.gsuiTimewindow-panelContent,
.gsuiTimewindow-mainBody {
	flex: 1;
}
.gsuiTimewindow-mainBody {
	width: 1000000px;
}
.gsuiTimewindow-mainContent {
	position: relative;
	z-index: 0;
}
.gsuiTimewindow-panelContentDown,
.gsuiTimewindow-contentDown {
	position: sticky;
	bottom: 0px;
	height: 96px;
	overflow: hidden;
	background-color: var( --gsuiTimewindow-bg );
	box-shadow: 0 -1px var( --gsuiTimewindow-panel-border );
}
.gsuiTimewindow-panelContentDown {
	background-color: inherit;
}

/* .......................................................................... */
.gsuiTimewindow-panelExtend {
	position: absolute;
}
.gsuiTimewindow-panelExtendX {
	left: 0;
	right: 0;
	top: -2px;
	height: 6px;
	cursor: ns-resize;
}
.gsuiTimewindow-panelExtendY {
	top: 0;
	bottom: 0;
	right: -2px;
	width: 6px;
	cursor: ew-resize;
}

/* .......................................................................... */
.gsuiTimewindow .gsuiTimeline {
	--gsuiTimeline-cursor-fill: var( --gsuiTimewindow-currentTime-fill );
}
.gsuiTimewindow-currentTime,
.gsuiTimewindow-loop {
	position: absolute;
	z-index: 1;
	top: 0;
	bottom: 0;
	pointer-events: none;
}
.gsuiTimewindow-currentTime {
	width: 2px;
	margin-left: -1px;
	background-color: var( --gsuiTimewindow-currentTime-fill );
}
.gsuiTimewindow-loop {
	opacity: 0;
	transition: .2s opacity;
	background-color: var( --gsuiTimewindow-loop-bg );
}
.gsuiTimewindow-looping .gsuiTimewindow-loop {
	opacity: 1;
}
.gsuiTimewindow-loopA { left: 0; }
.gsuiTimewindow-loopB { right: 0; }


/* .......................................................................... */
.gsuiTimewindow-step {
	display: flex;
	align-items: center;
	border: 0;
	outline: 0;
	padding: 4px;
	border-radius: 4px;
	font-size: inherit;
	font-family: var( --gsui-font-number );
	color: inherit;
	cursor: pointer;
	background: none;
	user-select: none;
	opacity: .5;
	transition: .2s opacity;
}
.gsuiTimewindow-step:focus,
.gsuiTimewindow-step:hover {
	opacity: 1;
}
.gsuiTimewindow-stepValue {
	white-space: nowrap;
	margin-right: 6px;
}
.gsuiPatterns {
	--gsuiPatterns-panel-menu-color: #919CA1;
	--gsuiPatterns-panel-menu-bg: #666;
	--gsuiPatterns-panel-btnSolid-bg: #444;
	--gsuiPatterns-newSynthBtn-color: #a5d6a7;
	--gsuiPatterns-newDrumsBtn-color: #44A1FC;

	--gsuiPatterns-synth-bg: #919CA1;
	--gsuiPatterns-synth-color: #222;
	--gsuiPatterns-synth-selected-color: #444;
	--gsuiPatterns-synth-expand-bg: #0000001a;
	--gsuiPatterns-synth-selected-bg: #66bb6a;
	--gsuiPatterns-synth-namehover-color: #7b7;
	--gsuiPatterns-synth-patterns-bg: #0006;
	--gsuiPatterns-synth-dest-bg: #0000001a;
	--gsuiPatterns-synth-placeholder-color: #fff6;
	--gsuiPatterns-synth-placeholder-bg: #0003;

	--gsuiPatterns-pattern-bg: #919CA1;
	--gsuiPatterns-pattern-selected-bg: #5ac;
	--gsuiPatterns-pattern-color: #41BBBF;
	--gsuiPatterns-pattern-selected-color: #223;
	--gsuiPatterns-pattern-head-bg: #0003;
	--gsuiPatterns-pattern-head-selected-bg: #fff3;
	--gsuiPatterns-pattern-dest-bg: #fff1;
}
.gsuiPatterns {
	--gsuiPatterns-pattern-h: 64px;
	--gsuiPatterns-pattern-head-h: 26px;
	--gsuiPatterns-pattern-grip-w: 16px;
	height: 100%;
}

/* .......................................................................... */
.gsuiPatterns-panel {
	--gsuiPanels-bd: 0;
	display: flex;
	flex-direction: column;
}
.gsuiPatterns-panelBuffers,
.gsuiPatterns-panelDrums {
	min-height: 29px;
	max-height: 400px;
	height: 140px;
}

/* .......................................................................... */
.gsuiPatterns-panel-menu {
	display: flex;
	align-items: center;
	height: 28px;
	min-height: 28px;
	padding: 0 6px;
	color: var( --gsuiPatterns-panel-menu-color );
	background-color: var( --gsuiPatterns-panel-menu-bg );
	user-select: none;
}
.gsuiPatterns-panel-icon,
.gsuiPatterns-panel-title {
	font-size: 12px;
	line-height: 1;
	opacity: .5;
}
.gsuiPatterns-panel-icon {
	margin-right: 4px;
}
.gsuiPatterns-panel-title {
	font-size: 12px;
	font-weight: bold;
}
.gsuiPatterns-panel-menu .gsuiPatterns-btnSolid {
	margin-left: 8px;
}

/* .......................................................................... */
.gsuiPatterns-panel-list {
	flex: 1;
	overflow: auto;
	position: relative;
}
.gsuiPatterns-panel-list:empty {
	display: none;
}

/* .......................................................................... */
.gsuiPatterns-destArrow {
	margin: 0 4px;
	font-size: 12px;
	opacity: .7;
	pointer-events: none;
}

/* .......................................................................... */
.gsuiPatterns-btnSolid {
	display: inline-flex;
	align-items: center;
	overflow: hidden;
	height: 20px;
	padding: 0 8px;
	border: 0;
	outline: 0;
	cursor: pointer;
	border-radius: 3px;
	line-height: 1;
	font-size: 12px;
	color: inherit;
	font-family: inherit;
	font-weight: bold;
	text-align: start;
	background-color: var( --gsuiPatterns-panel-btnSolid-bg );
	transition: filter .2s;
}
.gsuiPatterns-btnSolid:focus,
.gsuiPatterns-btnSolid:hover {
	filter: brightness( 1.1 );
}
.gsuiPatterns-btnSolid[ data-action="newSynth" ] { color: var( --gsuiPatterns-newSynthBtn-color ); }
.gsuiPatterns-btnSolid[ data-action="newDrums" ] { color: var( --gsuiPatterns-newDrumsBtn-color ); }
.gsuiPatterns-btnIcon {
	pointer-events: none;
}
.gsuiPatterns-btnText {
	margin-left: 4px;
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	pointer-events: none;
}

/* .......................................................................... */
.gsuiPatterns-placeholder {
	display: none;
	overflow: hidden;
	flex: 1;
	padding: 0 10px;
	text-align: center;
	align-items: center;
	justify-content: center;
	color: var( --gsuiPatterns-panel-menu-color );
	font-size: 12px;
	font-weight: bold;
	opacity: 0;
	transition: .3s;
	transition-property: opacity;
	user-select: none;
}
.gsuiPatterns-placeholderToCheck .gsuiPatterns-placeholder:only-child,
.gsuiPatterns-placeholderToCheck:empty + .gsuiPatterns-placeholder {
	display: flex;
	opacity: .4;
}
.gsuiPatterns-synth {
	display: flex;
	flex-direction: column;
	color: var( --gsuiPatterns-synth-color );
	border-bottom: 0 solid var( --gsuiPatterns-synth-bg );
	background-color: var( --gsuiPatterns-synth-bg );
	transition: .2s;
	transition-property:
		border-bottom-color,
		background-color,
		filter;
}
.gsuiPatterns-synth-expanded {
	filter: brightness( 1.1 );
	border-bottom-width: 2px;
}
.gsuiPatterns-synth-selected {
	--gsuiPatterns-synth-bg: var( --gsuiPatterns-synth-selected-bg );
	--gsuiPatterns-synth-color: var( --gsuiPatterns-synth-selected-color );
}

/* .......................................................................... */
.gsuiPatterns-synth-head {
	display: flex;
	height: 32px;
	line-height: 32px;
	font-size: 12px;
	user-select: none;
}

/* .......................................................................... */
.gsuiPatterns-synth-btn {
	width: 20px;
	min-width: 20px;
	margin: 0;
	border: 0;
	outline: 0;
	padding: 0;
	opacity: .7;
	color: inherit;
	cursor: pointer;
	background: none;
	font-size: 14px;
	transition: .1s;
	transition-property: background-color, opacity;
}
.gsuiPatterns-synth-btn:focus,
.gsuiPatterns-synth-btn:hover {
	opacity: 1;
}
.gsuiPatterns-synth:not( .gsuiPatterns-synth-selected ) .gsuiPatterns-synth-btn:hover {
	color: var( --gsuiPatterns-synth-namehover-color );
}

/* .......................................................................... */
.gsuiPatterns-synth-expand {
	width: 16px;
	min-width: 16px;
	background-color: var( --gsuiPatterns-synth-expand-bg );
}
.gsuiPatterns-synth-expanded .gsuiPatterns-synth-expand {
	opacity: 1;
}

/* .......................................................................... */
.gsuiPatterns-synth-info {
	flex: 1;
	display: flex;
	overflow: hidden;
	align-items: center;
	padding-left: 6px;
	white-space: nowrap;
	text-overflow: ellipsis;
	font-weight: bold;
}
.gsuiPatterns-synth-name {
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	pointer-events: none;
}
.gsuiPatterns-synth-name:empty::before {
	content: "Untitled";
	font-style: italic;
	opacity: .8;
}
.gsuiPatterns-synth-dest {
	background-color: var( --gsuiPatterns-synth-dest-bg );
}
.gsuiPatterns-synth-dest:hover,
.gsuiPatterns-synth-dest:focus {
	color: var( --gsuiPatterns-synth-bg );
	background-color: var( --gsuiPatterns-panel-btnSolid-bg );
}

/* .......................................................................... */
.gsuiPatterns-synth-patterns {
	position: relative;
	overflow: hidden;
	min-height: 0;
	max-height: 250px;
	background-color: var( --gsuiPatterns-synth-patterns-bg );
	transition: .3s min-height;
}
.gsuiPatterns-synth-expanded .gsuiPatterns-synth-patterns {
	overflow-y: auto;
	min-height: 32px;
}
.gsuiPatterns-synth .gsuiPatterns-pattern {
	margin-top: calc( var( --gsuiPatterns-pattern-h ) * -1 );
}
.gsuiPatterns-synth-expanded .gsuiPatterns-pattern {
	margin-top: 0;
}

/* .......................................................................... */
.gsuiPatterns-synth .gsuiPatterns-placeholder {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}
.gsuiPatterns-pattern {
	overflow: hidden;
	position: relative;
	box-sizing: border-box;
	flex-direction: column;
	height: var( --gsuiPatterns-pattern-h );
	color: var( --gsuiPatterns-pattern-color );
	background-color: var( --gsuiPatterns-pattern-bg );
	transition:
		margin-top .3s,
		background-color .1s;
}
.gsuiPatterns-panelBuffers .gsuiPatterns-pattern {
	border-bottom: 2px solid transparent;
}
.gsuiPatterns-pattern-selected {
	--gsuiPatterns-pattern-bg: var( --gsuiPatterns-pattern-selected-bg );
	--gsuiPatterns-pattern-color: var( --gsuiPatterns-pattern-selected-color );
	--gsuiPatterns-pattern-head-bg: var( --gsuiPatterns-pattern-head-selected-bg );
}

/* .......................................................................... */
.gsuiPatterns-pattern-grip {
	position: absolute;
	width: calc( var( --gsuiPatterns-pattern-grip-w ) - 2px );
	top: 0;
	left: 0;
	bottom: 0;
	cursor: grab;
	font-size: 14px;
	text-align: center;
	line-height: var( --gsuiPatterns-pattern-h );
	background-color: var( --gsuiPatterns-pattern-head-bg );
}

/* .......................................................................... */
.gsuiPatterns-pattern-head {
	position: absolute;
	left: var( --gsuiPatterns-pattern-grip-w );
	top: 0;
	right: 0;
	display: flex;
	box-sizing: border-box;
	height: var( --gsuiPatterns-pattern-head-h );
	line-height: var( --gsuiPatterns-pattern-head-h );
	background-color: var( --gsuiPatterns-pattern-head-bg );
	transition: inherit;
}
.gsuiPatterns-pattern-info {
	flex: 1;
	display: flex;
	align-items: center;
	padding: 0 8px;
	overflow: hidden;
}
.gsuiPatterns-pattern-name {
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	font-size: 12px;
	font-weight: bold;
}
.gsuiPatterns-pattern-name:empty::after {
	content: "Untitled";
	font-style: italic;
	opacity: .5;
}
.gsuiPatterns-pattern-dest {
	background-color: var( --gsuiPatterns-pattern-dest-bg );
}
.gsuiPatterns-pattern-dest:hover,
.gsuiPatterns-pattern-dest:focus {
	color: var( --gsuiPatterns-pattern-bg );
	background-color: var( --gsuiPatterns-pattern-color );
}
.gsuiPatterns-pattern-btn {
	width: 20px;
	border: 0;
	outline: 0;
	padding: 0;
	opacity: .7;
	color: inherit;
	cursor: pointer;
	font-size: 14px;
	background: none;
	transition: .1s opacity;
}
.gsuiPatterns-pattern-btn:focus,
.gsuiPatterns-pattern-btn:hover {
	opacity: 1;
}

/* .......................................................................... */
.gsuiPatterns-pattern-content,
.gsuiPatterns-pattern-placeholder {
	position: absolute;
	top: var( --gsuiPatterns-pattern-head-h );
	left: var( --gsuiPatterns-pattern-grip-w );
	right: 0;
	bottom: 0;
	pointer-events: none;
}
.gsuiPatterns-pattern-content:empty {
	display: none;
}
.gsuiPatterns-pattern-content:empty + .gsuiPatterns-pattern-placeholder {
	display: flex;
}
.gsuiPatterns-pattern-svg {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	opacity: .8;
	fill: currentColor;
}
.gsuiPatterns-pattern-placeholder {
	display: none;
	align-items: center;
	font-size: 14px;
	opacity: .5;
}
.gsuiPatterns-pattern-placeholderIcon {
	margin: 0 8px;
}
.gsuiPatterns-pattern-placeholderText {
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	user-select: none;
}
.gsuiTrack {
	--gsuiTrack-hsl-h: 0;
	--gsuiTrack-hsl-s: 0%;
	--gsuiTrack-hsl-l: 33%;
	--gsuiTrack-color: #fff;
	--gsuiTrack-toggle-bg: #ffa;
	--gsuiTrack-toggleOff-bg: #fff3;
}
.gsuiTrack {
	display: flex;
	height: var( --gsuiTimewindow-lineH );
	background-color: hsl(
		var( --gsuiTrack-hsl-h ),
		var( --gsuiTrack-hsl-s ),
		calc( var( --gsuiTrack-hsl-l ) + var( --rel-l, 0% ) ) );
}
.gsuiTrack,
.gsuiTrack-row,
.gsuiTrack-toggle::before {
	transition: .2s background-color;
}
.gsuiTrack:nth-child( even ) {
	--rel-l: -1.7%;
}
.gsuiTrack.gsui-mute {
	--rel-l: -5%;
	--gsuiTrack-toggle-bg: var( --gsuiTrack-toggleOff-bg );
}
.gsuiTrack.gsui-mute:nth-child( even ) {
	--rel-l: -5.5%;
}

/* .......................................................................... */
.gsuiTrack-row {
	position: relative;
	z-index: 0;
	height: var( --gsuiTimewindow-lineH );
	background-color: rgba( 0, 0, 0, var( --rel-a, 0 ) );
}
.gsuiTrack-row:nth-child( even ) {
	--rel-a: .06;
}
.gsuiTrack-row.gsui-mute {
	--rel-a: .25;
}
.gsuiTrack-row.gsui-mute:nth-child( even ) {
	--rel-a: .29;
}
.gsuiTrack-row > div {
	position: absolute;
	top: 0;
	bottom: 0;
	width: 100%;
	font-size: var( --gsuiTimewindow-pxperbeat );
}

/* .......................................................................... */
.gsuiTrack-toggle {
	cursor: pointer;
	display: flex;
	border: 0;
	outline: 0;
	padding: 0;
	min-width: 24px;
	align-items: center;
	justify-content: center;
	color: var( --gsuiTrack-toggle-bg );
	font-size: 8px;
	background: none;
}
.gsuiTrack-nameWrap {
	position: relative;
	flex: 1;
}
.gsuiTrack-name {
	box-sizing: border-box;
	position: absolute;
	top: 0;
	width: 100%;
	height: 100%;
	border: 0;
	outline: 0;
	padding-right: 10px;
	font-size: 12px;
	font-weight: bold;
	font-family: inherit;
	text-overflow: ellipsis;
	color: var( --gsuiTrack-color );
	cursor: default;
	background: none;
	user-select: none;
}
.gsui-mute .gsuiTrack-name {
	opacity: .5;
}
.gsuiTrack-name:focus {
	font-weight: normal;
}
.gsuiTrack-name::placeholder {
	color: inherit;
	font-style: italic;
	font-weight: normal;
	opacity: .3;
}
.gsuiTrack-name:focus::placeholder {
	color: transparent;
}
.gsuiWindow {
	--gsuiWindow-bg: #444;
	--gsuiWindow-bgImg: url( "data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23000000' fill-opacity='0.2' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E" );
	--gsuiWindow-color: #222;
	--gsuiWindow-head-bg: #919CA1;
	--gsuiWindow-border-color: #444;
	--gsuiWindow-btn-close-color: #ba5d5d88;
	--gsuiWindow-focused-border-color: #689acb;
}
.gsuiWindows {
	--gsuiWindows-overflow: hidden;
	position: relative;
	overflow: var( --gsuiWindows-overflow );
	scroll-behavior: smooth;
}

.gsuiWindows.gsuiWindows-maximized {
	overflow: hidden;
}
.gsuiWindow {
	--gsuiWindow-radius: 2px;
	--gsuiWindow-head-height: 28px;
	--gsuiWindow-border-width: 2px;
	--gsuiWindow-handler-width: 4px;
	--gsuiWindow-title-opacity: .8;
	position: absolute;
	outline: 0;
	color: var( --gsuiWindow-color );
	border-radius: var( --gsuiWindow-radius );
	transition: .2s;
	transition-property: opacity, visibility;
}
.gsuiWindow:not( .gsuiWindow-show ) {
	opacity: 0;
	visibility: hidden;
	pointer-events: none;
}
.gsuiWindow:focus-within {
	--gsuiWindow-title-opacity: 1;
	--gsuiWindow-border-color: var( --gsuiWindow-focused-border-color );
}
.gsuiWindow-maximized {
	--gsuiWindow-radius: 0;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	overflow: hidden;
}
.gsuiWindow-handlers::before,
.gsuiWindow:not( .gsuiWindow-dragging ),
.gsuiWindows-lowGraphics .gsuiWindow-dragging {
	box-shadow: 0 0 0
		var( --gsuiWindow-border-width )
		var( --gsuiWindow-border-color );
}
/*
// If we want to add some shadow:
.gsuiWindow:not( .gsuiWindow-dragging ):focus-within,
.gsuiWindows-lowGraphics .gsuiWindow.gsuiWindow-dragging:focus-within {
	box-shadow: 0 0 0
		var( --gsuiWindow-border-width )
		var( --gsuiWindow-border-color ),
		0 0 20px #0008;
}
*/

/* .......................................................................... */
.gsuiWindow-handlers {
	position: absolute;
	opacity: 0;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	margin: calc( var( --gsuiWindow-handler-width ) * -1 );
}
.gsuiWindow-handlers::before {
	content: "";
	z-index: 1;
	position: absolute;
	pointer-events: none;
	border-radius: var( --gsuiWindow-radius );
	top: var( --gsuiWindow-handler-width );
	left: var( --gsuiWindow-handler-width );
	right: var( --gsuiWindow-handler-width );
	bottom: var( --gsuiWindow-handler-width );
}
.gsuiWindow-dragging .gsuiWindow-handlers {
	opacity: 1;
}
.gsuiWindow-maximized .gsuiWindow-handlers,
.gsuiWindow-minimized .gsuiWindow-handler {
	display: none;
}
.gsuiWindow-handler {
	position: absolute;
	width: calc( var( --gsuiWindow-handler-width ) * 2 );
	height: calc( var( --gsuiWindow-handler-width ) * 2 );
}
.gsuiWindow-handler[ data-dir="nw" ] { cursor: nw-resize; top: 0; left: 0; }
.gsuiWindow-handler[ data-dir="ne" ] { cursor: ne-resize; top: 0; right: 0; }
.gsuiWindow-handler[ data-dir="sw" ] { cursor: sw-resize; bottom: 0; left: 0; }
.gsuiWindow-handler[ data-dir="se" ] { cursor: se-resize; bottom: 0; right: 0; }
.gsuiWindow-handler[ data-dir="n" ] { cursor: n-resize; top: 0; width: 100%; }
.gsuiWindow-handler[ data-dir="w" ] { cursor: w-resize; left: 0; height: 100%; }
.gsuiWindow-handler[ data-dir="e" ] { cursor: e-resize; right: 0; height: 100%; }
.gsuiWindow-handler[ data-dir="s" ] { cursor: s-resize; bottom: 0; width: 100%; }

/* .......................................................................... */
.gsuiWindow-wrap {
	position: absolute;
	overflow: hidden;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	border-radius: inherit;
}
.gsuiWindow-head {
	display: flex;
	position: absolute;
	top: 0;
	width: 100%;
	font-size: 16px;
	height: var( --gsuiWindow-head-height );
	background-color: var( --gsuiWindow-head-bg );
	user-select: none;
	-webkit-user-select: none;
}
.gsuiWindow-dragging .gsuiWindow-head {
	cursor: move;
}
.gsuiWindow-minimized .gsuiWindow-head {
	border-radius: inherit;
}
.gsuiWindow-content {
	position: absolute;
	overflow: auto;
	width: 100%;
	bottom: 0;
	top: var( --gsuiWindow-head-height );
	background-color: var( --gsuiWindow-bg );
	background-image: var( --gsuiWindow-bgImg );
}
.gsuiWindow-minimized .gsuiWindow-content {
	display: none;
}

/* .......................................................................... */
.gsuiWindow-icon,
.gsuiWindow-title {
	opacity: var( --gsuiWindow-title-opacity );
	transition: .2s opacity;
}
.gsuiWindow-icon {
	border: 0;
	padding: 0;
	outline: 0;
	width: 32px;
	min-width: 32px;
	color: inherit;
	cursor: inherit;
	font-size: 16px;
	background: none;
}
.gsuiWindow-title {
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	font-size: 12px;
	font-weight: bold;
	line-height: var( --gsuiWindow-head-height );
}
.gsuiWindow-headContent {
	flex: 1;
	display: flex;
	align-items: center;
	padding-left: .5em;
}
.gsuiWindow-headBtns {
	height: 100%;
	display: flex;
	margin-left: auto;
	align-items: center;
}

/* .......................................................................... */
.gsuiWindow-headBtn {
	border: 0;
	padding: 0;
	outline: 0;
	width: var( --gsuiWindow-head-height );
	height: 100%;
	cursor: pointer;
	color: inherit;
	font-size: 14px;
	opacity: .6;
	transition: .2s;
	transition-property: opacity, background-color;
	background: none;
}
.gsuiWindow-headBtn:focus,
.gsuiWindow-headBtn:hover {
	opacity: 1;
	background-color: rgba( 0, 0, 0, .1 );
}
.gsuiWindow-headBtn[ data-icon="close" ]:focus,
.gsuiWindow-headBtn[ data-icon="close" ]:hover {
	background-color: var( --gsuiWindow-btn-close-color );
}
.gsuiWindow-minimized .gsuiWindow-headBtn[ data-icon="minimize" ],
.gsuiWindow-maximized .gsuiWindow-headBtn[ data-icon="maximize" ],
.gsuiWindow:not( .gsuiWindow-minimized ):not( .gsuiWindow-maximized )
.gsuiWindow-headBtn[ data-icon="restore" ] {
	display: none;
}
/* FontAwesome (regular/bold) */
/* .......................................................................... */

@font-face {
	font-family: "FontAwesome";
	font-style: normal;
	font-weight: normal;
	src: url( "../../assets/fonts/fa-duotone-900.woff2" );
}

@font-face {
	font-family: "FontAwesomeBrands";
	font-style: normal;
	font-weight: normal;
	src: url( "../../assets/fonts/fa-brands-400.woff2" );
}

/* Oswald (regular) */
/* .......................................................................... */

@font-face { /* latin */
	font-family: "Oswald";
	font-style: normal;
	font-weight: normal;
	src: local( "Oswald Regular" ), local( "Oswald-Regular" ), url( "../../assets/fonts/oswald-400-latin.woff2" ) format( "woff2" );
	unicode-range: u+0000-00ff, u+0131, u+0152-0153, u+02bb-02bc, u+02c6, u+02da, u+02dc, u+2000-206f, u+2074, u+20ac, u+2122, u+2191, u+2193, u+2212, u+2215, u+feff, u+fffd;
}

/* Unica One (regular) */
/* .......................................................................... */

@font-face { /* latin */
	font-family: "Unica One";
	font-style: normal;
	font-weight: normal;
	src: local( "Unica One" ), local( "UnicaOne-Regular" ), url( "../../assets/fonts/unica-one-400-latin.woff2" ) format( "woff2" );
	unicode-range: u+0000-00ff, u+0131, u+0152-0153, u+02bb-02bc, u+02c6, u+02da, u+02dc, u+2000-206f, u+2074, u+20ac, u+2122, u+2191, u+2193, u+2212, u+2215, u+feff, u+fffd;
}

/* Inconsolata (regular) */
/* .......................................................................... */

@font-face { /* latin */
	font-family: "Inconsolata";
	font-style: normal;
	font-weight: normal;
	src: local( "Inconsolata Regular" ), local( "Inconsolata-Regular" ), url( "../../assets/fonts/inconsolata-400-latin.woff2" ) format( "woff2" );
	unicode-range: u+0000-00ff, u+0131, u+0152-0153, u+02bb-02bc, u+02c6, u+02da, u+02dc, u+2000-206f, u+2074, u+20ac, u+2122, u+2191, u+2193, u+2212, u+2215, u+feff, u+fffd;
}

/* Montserrat (regular) */
/* .......................................................................... */

@font-face { /* cyrillic-ext */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: normal;
	src: local( "Montserrat Medium" ), local( "Montserrat-Medium" ), url( "../../assets/fonts/montserrat-500-cyrillic-ext.woff2" ) format( "woff2" );
	unicode-range: u+0460-052f, u+1c80-1c88, u+20b4, u+2de0-2dff, u+a640-a69f, u+fe2e-fe2f;
}

@font-face { /* cyrillic */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: normal;
	src: local( "Montserrat Medium" ), local( "Montserrat-Medium" ), url( "../../assets/fonts/montserrat-500-cyrillic.woff2" ) format( "woff2" );
	unicode-range: u+0400-045f, u+0490-0491, u+04b0-04b1, u+2116;
}

@font-face { /* vietnamese */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: normal;
	src: local( "Montserrat Medium" ), local( "Montserrat-Medium" ), url( "../../assets/fonts/montserrat-500-vietnamese.woff2" ) format( "woff2" );
	unicode-range: u+0102-0103, u+0110-0111, u+1ea0-1ef9, u+20ab;
}

@font-face { /* latin-ext */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: normal;
	src: local( "Montserrat Medium" ), local( "Montserrat-Medium" ), url( "../../assets/fonts/montserrat-500-latin-ext.woff2" ) format( "woff2" );
	unicode-range: u+0100-024f, u+0259, u+1e00-1eff, u+2020, u+20a0-20ab, u+20ad-20cf, u+2113, u+2c60-2c7f, u+a720-a7ff;
}

@font-face { /* latin */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: normal;
	src: local( "Montserrat Medium" ), local( "Montserrat-Medium" ), url( "../../assets/fonts/montserrat-500-latin.woff2" ) format( "woff2" );
	unicode-range: u+0000-00ff, u+0131, u+0152-0153, u+02bb-02bc, u+02c6, u+02da, u+02dc, u+2000-206f, u+2074, u+20ac, u+2122, u+2191, u+2193, u+2212, u+2215, u+feff, u+fffd;
}

/* Montserrat (bold) */
/* .......................................................................... */

@font-face { /* cyrillic-ext */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: bold;
	src: local( "Montserrat Bold" ), local( "Montserrat-Bold" ), url( "../../assets/fonts/montserrat-700-cyrillic-ext.woff2" ) format( "woff2" );
	unicode-range: u+0460-052f, u+1c80-1c88, u+20b4, u+2de0-2dff, u+a640-a69f, u+fe2e-fe2f;
}

@font-face { /* cyrillic */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: bold;
	src: local( "Montserrat Bold" ), local( "Montserrat-Bold" ), url( "../../assets/fonts/montserrat-700-cyrillic.woff2" ) format( "woff2" );
	unicode-range: u+0400-045f, u+0490-0491, u+04b0-04b1, u+2116;
}

@font-face { /* vietnamese */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: bold;
	src: local( "Montserrat Bold" ), local( "Montserrat-Bold" ), url( "../../assets/fonts/montserrat-700-vietnamese.woff2" ) format( "woff2" );
	unicode-range: u+0102-0103, u+0110-0111, u+1ea0-1ef9, u+20ab;
}

@font-face { /* latin-ext */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: bold;
	src: local( "Montserrat Bold" ), local( "Montserrat-Bold" ), url( "../../assets/fonts/montserrat-700-latin-ext.woff2" ) format( "woff2" );
	unicode-range: u+0100-024f, u+0259, u+1e00-1eff, u+2020, u+20a0-20ab, u+20ad-20cf, u+2113, u+2c60-2c7f, u+a720-a7ff;
}

@font-face { /* latin */
	font-family: "Montserrat";
	font-style: normal;
	font-weight: bold;
	src: local( "Montserrat Bold" ), local( "Montserrat-Bold" ), url( "../../assets/fonts/montserrat-700-latin.woff2" ) format( "woff2" );
	unicode-range: u+0000-00ff, u+0131, u+0152-0153, u+02bb-02bc, u+02c6, u+02da, u+02dc, u+2000-206f, u+2074, u+20ac, u+2122, u+2191, u+2193, u+2212, u+2215, u+feff, u+fffd;
}
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background-color: #444; }
::-webkit-scrollbar-thumb { background-color: #87DDDD; }

.no-select {
	user-select: none;
	-webkit-user-select: none;
}

html,
body {
	height: 100%;
	margin: 0;
	overflow: hidden;
	font-family: var( --font-default );
	background-color: var( --app-bg );
}

a {
	color: inherit;
	text-decoration: none;
}
.TextGlitch {
	position: relative;
	color: #ccc;
	line-height: 1em;
	font-size: 68px;
	font-family: "oswald", monospace;
}
.TextGlitch-blended {
	color: #fff;
}

.TextGlitch-clip {
	position: relative;
}
.TextGlitch-clip + .TextGlitch-clip {
	position: absolute;
	top: 0;
}
.TextGlitch:not( .TextGlitch-blended ) .TextGlitch-clip + .TextGlitch-clip {
	display: none;
}

.TextGlitch-word {
	margin: 0;
	white-space: nowrap;
}

.TextGlitch-blend {
	position: absolute;
	top: 0;
	opacity: 0;
	transition: .1s;
	transition-property: opacity;
}
.TextGlitch-blendA {
	color: #2af;
	margin: -.03em 0 0 .03em;
	mix-blend-mode: darken;
}
.TextGlitch-blendB {
	color: #f64;
	margin: .03em 0 0 -.03em;
	mix-blend-mode: color-burn;
}
.TextGlitch-blended .TextGlitch-blend {
	opacity: .4;
}
#loading {
	display: flex;
	z-index: 2147483646;
	position: absolute;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	color: #fff8;
	user-select: none;
	-webkit-user-select: none;
	background-image: url("front.jpg");
	transition: .5s opacity;
}
#loading.started {
	pointer-events: none;
	opacity: 0;
}

#loadingContent {
	position: relative;
	pointer-events: none;
	text-align: center;
}

#loadingTitle {
	position: relative;
	font: 52px var( --font-oswald );
}

#loadingLoading,
#loadingLoaded,
#loadingStarting {
	position: absolute;
	left: 0;
	width: 100%;
	opacity: 0;
}
#loading.loaded:not( .starting ) #loadingLoaded {
	animation: 1s loadingTextAnim linear infinite alternate;
}
#loading:not( .loaded ):not( .starting ) #loadingLoading,
#loading.starting #loadingStarting {
	opacity: 1;
}
#gsTitle {
	margin-bottom: 16px;
}

@keyframes loadingTextAnim {
	from { opacity: 0; }
	to { opacity: 1; }
}
:root {
	--app-bg: #222;
	--font-default: "Montserrat", sans-serif;
	--font-monospace: "Inconsolata", "consolas", monospace;
	--font-number: "Unica One", var( --font-monospace );
	--font-oswald: "Oswald", sans-serif;
	--pan-border: 1px solid #333;
	--bpm-fontSize: 22px;

	--gsui-font: var( --font-default );
	--gsui-font-number: var( --font-number );

	--head-bg: #444;
	--head-gap: 4px;
	--head-border: 0;
	--head-heightA: 32px;
	--head-heightB: 24px;
	--head-hover-dur: .2s;
	--head-winBtn-bg: #222;
	--head-winBtn-open-bg: #ff9;

	--head-cmps-btn: #9dabd5;
	--head-dropdown-shadow: 20px 10px #0006;

	--windowBtn-bg: #444;
	--windowBtn-chan-color: #ce93d8;
	--windowBtn-synth-color: #a5d6a7;
	--windowBtn-newCmp-color: #ff9;
	--windowBtn-pattern-color: #81d4fa;

	--ctrl-play-bg: #67a;
	--ctrl-stop-bg: #888;
	--ctrl-play-text: #ddd;
	--ctrl-about-color: #ff9;
	--ctrl-render-color: #ff9;
	--ctrl-eatcookie-color: #ff9;
	--ctrl-currentTime-color: #abd;
	--ctrl-currentTime-bg: #0003;

	--cmp-cloud-bg: #4c71af;
	--cmp-local-bg: #67a;
	--cmp-text: #fff;
	--cmp-height: 42px;
	--cmp-text-size: 18px;
	--cmp-save-bg: #ba5d5d;

	--history-action-bg: #454750;
	--history-action-text: #ddd;
	--history-actionlight-bg: #67a;
	--history-actionlightoff-bg: #1a1a1a;
}
#app {
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	overflow: hidden;
	position: absolute;
	display: flex;
	flex-direction: column;
}

#body {
	flex: 1;
	background-color: var( --app-bg );
	background-image: url( "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='304' height='304' viewBox='0 0 304 304'%3E%3Cpath fill='%23000000' fill-opacity='0.2' d='M44.1 224a5 5 0 1 1 0 2H0v-2h44.1zm160 48a5 5 0 1 1 0 2H82v-2h122.1zm57.8-46a5 5 0 1 1 0-2H304v2h-42.1zm0 16a5 5 0 1 1 0-2H304v2h-42.1zm6.2-114a5 5 0 1 1 0 2h-86.2a5 5 0 1 1 0-2h86.2zm-256-48a5 5 0 1 1 0 2H0v-2h12.1zm185.8 34a5 5 0 1 1 0-2h86.2a5 5 0 1 1 0 2h-86.2zM258 12.1a5 5 0 1 1-2 0V0h2v12.1zm-64 208a5 5 0 1 1-2 0v-54.2a5 5 0 1 1 2 0v54.2zm48-198.2V80h62v2h-64V21.9a5 5 0 1 1 2 0zm16 16V64h46v2h-48V37.9a5 5 0 1 1 2 0zm-128 96V208h16v12.1a5 5 0 1 1-2 0V210h-16v-76.1a5 5 0 1 1 2 0zm-5.9-21.9a5 5 0 1 1 0 2H114v48H85.9a5 5 0 1 1 0-2H112v-48h12.1zm-6.2 130a5 5 0 1 1 0-2H176v-74.1a5 5 0 1 1 2 0V242h-60.1zm-16-64a5 5 0 1 1 0-2H114v48h10.1a5 5 0 1 1 0 2H112v-48h-10.1zM66 284.1a5 5 0 1 1-2 0V274H50v30h-2v-32h18v12.1zM236.1 176a5 5 0 1 1 0 2H226v94h48v32h-2v-30h-48v-98h12.1zm25.8-30a5 5 0 1 1 0-2H274v44.1a5 5 0 1 1-2 0V146h-10.1zm-64 96a5 5 0 1 1 0-2H208v-80h16v-14h-42.1a5 5 0 1 1 0-2H226v18h-16v80h-12.1zm86.2-210a5 5 0 1 1 0 2H272V0h2v32h10.1zM98 101.9V146H53.9a5 5 0 1 1 0-2H96v-42.1a5 5 0 1 1 2 0zM53.9 34a5 5 0 1 1 0-2H80V0h2v34H53.9zm60.1 3.9V66H82v64H69.9a5 5 0 1 1 0-2H80V64h32V37.9a5 5 0 1 1 2 0zM101.9 82a5 5 0 1 1 0-2H128V37.9a5 5 0 1 1 2 0V82h-28.1zm16-64a5 5 0 1 1 0-2H146v44.1a5 5 0 1 1-2 0V18h-26.1zm102.2 270a5 5 0 1 1 0 2H98v14h-2v-16h124.1zM242 149.9V160h16v34h-16v62h48v48h-2v-46h-48v-66h16v-30h-16v-12.1a5 5 0 1 1 2 0zM53.9 18a5 5 0 1 1 0-2H64V2H48V0h18v18H53.9zm112 32a5 5 0 1 1 0-2H192V0h50v2h-48v48h-28.1zm-48-48a5 5 0 0 1-9.8-2h2.07a3 3 0 1 0 5.66 0H178v34h-18V21.9a5 5 0 1 1 2 0V32h14V2h-58.1zm0 96a5 5 0 1 1 0-2H137l32-32h39V21.9a5 5 0 1 1 2 0V66h-40.17l-32 32H117.9zm28.1 90.1a5 5 0 1 1-2 0v-76.51L175.59 80H224V21.9a5 5 0 1 1 2 0V82h-49.59L146 112.41v75.69zm16 32a5 5 0 1 1-2 0v-99.51L184.59 96H300.1a5 5 0 0 1 3.9-3.9v2.07a3 3 0 0 0 0 5.66v2.07a5 5 0 0 1-3.9-3.9H185.41L162 121.41v98.69zm-144-64a5 5 0 1 1-2 0v-3.51l48-48V48h32V0h2v50H66v55.41l-48 48v2.69zM50 53.9v43.51l-48 48V208h26.1a5 5 0 1 1 0 2H0v-65.41l48-48V53.9a5 5 0 1 1 2 0zm-16 16V89.41l-34 34v-2.82l32-32V69.9a5 5 0 1 1 2 0zM12.1 32a5 5 0 1 1 0 2H9.41L0 43.41V40.6L8.59 32h3.51zm265.8 18a5 5 0 1 1 0-2h18.69l7.41-7.41v2.82L297.41 50H277.9zm-16 160a5 5 0 1 1 0-2H288v-71.41l16-16v2.82l-14 14V210h-28.1zm-208 32a5 5 0 1 1 0-2H64v-22.59L40.59 194H21.9a5 5 0 1 1 0-2H41.41L66 216.59V242H53.9zm150.2 14a5 5 0 1 1 0 2H96v-56.6L56.6 162H37.9a5 5 0 1 1 0-2h19.5L98 200.6V256h106.1zm-150.2 2a5 5 0 1 1 0-2H80v-46.59L48.59 178H21.9a5 5 0 1 1 0-2H49.41L82 208.59V258H53.9zM34 39.8v1.61L9.41 66H0v-2h8.59L32 40.59V0h2v39.8zM2 300.1a5 5 0 0 1 3.9 3.9H3.83A3 3 0 0 0 0 302.17V256h18v48h-2v-46H2v42.1zM34 241v63h-2v-62H0v-2h34v1zM17 18H0v-2h16V0h2v18h-1zm273-2h14v2h-16V0h2v16zm-32 273v15h-2v-14h-14v14h-2v-16h18v1zM0 92.1A5.02 5.02 0 0 1 6 97a5 5 0 0 1-6 4.9v-2.07a3 3 0 1 0 0-5.66V92.1zM80 272h2v32h-2v-32zm37.9 32h-2.07a3 3 0 0 0-5.66 0h-2.07a5 5 0 0 1 9.8 0zM5.9 0A5.02 5.02 0 0 1 0 5.9V3.83A3 3 0 0 0 3.83 0H5.9zm294.2 0h2.07A3 3 0 0 0 304 3.83V5.9a5 5 0 0 1-3.9-5.9zm3.9 300.1v2.07a3 3 0 0 0-1.83 1.83h-2.07a5 5 0 0 1 3.9-3.9zM97 100a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-48 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 96a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-144a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-96 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm96 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-32 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM49 36a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-32 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM33 68a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 240a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm80-176a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 48a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm112 176a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-16 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM17 180a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16 0a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM17 84a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm32 64a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm16-16a3 3 0 1 0 0-6 3 3 0 0 0 0 6z'%3E%3C/path%3E%3C/svg%3E" );
	background-attachment: local;
	--gsuiWindows-overflow: auto;
}

#noscript {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	z-index: 2147483647;
	color: #ddd;
	background-color: #333;
}
#head {
	position: relative;
	display: grid;
	z-index: 1000; /* 1. */
	color: #ddd;
	font-size: 16px;
	padding: var( --head-gap );
	grid-gap: var( --head-gap );
	grid-template:
		"header ctrlA       ctrlB       .   headHelp  " var( --head-heightA )
		"cmp    currentTime winBtns     .   headVersion" var( --head-heightB )
		/260px  min-content min-content 1fr min-content;
	background-color: var( --head-bg );
	border-bottom: var( --head-border );
}

/* .......................................................................... */
a.btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
}
.btn {
	border: 0;
	padding: 0;
	outline: 0;
	color: inherit;
	cursor: pointer;
	font-size: inherit;
	border-radius: 4px;
	background: none;
	transition: var( --head-hover-dur );
	transition-property: color, opacity, background-color;
	user-select: none;
}
.btn:not( .gsuiIcon ) {
	font-family: inherit;
}
.btnMarge + .btnMarge {
	margin-left: var( --head-gap );
}
.btn:focus {
	z-index: 1;
	position: relative;
	box-shadow: 0 0 1px 2px #69b;
}
.btn.gsuiIcon:focus,
.btn.gsuiIcon:hover {
	color: #fff;
}
.btnBg {
	background-color: #ffffff1a;
}
.btnBg:focus,
.btnBg:hover {
	background-color: #fff3;
}
.btnLarge {
	width: var( --head-heightA );
	min-width: var( --head-heightA );
}
.btnIconLarge {
	font-size: calc( var( --head-heightA ) - 8px );
}

/* .......................................................................... */
.btnGroup .btn:first-of-type {
	border-top-left-radius: 4px;
	border-bottom-left-radius: 4px;
}
.btnGroup .btn:last-of-type {
	border-top-right-radius: 4px;
	border-bottom-right-radius: 4px;
}
.btnGroup .btn {
	margin-left: 0;
	border-radius: 0;
	transition: color var( --head-hover-dur );
}
.btnGroup .btn:hover {
	color: #fff;
}

/* .......................................................................... */
#header {
	grid-area: header;
	display: flex;
}
#title {
	align-self: center;
	font-size: 28px;
	font-family: var( --font-oswald );
	margin-right: 4px;
}
#title::before {
	content: attr( data-text );
}
#headUser {
	border: 2px solid #222;
	box-sizing: border-box;
	margin-left: var( --head-gap );
	background-size: cover;
	background-color: rgba( 255, 255, 255, .3 );
}
#app.logged #login,
#app:not( .logged ) #logout,
#app:not( .logged ) #headUser {
	display: none;
}
#login,
#logout {
	margin-left: 4px;
	opacity: .7;
}

/* .......................................................................... */
#cmpsBtn {
	display: flex;
	align-items: center;
	justify-content: center;
	height: 100%;
	margin-left: 4px;
	color: var( --head-cmps-btn );
}
#cmpsBtn .gsuiIcon[ data-icon="plus" ] {
	margin-left: 4px;
	font-size: 14px;
}
#cmpsBtn:focus,
#cmpsBtn:hover {
	color: var( --head-bg );
	background-color: var( --head-cmps-btn );
}

/* .......................................................................... */
#headCmp {
	grid-area: cmp;
	display: flex;
	overflow: hidden;
	border-radius: 4px;
	line-height: var( --head-heightB );
	background-color: var( --cmp-local-bg );
}
#headCmpSave {
	border-radius: 0;
}
#headCmpInfo {
	flex: 1;
	display: flex;
	overflow: hidden;
	align-items: center;
	padding: 0 4px;
	font-size: 14px;
}
#headCmpName {
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	text-align: left;
	padding-right: .4ch;
}
#headCmpIcon {
	display: none;
	margin-right: .3em;
}
#headCmp.cmp-saved #headCmpIcon {
	display: inline-block;
}
#headCmp:not( .cmp-saved ) #headCmpName::before {
	content: "*";
}
#headCmpName:empty::after {
	content: "Untitled";
	font-style: italic;
	padding-right: 1px;
	opacity: .8;
}
#headCmpHover {
	width: 0;
	display: inline-block;
	overflow: hidden;
	position: relative;
	transition: .1s;
	transition-property: width, margin-left;
}
#headCmpInfo:focus #headCmpHover,
#headCmpInfo:hover #headCmpHover {
	width: 1.4ch;
	margin-left: 4px;
}
#headCmpDur::before {
	content: "?";
	margin: 4px;
}

/* .......................................................................... */
#headGain {
	width: 6px;
	--gsuiSlider-lineRadius: 4px;
	--gsuiSlider-lineColor: var( --ctrl-play-bg );
	--gsuiSlider-lineBgColor: #222;
}
#headGain .gsuiSlider-eventCatcher {
	left: -12px;
	right: -4px;
}

/* .......................................................................... */
#headCurrentTime {
	grid-area: currentTime;
	padding: 10px;
	border-radius: 4px;
	background-color: var( --ctrl-currentTime-bg );
	--gsuiSlider-lineColor: var( --ctrl-currentTime-color );
	--gsuiSlider-lineBgColor: #222;
}
#headCurrentTime .gsuiSlider-eventCatcher {
	top: -10px;
	left: -10px;
	right: -10px;
	bottom: -10px;
}

/* .......................................................................... */
#ctrlA {
	grid-area: ctrlA;
	display: flex;
}

/* .......................................................................... */
#headPlay {
	display: flex;
}
.playBtn {
	background-color: var( --ctrl-play-bg );
}
#playToggle {
	padding: 6px 5px 6px 7px;
	display: flex;
	overflow: hidden;
	align-items: center;
	flex-direction: column;
	justify-content: space-between;
}
#playToggle span {
	width: 8px;
	height: 8px;
	box-sizing: border-box;
	border: 2px solid;
	border-radius: 2px;
}
#playToggle[ data-dir="up" ] span:first-child,
#playToggle[ data-dir="down" ] span:last-child {
	background-color: currentColor;
}
#stop {
	margin-left: -3px;
}

/* .......................................................................... */
#headTempo {
	display: flex;
	align-items: center;
	white-space: nowrap;
	background-color: #222;
}
#timeSignature {
	display: flex;
	align-items: center;
	flex-direction: column;
	justify-content: space-between;
	height: 40%;
	padding: 0 6px 0 8px;
	font-size: 14px;
	line-height: 0;
	font-family: var( --font-number );
}
#bpm {
	display: flex;
	align-items: baseline;
	padding-right: 7px;
	font-size: var( --bpm-fontSize );
	font-family: var( --font-number );
}
#bpm::after {
	content: "bpm";
	margin-left: 2px;
	font-size: 14px;
	opacity: .5;
}

/* .......................................................................... */
#ctrlB {
	grid-area: ctrlB;
	display: flex;
}

/* .......................................................................... */
#headHist {
	display: inline-flex;
	user-select: none;
}
#headHist .btn {
	background-color: #777;
}
#redo {
	margin-left: -4px;
}
#undoMore {
	padding: 0 6px 0 3px;
}

/* .......................................................................... */
#headAnalyser {
	width: 140px;
	border-radius: 4px;
	background-color: #000;
	filter: saturate( .5 ) contrast( .76 );
}

/* .......................................................................... */
#headExport {
	color: var( --ctrl-render-color );
}

/* .......................................................................... */
#winBtns {
	grid-area: winBtns;
	display: flex;
	white-space: nowrap;
}
.winBtn {
	padding: 2px 6px;
	font-size: 12px;
	font-weight: bold;
	border-radius: 0;
	background-color: var( --head-winBtn-bg );
	transition: var( --head-hover-dur );
	transition-property: color, background-color, box-shadow;
}
.winBtn:first-child {
	border-top-left-radius: 4px;
	border-bottom-left-radius: 4px;
}
.winBtn:last-child {
	border-top-right-radius: 4px;
	border-bottom-right-radius: 4px;
}
.winBtn + .winBtn {
	margin-left: 0;
	border-left: 1px dashed rgba( 0, 0, 0, .2 );
}
.winBtn-open {
	color: var( --head-bg );
	background-color: var( --head-winBtn-open-bg );
}
.winBtn::before {
	content: attr( data-text );
}

/* .......................................................................... */
#headHelp {
	grid-area: headHelp;
	display: flex;
}
#cookies {
	animation: infinite cookie-anim 5s;
}
#helpAbout {
	color: var( --ctrl-about-color );
}

@keyframes cookie-anim {
	30% { box-shadow: none; }
	35% { box-shadow: 0 0 0 3px var( --ctrl-eatcookie-color ); }
	100% { box-shadow: 0 0 0 3px transparent; }
}

/* .......................................................................... */
#headVersion {
	display: flex;
	align-items: center;
	justify-content: flex-end;
	grid-area: headVersion;
	user-select: none;
}
#headVersionBtn {
	display: flex;
	align-items: center;
	border: 0;
	padding: 0;
	outline: 0;
	border-radius: 4px;
	font-size: 18px;
	color: inherit;
	cursor: pointer;
	opacity: .3;
	background: none;
	transition: opacity var( --head-hover-dur );
}
#headVersionBtn:focus {
	box-shadow: 0 0 1px 2px #69b;
}
#headVersionBtn:focus,
#headVersionBtn:hover {
	opacity: 1;
}
#headVersionNum {
	margin-left: 6px;
	font-family: var( --font-number );
}

/*
	1. z-index: 1000 to be on top on all the windows possible.
*/
#cmps {
	left: var( --head-gap );
	width: 480px;
	grid-template-columns: 1fr 1fr;
	box-shadow: 12px var( --head-dropdown-shadow );
}

#cmps .windowBtn {
	color: var( --windowBtn-newCmp-color );
	margin-left: 8px;
}

#cmpsCloudList {
	border-left: 1px solid #444;
}

#app:not( .logged ) #cmpsCloudList .placeholder span:first-child,
#app.logged         #cmpsCloudList .placeholder span:last-child {
	display: none;
}
#app:not( .logged ) #cloudNewCmp {
	color: #888;
}
.popup {
	width: 500px;
}

/* .popup *content* --------------------------------------------------------- */
.popup fieldset {
	border: 2px solid #444;
	border-radius: 4px;
	margin-bottom: 10px;
}

.popup legend {
	font-size: 12px;
	opacity: .5;
}

.popup a {
	color: #707099;
}

.popup-error-msg {
	margin-top: 12px;
	font-size: 12px;
	color: #ed9a8b;
}
.popup-error-msg:empty {
	display: none;
}

.popup .param {
	display: flex;
	align-items: center;
	font-size: 14px;
}
.popup .param + .param {
	margin-top: 6px;
}

.popup .param-title {
	flex: 1;
}
.popup .param-values {
	display: flex;
	align-items: center;
	font-family: var( --font-monospace );
}
.popup .param-column {
	flex-direction: column;
}

.popup label {
	display: flex;
	align-items: center;
}
.popup input[ type="radio" ]:checked + label {
	font-weight: bold;
}

.popup input,
.popup button {
	border-radius: 2px;
	border: 0;
	color: inherit;
	font-size: inherit;
}
.popup input::placeholder {
	color: #aaa;
	font-style: italic;
}
.popup input[ type="radio" ],
.popup input[ type="checkbox" ] {
	margin-right: 8px;
	transform: scale( 1.5 );
}
.popup input[ type="range" ] {
	min-width: 0;
}

.popup input[ type="password" ],
.popup input[ type="number" ],
.popup input[ type="text" ],
.popup input[ type="url" ],
.popup input[ type="file" ] {
	width: 180px;
	height: 32px;
	padding: 0 8px;
	box-sizing: border-box;
	font-family: inherit;
	background-color: rgba( 255, 255, 255, .1 );
}
.popup input[ type="file" ] {
	width: 200px;
	height: auto;
	padding-top: 6px;
	padding-bottom: 6px;
}

/* #authPopupContent -------------------------------------------------------- */
#authPopupContent {
	width: 340px;
}
#authPopupContent a {
	font-size: 12px;
}

/* #selectChanPopupContent ---------------------------------------------------- */
#selectChanPopupContent,
#gsuiPatterns-selectChanPopupContent {
	width: auto;
}
#selectChanPopupSelect,
#gsuiPatterns-selectChanPopupSelect {
	width: 100%;
	color: inherit;
	background-color: transparent;
}
#selectChanPopupSelect option,
#gsuiPatterns-selectChanPopupSelect option {
	padding: 4px;
}

/* #tempoPopupContent ---------------------------------------------------- */
#tempoPopupContent {
	width: 400px;
}
#tempoBPM {
	width: calc( 180px - 6px - 32px );
}
#tempoBPMTap {
	display: flex;
	align-self: normal;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: inherit;
	width: 32px;
	font-size: 18px;
	margin-left: 6px;
	border-radius: 2px;
	background-color: rgba( 255, 255, 255, .1 );
}
#tempoBPMTap:hover {
	background-color: rgba( 255, 255, 255, .2 );
}

/* #shortcutsPopupContent --------------------------------------------------- */
#shortcutsPopupContent .param {
	padding: 4px;
}
#shortcutsPopupContent .param:nth-child( even ) {
	background-color: rgba( 255, 255, 255, .05 );
}

#shortcutsPopupContent .param-title {
	font-size: 13px;
}

#shortcutsPopupContent .shortcuts {
	display: inline-block;
	position: relative;
	border-radius: 4px;
	border-bottom: 3px solid #333;
	padding: 4px 6px;
	color: #fff;
	white-space: nowrap;
	background: #B82587;
}
#shortcutsPopupContent .shortcuts-sep {
	margin: 0 8px;
	font-size: 10px;
}
#shortcutsPopupContent .shortcuts .icon {
	width: auto;
}

/* #renderPopupContent ------------------------------------------------------- */
#renderWrap {
	display: flex;
	padding: 10px 0;
}
#renderProgress {
	flex: 1;
	height: 28px;
}
#renderBtn {
	padding: 0 .8em;
	border-radius: 2px;
	margin-right: 10px;
	color: #20BF9F;
	font-size: 12px;
	line-height: 28px;
	font-weight: bold;
	background-color: #00F7FF;
}
#renderBtn > span { display: none; }
#renderBtn[ data-status="0" ] #renderBtn0 { display: inline; }
#renderBtn[ data-status="1" ] #renderBtn1 { display: inline; }
#renderBtn[ data-status="2" ] #renderBtn2 { display: inline; }
#renderBtn .gsuiIcon {
	margin-left: .3em;
}

/* #settingsPopupContent ---------------------------------------------------- */
#settingsPopupContent {
	width: 400px;
}
#settingsPopupContent .param-values {
	width: 200px;
}
.settingsPopupFps {
	font-size: 16px;
}
.settingsPopupFps::after {
	content: " fps";
	font-family: var( --font-default );
	font-size: 12px;
	opacity: .6;
}
#settingsUIRateManual {
	flex: 1;
	margin-left: 8px;
}

/* #aboutPopupContent ------------------------------------------------------- */
#aboutPopupContent {
	width: 450px;
	text-align: center;
}
#aboutPopupContent > div {
	margin-bottom: 16px;
}

#aboutPopupContent .title {
	display: flex;
	align-items: baseline;
	justify-content: center;
}
#aboutPopupContent .title > span:first-child {
	margin-right: 4px;
	font: 32px var( --font-oswald );
}

#aboutPopupContent a {
	color: #ccf;
	font-weight: bold;
}

#aboutPopupContent .social-network {
	display: flex;
}

#aboutPopupContent .social-network a {
	flex: 1;
	padding: 20px 0;
	color: #fff;
	font-size: 36px;
	font-weight: normal;
	opacity: .5;
	transition: .4s;
	transition-property: opacity;
}
#aboutPopupContent .social-network a:hover {
	opacity: 1;
}
#aboutPopupContent .social-network a:hover::before {
	top: -4px;
	left: 4px;
	text-shadow: -4px 4px 2px rgba( 0, 0, 0, .2 );
}
#aboutPopupContent .social-network a::before {
	position: relative;
	top: 0;
	left: 0;
	transition: .2s;
	transition-property: top, left, text-shadow;
}
#aboutPopupContent .social-network:hover a:not( :hover ) {
	opacity: .3;
}
.gsuiWindow[ data-window-id="mixer" ] .gsuiWindow-content {
	overflow-y: hidden;
}

/* .......................................................................... */
.windowBetaMsg {
	color: #fff;
	padding: 8px;
	font-size: 11px;
	font-weight: bold;
	background: #B82587;
}

/* .......................................................................... */
.windowBtn {
	height: 20px;
	padding: 0 8px;
	max-width: 110px;
	border: 0;
	outline: 0;
	cursor: pointer;
	overflow: hidden;
	border-radius: 3px;
	line-height: 1;
	color: inherit;
	font-size: 12px;
	font-weight: bold;
	font-family: inherit;
	white-space: nowrap;
	text-overflow: ellipsis;
	background-color: var( --windowBtn-bg );
	transition: filter .2s;
}
.windowBtn:focus,
.windowBtn:hover {
	filter: brightness( 1.1 );
}

.windowBtnIcon,
.windowBtnText {
	pointer-events: none;
}

.windowBtnIcon + .windowBtnText {
	margin-left: 4px;
}

.windowDataBtn:empty::before {
	content: "Untitled";
	font-style: italic;
}
#channelName,
#synthChannelBtn { color: var( --windowBtn-chan-color ); }
#drumsNew,
#drumsName,
#pianorollName { color: var( --windowBtn-pattern-color ); }
#synthName { color: var( --windowBtn-synth-color ); }
#synthChanName {
	margin: 0;
	padding-right: 4px;
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}

/* .......................................................................... */
#synthDestArrow {
	margin: 0 6px;
	pointer-events: none;
}

/* .......................................................................... */
.gsuiDrums,
.gsuiPianoroll,
.gsuiPatternroll,
.gsuiSynthesizer {
	height: 100%;
	outline: 0;
}
.cmp {
	box-sizing: border-box;
	display: flex;
	color: var( --cmp-text );
	height: var( --cmp-height );
	font-size: var( --cmp-text-size );
	line-height: var( --cmp-height );
	background-color: var( --cmp-bg );
	filter: brightness( .9 );
}
#cmpsLocalList .cmp { --cmp-bg: var( --cmp-local-bg ); }
#cmpsCloudList .cmp { --cmp-bg: var( --cmp-cloud-bg ); }
.cmp:nth-child( odd ) {
	filter: brightness( .85 );
}
.cmp.cmp-loaded {
	filter: none;
}
.cmp-loading {
	pointer-events: none;
}

/* .......................................................................... */
.cmp-btn {
	border: 0;
	color: inherit;
	cursor: pointer;
	font-size: 16px;
	background: none;
}
.cmp-btn-light {
	opacity: .7;
	padding: 0 8px;
	transition: .2s opacity;
}
.cmp-btn-light:focus,
.cmp-btn-light:hover {
	opacity: 1;
}

/* .......................................................................... */
.cmp-save {
	width: 32px;
	background-color: var( --cmp-save-bg );
	transition: .2s;
	transition-property: margin-left, color, background-color, visibility;
}
.cmp-saved .cmp-save {
	visibility: hidden;
	margin-left: -32px;
}
.cmp-save.cmp-save:focus,
.cmp-save.cmp-save:hover {
	color: var( --cmp-save-bg );
	background-color: var( --cmp-text );
}

/* .......................................................................... */
.cmp-info {
	flex: 1;
	display: flex;
	align-items: flex-start;
	flex-direction: column;
	justify-content: space-between;
	padding: 6px 6px 4px;
	overflow: hidden;
	font-size: 13px;
	line-height: 1em;
	transition: .2s;
	transition-property: padding-left, opacity;
	opacity: .7;
}
.cmp-info:focus,
.cmp-info:hover,
.cmp-loaded .cmp-info {
	opacity: 1;
}
.cmp-info > div {
	pointer-events: none;
	white-space: nowrap;
	text-overflow: ellipsis;
	overflow: hidden;
}

/* .......................................................................... */
.cmp-name {
	max-width: 100%;
	font-weight: bold;
	border-radius: 2px;
	padding-right: .4ch;
	transition: .2s;
	transition-property: box-shadow, color, background-color;
}
.cmp-info:focus .cmp-name,
.cmp-info:hover .cmp-name {
	color: var( --cmp-bg );
	box-shadow: 0 0 0 2px var( --cmp-text );
	background-color: var( --cmp-text );
}
.cmp:not( .cmp-saved ) .cmp-name::before {
	content: "*";
}
.cmp-name:empty::after {
	font-style: italic;
	content: "Untitled";
}

/* .......................................................................... */
.cmp-bpm-wrap,
.cmp-duration-wrap {
	display: inline-flex;
	align-items: center;
	font: 14px var( --font-number );
}
.cmp-duration-wrap {
	margin-right: 10px;
}
.cmp-info .gsuiIcon {
	margin-right: 4px;
	opacity: .4;
}
#history {
	left: 420px;
	width: 360px;
	box-shadow: 2px var( --head-dropdown-shadow );
}
#version {
	font-size: 18px;
}

#versionNum {
	opacity: .8;
	font-family: var( --font-number );
}

#versionCheck {
	font-size: 11px;
	font-weight: bold;
	opacity: .4;
	cursor: pointer;
	transition: .2s opacity;
}
#versionCheck:hover {
	opacity: 1;
}
.placeholder {
	display: none;
	height: 100%;
	box-sizing: border-box;
	align-items: center;
	justify-content: center;
	padding: 1em;
	text-align: center;
	font-size: 12px;
	opacity: .5;
	user-select: none;
}
.placeholder:only-child {
	display: flex;
}
.headDropdown {
	position: absolute;
	overflow: hidden;
	display: grid;
	height: 320px;
	grid-template-rows: 32px 1fr;
	box-sizing: border-box;
	top: calc( 100% + var( --head-gap ) );
	z-index: 1;
	outline: 0;
	border: 2px solid #444;
	border-radius: 4px;
	transition: .2s;
	transition-property: opacity, visibility;
}
.headDropdown:focus {
	border-color: #69b;
}
.headDropdown:focus-within {
	z-index: 2;
}
.headDropdown-btn:not( :focus ) + .headDropdown:not( :focus-within ) {
	opacity: 0;
	visibility: hidden;
}

.headDropdown-head {
	display: flex;
	align-items: center;
	color: #222;
	font-size: 14px;
	background-color: #888;
	user-select: none;
}
.headDropdown-icon {
	margin: 0 6px;
	font-size: 16px;
}
.headDropdown-title {
	font-weight: bold;
}

.headDropdown-list {
	overflow: auto;
	background-color: #C9C9C9;
}

.headDropdown-backdrop {
	position: absolute;
	top: 68px;
	left: 0;
	right: 0;
	bottom: -1000px;
	opacity: 0;
	visibility: hidden;
	backdrop-filter: blur( 10px );
	background-color: #0009;
	transition: .4s;
	transition-property: visibility, opacity;
}
.headDropdown-btn:focus ~ .headDropdown-backdrop,
.headDropdown:focus-within + .headDropdown-backdrop {
	visibility: visible;
	opacity: 1;
}
.historyAction {
	display: flex;
	box-sizing: border-box;
	align-items: center;
	cursor: pointer;
	height: 30px;
	padding: 0 6px;
	color: var( --history-action-text );
	font-size: 14px;
	font-family: var( --font-monospace );
	background-color: var( --history-action-bg );
	transition: filter .2s;
}
.historyAction:hover {
	filter: brightness( 1.3 );
}

/* -------------------------------------------------------------------------- */
.historyAction::before {
	content: "";
	display: block;
	width: 6px;
	height: 6px;
	border-radius: 50%;
	transition: inherit;
	background-color: var( --history-actionlight-bg );
}
.historyAction-undone:not( :hover )::before {
	background-color: var( --history-actionlightoff-bg );
}

/* -------------------------------------------------------------------------- */
.historyAction-icon {
	width: 1.4ch;
	margin: 0 6px;
	text-align: center;
}
.historyAction-text {
	flex: 1;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	transition-duration: inherit;
	transition-property: opacity;
}
.historyAction-undone .historyAction-icon,
.historyAction-undone .historyAction-text {
	opacity: .6;
}
#pianorollForbidden {
	position: absolute;
	z-index: 2000000; /* 1. */
	top: 0;
	width: 100%;
	height: 100%;
	display: flex;
	overflow: hidden;
	align-items: center;
	justify-content: center;
	background: #B818A3;
	transition: .2s;
	transition-property: opacity, visibility;
}
#pianorollForbidden.hidden {
	opacity: 0;
	visibility: hidden;
}
#pianorollForbidden::before {
	content: "No pattern selected...";
	display: block;
	padding: 18px;
	color: #ddd;
	font-size: 12px;
	font-style: italic;
	font-weight: bold;
	border-radius: 4px;
	background-color: rgba( 255, 255, 255, .1 );
}

/*
1.
	z-index: 2000000; because of gsuiSliderGroup
*/
</style>
</head>
<body>

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M2VH8NR"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<noscript id="noscript">SquencerSynthisizer needs JavaScript to run</noscript>
<div id="loading">
	<div id="loadingContent">
		<div class="TextGlitch" id="gsTitle">
			<div class="TextGlitch-clip">
				<div class="TextGlitch-word">SquencerSynthisizer v.1.5 "open Beginner"</div>
				<div class="TextGlitch-word TextGlitch-blend TextGlitch-blendA"></div>
				<div class="TextGlitch-word TextGlitch-blend TextGlitch-blendB"></div>
			</div>
			<div class="TextGlitch-clip">
				<div class="TextGlitch-word"></div>
				<div class="TextGlitch-word TextGlitch-blend TextGlitch-blendA"></div>
				<div class="TextGlitch-word TextGlitch-blend TextGlitch-blendB"></div>
			</div>
			<div class="TextGlitch-clip">
				<div class="TextGlitch-word"></div>
				<div class="TextGlitch-word TextGlitch-blend TextGlitch-blendA"></div>
				<div class="TextGlitch-word TextGlitch-blend TextGlitch-blendB"></div>
			</div>
		</div>
		<span id="loadingLoading">loading...</span>
		<span id="loadingLoaded">click to start</span>
		<span id="loadingStarting">starting...</span>
	</div>
</div>
<div id="app">
	<!--#head-->
	<div id="body"></div>
</div>
<div id="head">
	<div id="header">
		<span id="title" data-text="Squencer" data-text-s="GS"></span>
		<a class="btn btnLarge headBtn" href id="headUser" title="Cloud profile" target="_blank" rel="noopener"></a>
		<button class="btn btnLarge headBtn btnIconLarge gsuiIcon" id="login" data-icon="profile" title="Login to Squencer"></button>
		<button class="btn btnLarge headBtn btnIconLarge gsuiIcon" id="logout" data-icon="logout" title="Logout"></button>
		<div id="headCmps">
			<button class="btn btnLarge headBtn headDropdown-btn gsuiIcon" id="cmpsBtn" data-icon="musics" title="Create cloud/local compositions"></button>
			<!--#cmps-->
			<div class="headDropdown-backdrop"></div>
		</div>
	</div>
	<div id="headCmp">
		<button id="headCmpSave" class="btn cmp-save gsuiIcon" title="Save composition"></button>
		<button id="headCmpInfo" class="btn" title="Edit composition's title">
			<i id="headCmpIcon" class="gsuiIcon"></i>
			<span id="headCmpName"></span>
			<span id="headCmpHover" class="gsuiIcon" data-icon="pen"></span>
			<span id="headCmpDur"></span>
		</button>
	</div>
	<div id="ctrlA">
		<div id="headGain" class="btnMarge" title="Main app volume (this will not affect the rendering)">
			<gsui-slider type="linear-y" min="0" max="1" step=".01" mousemove-size="150"></gsui-slider>
		</div>
		<div id="headPlay" class="btnGroup btnMarge">
			<button class="playBtn btn" id="playToggle" data-dir="up" title="Toggle focus between the composition and piano windows"><span></span><span></span></button>
			<button class="playBtn btn btnLarge gsuiIcon" id="play" data-icon="play"></button>
			<button class="playBtn btn btnLarge gsuiIcon" id="stop" data-icon="stop"></button>
		</div>
		<button id="headTempo" class="btn btnMarge" title="Edit the time signature and BPM">
			<div id="timeSignature">
				<span id="beatsPerMeasure"></span>
				<span id="stepsPerBeat"></span>
			</div>
			<div id="bpm"></div>
		</button>
	</div>
	<div id="ctrlB">
		<div id="headHist" class="btnGroup btnMarge">
			<button class="histBtn btn btnLarge gsuiIcon" id="undo" data-icon="undo" title="Undo the previous action"></button>
			<button class="histBtn btn btnLarge gsuiIcon" id="redo" data-icon="redo" title="Redo the last action"></button>
			<button class="histBtn btn headDropdown-btn gsuiIcon" id="undoMore" data-icon="caret-down" title="Show the actions list"></button>
			<!--#history-->
			<div class="headDropdown-backdrop"></div>
		</div>
		<canvas id="headAnalyser" class="btnMarge"></canvas>
		<button id="headExport" class="btn btnMarge btnLarge btnBg gsuiIcon" data-icon="export" title="Export the composition"></button>
		<button id="headSettings" class="btn btnMarge btnLarge btnBg gsuiIcon" data-icon="settings" title="Settings"></button>
		<!-- <button id="headMidi" class="btn btnMarge btnLarge btnBg gsuiIcon" data-icon="midi" title="Midi devices"></button> -->
	</div>
	<div id="headCurrentTime">
		<gsui-slider type="linear-x" min="0" step=".01"></gsui-slider>
	</div>
	<div id="winBtns">
		<button class="btn btnMarge winBtn" data-win="blocks" title="Open/close the blocks window">blocks</button>
		<button class="btn btnMarge winBtn" data-win="mixer" title="Open/close the mixer window">mixer</button>
		<button class="btn btnMarge winBtn" data-win="synth" title="Open/close the synthesizer window">synth</button>
		<button class="btn btnMarge winBtn" data-win="main" title="Open/close the composition window">composition</button>
		<button class="btn btnMarge winBtn" data-win="drums" title="Open/close the drums window">drums</button>
		<button class="btn btnMarge winBtn" data-win="piano" title="Open/close the piano window">pianoroll</button>
		<button class="btn btnMarge winBtn" data-win="effects" title="Open/close the effects window">effects</button>
	</div>
	<div id="headHelp">
		<button class="btn btnMarge btnLarge btnBg gsuiIcon" id="cookies" data-icon="cookie" title="Cookies"></button>
		<button class="btn btnMarge btnLarge btnBg gsuiIcon" id="helpKeyboardShortcuts" data-icon="keyboard" title="Keyboard shortcuts"></button>
		<a      class="btn btnMarge btnLarge btnBg gsuiIcon" id="help" data-icon="help" title="Help" href="https://squencer.netlify.app/music.html" target="_blank" rel="noopener"></a>
		<a      class="btn btnMarge btnLarge btnBg gsuiIcon" id="changelog" data-icon="changelog" title="Changelog" href="https://squencer.netlify.app" target="_blank" rel="noopener"></a>
		<button class="btn btnMarge btnLarge btnBg gsuiIcon" id="helpAbout" data-icon="about" title="About"></button>
	</div>
	<div id="headVersion">
		<a id="headVersionBtn" class="headDropdown-btn" title="Access older versions" href="https://squencer.netlify.app" target="_blank" rel="noopener">
			<i class="gsuiIcon" data-icon="list"></i>
			<span id="headVersionNum"></span>
		</a>
	</div>
</div>
<div class="cmp" id="cmp" draggable="true" data-remove data-remove-id>
	<button data-action="save" class="cmp-btn cmp-save gsuiIcon"></button>
	<a href data-action="open" class="cmp-info">
		<div class="cmp-name"></div>
		<div>
			<span class="cmp-duration-wrap">
				<i class="gsuiIcon" data-icon="clock"></i>
				<span class="cmp-duration"></span>
			</span>
			<span class="cmp-bpm-wrap">
				<i class="gsuiIcon" data-icon="speed"></i>
				<span class="cmp-bpm"></span>
			</span>
		</div>
	</a>
	<a href class="cmp-btn cmp-btn-light gsuiIcon" data-action="json" data-icon="file-export" title="Export to JSON file"></a>
	<button class="cmp-btn cmp-btn-light gsuiIcon" data-action="delete" data-icon="minus-oct" title="Delete"></button>
</div>
<div id="cmps" class="headDropdown" tabindex="0">
	<div class="headDropdown-head" id="cmpsLocalTitle">
		<i class="headDropdown-icon gsuiIcon" data-icon="local"></i>
		<span class="headDropdown-title">local</span>
		<button class="windowBtn" id="localNewCmp" title="Create a new composition on this computer">
			<i class="windowBtnIcon gsuiIcon" data-icon="plus"></i>
			<span class="windowBtnText">new</span>
		</button>
		<button class="windowBtn" id="localOpenCmp" title="Open a composition on this computer">
			<i class="windowBtnIcon gsuiIcon" data-icon="folder-open"></i>
			<span class="windowBtnText">open</span>
		</button>
	</div>
	<div class="headDropdown-head" id="cmpsCloudTitle">
		<i class="headDropdown-icon gsuiIcon" data-icon="cloud"></i>
		<span class="headDropdown-title">cloud</span>
		<button class="windowBtn" id="cloudNewCmp" title="Create a new composition on your cloud profile">
			<i class="windowBtnIcon gsuiIcon" data-icon="plus"></i>
			<span class="windowBtnText">new</span>
		</button>
	</div>
	<div class="headDropdown-list" id="cmpsLocalList">
		<div class="placeholder">
			<span>there is no local composition here</span>
		</div>
	</div>
	<div class="headDropdown-list" id="cmpsCloudList">
		<div class="placeholder">
			<span>you don't have any cloud composition yet</span>
			<span>you are not connected</span>
		</div>
	</div>
</div>
<div id="history" class="headDropdown" tabindex="0">
	<div class="headDropdown-head" id="historyTitle">
		<i class="headDropdown-icon gsuiIcon" data-icon="history"></i>
		<span class="headDropdown-title">history</span>
	</div>
	<div class="headDropdown-list" id="historyList">
		<div class="placeholder">
			<span>there is nothing to undo</span>
		</div>
	</div>
</div>
<div class="historyAction" id="historyAction" data-remove data-remove-id>
	<i class="historyAction-icon gsuiIcon"></i>
	<span class="historyAction-text"></span>
</div>
<div data-window="blocks"></div>
<div data-window="mixer"></div>
<div data-window="synth">
	<div class="windowMenu">
		<button id="synthName" class="windowBtn windowDataBtn"></button>
		<i id="synthDestArrow" class="gsuiIcon" data-icon="arrow-right"></i>
		<button id="synthChannelBtn" class="windowBtn">
			<i class="windowBtnIcon gsuiIcon" data-icon="mixer"></i>
			<span id="synthChannelBtnText" class="windowBtnText"></span>
		</button>
	</div>
</div>
<div data-window="piano">
	<div class="windowMenu">
		<button id="pianorollName" class="windowBtn windowDataBtn"></button>
	</div>
	<div id="pianorollForbidden" class="no-select"></div>
</div>
<div data-window="main"></div>
<div data-window="effects">
	<div class="windowMenu">
		<button id="channelName" class="windowBtn windowDataBtn"></button>
	</div>
	<div class="windowBetaMsg">
		Beta: the effects may not work as expected due to browser support
	</div>
</div>
<div data-window="drums">
	<div class="windowMenu">
		<button id="drumsName" class="windowBtn windowDataBtn"></button>
	</div>
</div>
<div class="popup" id="authPopupContent" data-remove>
	<fieldset>
		<legend>Sign in</legend>
		<div class="param">
			<div class="param-title">
				<span>Email</span>
				<small>or username</small>
			</div>
			<div class="param-values">
				<input type="text" name="email"/>
			</div>
		</div>
		<div class="param">
			<div class="param-title">
				<span>Password</span>
			</div>
			<div class="param-values">
				<input type="password" name="password"/>
			</div>
		</div>
		<div id="authPopupError" class="popup-error-msg"></div>
	</fieldset>
	<a target="_blank" rel="noopener" href="https://squencer.netlify.app/#/forgotPassword">Forgot password&nbsp;?</a><br/>
	<a target="_blank" rel="noopener" href="https://squencer.netlify.app/#/auth">Create a new account</a>
</div>
<div class="popup" id="openPopupContent" data-remove>
	<fieldset>
		<legend>Open and load a new composition</legend>
		<div class="param">
			<div class="param-title">With an URL</div>
			<div class="param-values">
				<input id="inputOpenURL" name="url" type="url" placeholder="http://"/>
			</div>
		</div>
		<div class="param">
			<div class="param-title">
				With a local file<br/>
				<small>(Please notice that you can also drop a file into the app)</small>
			</div>
			<div class="param-values">
				<input id="inputOpenFile" name="file" type="file"/>
			</div>
		</div>
	</fieldset>
</div>
<div class="popup" id="aboutPopupContent" data-remove>
	<div class="title">
		<span>SquencerSynthBeginner</span>
		<span id="version">
			<span id="versionNum"></span>
			<i id="versionIcon" class="gsuiIcon"></i>
			<span id="versionCheck">check the version</span>
		</span>
	</div>
	<div>
		<img src="yoga.jpg" alt="Young Generations Audio" width="300" height="100%">
		Squencer is a <b>work-in-progress</b> free browser-based digital audio workstation following the
		<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a>.
	</div>
	<div>
		You can or don't create an account (by clicking <i class="gsuiIcon" data-icon="profile"></i>)
		and start uploading your compositions online <i class="gsuiIcon" data-icon="cloud"></i>
	</div>
	<div class="social-network">
		<a target="_blank" rel="noopener" title="GitHub"   class="gsuiIcon gsuiIconB" data-icon="github"   href="https://squencer.netlify.app"></a>
		<a target="_blank" rel="noopener" title="Twitter"  class="gsuiIcon gsuiIconB" data-icon="twitter"  href="https://twitter.com/"></a>
		<a target="_blank" rel="noopener" title="YouTube"  class="gsuiIcon gsuiIconB" data-icon="youtube"  href="https://youtube.com/channel/"></a>
		<a target="_blank" rel="noopener" title="Facebook" class="gsuiIcon gsuiIconB" data-icon="facebook" href="https://facebook.com/RRRrecording"></a>
		<a target="_blank" rel="noopener" title="CodePen"  class="gsuiIcon gsuiIconB" data-icon="codepen"  href="https://codepen.io/"></a>
		<a target="_blank" rel="noopener" title="Discord"  class="gsuiIcon gsuiIconB" data-icon="discord"  href="https://discord.gg/"></a>
	</div>
</div>
<div class="popup" id="tempoPopupContent" data-remove>
	<fieldset>
		<legend>BPM / time signature</legend>
		<div class="param">
			<div class="param-title">Beats per measure</div>
			<div class="param-values"><input id="tempoBeatsPM" name="beatsPerMeasure" type="number" min="1" max="16"/></div>
		</div>
		<div class="param">
			<div class="param-title">Steps per beat</div>
			<div class="param-values"><input id="tempoStepsPB" name="stepsPerBeat" type="number" min="1" max="16"/></div>
		</div>
		<div class="param">
			<div class="param-title">BPM (Beats Per Minute)</div>
			<div class="param-values">
				<input id="tempoBPM" name="bpm" type="number" min="1" max="999"/>
				<a id="tempoBPMTap" class="gsuiIcon" data-icon="tint"></a>
			</div>
		</div>
	</fieldset>
</div>
<div class="popup" id="renderPopupContent" data-remove>
	<fieldset>
		<legend>Render the current composition</legend>
		<div id="renderWrap">
			<a href id="renderBtn">
				<span id="renderBtn0">
					<span>Render</span>
					<i class="gsuiIcon" data-icon="render"></i>
				</span>
				<span id="renderBtn1">
					<span>Rendering...</span>
					<i class="gsuiIcon" data-spin="on"></i>
				</span>
				<span id="renderBtn2">
					<span>Download WAV file</span>
					<i class="gsuiIcon" data-icon="export"></i>
				</span>
			</a>
			<progress id="renderProgress" value="" max="1"></progress>
		</div>
	</fieldset>
</div>
<div class="popup" id="settingsPopupContent" data-remove>
	<fieldset>
		<legend>UI refresh rate</legend>
		<div class="param">
			<div class="param-title">Auto</div>
			<div class="param-values">
				<label>
					<input id="settingsUIRateModeAuto" name="UIRateMode" type="radio" value="auto"/>
					<span class="settingsPopupFps">60</span>
				</label>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Manual</div>
			<div class="param-values">
				<label>
					<input id="settingsUIRateModeManual" name="UIRateMode" type="radio" value="manual"/>
					<span id="settingsUIRateManualFps" class="settingsPopupFps"></span>
				</label>
				<input id="settingsUIRateManual" name="UIRateManual" type="range" step="1" min="5" max="40"/>
			</div>
		</div>
	</fieldset>
	<fieldset>
		<legend>Windows</legend>
		<div class="param">
			<div class="param-title">Move/resize mode</div>
			<div class="param-values">
				<label>
					<input id="settingsWindowsMode" name="windowsDirectMode" type="checkbox"/>
					<span>direct</span>
				</label>
			</div>
		</div>
	</fieldset>
</div>
<div class="popup" id="shortcutsPopupContent" data-remove>
	<fieldset>
		<legend>Global shortcuts</legend>
		<div class="param">
			<div class="param-title">Save the current composition</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">S</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Open a composition</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">O</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Open a new composition</div>
			<div class="param-values">
				<kbd class="shortcuts">Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">N</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Play / pause the selected grid</div>
			<div class="param-values">
				<kbd class="shortcuts">Space</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Undo the previous action</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">Z</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Redo the next action</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">Shift</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">Z</kbd>
			</div>
		</div>
	</fieldset>
	<fieldset>
		<legend>Grids shortcuts</legend>
		<div class="param">
			<div class="param-title">Select all the blocks of the focused grid</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">A</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Deselect all the blocks of the focused grid</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">D</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Duplicate (copy/paste) the selected blocks</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / Alt</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">B</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Delete all the selected blocks of the focused grid</div>
			<div class="param-values">
				<kbd class="shortcuts">Delete</kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Move vertically inside the grids</div>
			<div class="param-values">
				<kbd class="shortcuts">Scroll <i class="gsuiIcon" data-icon="arrows-v"></i></kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">Move horizontally inside the grids</div>
			<div class="param-values">
				<kbd class="shortcuts">Shift</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">Scroll <i class="gsuiIcon" data-icon="arrows-v"></i></kbd>
			</div>
		</div>
		<div class="param">
			<div class="param-title">
				Zoom-in / zoom-out<br/>
				Zoom X by scrolling above the grid<br/>
				Zoom Y by scrolling above the keys<br/>
			</div>
			<div class="param-values">
				<kbd class="shortcuts">Ctrl / ?</kbd><i class="shortcuts-sep gsuiIcon" data-icon="plus"></i>
				<kbd class="shortcuts">Scroll <i class="gsuiIcon" data-icon="arrows-v"></i></kbd>
			</div>
		</div>
	</fieldset>
</div>
<div class="popup" id="selectChanPopupContent" data-remove>
	<fieldset>
		<legend>Select a channel</legend>
		<select id="selectChanPopupSelect" size="8" name="channel"></select>
	</fieldset>
</div>
<div id="gsuiPianoroll-template" class="gsuiBlocksManager gsuiPianoroll" tabindex="-1"></div>

<div class="gsuiBlocksManager-block gsuiPianoroll-block" id="gsuiPianoroll-block-template" data-action="move">
	<div class="gsuiDragline-drop"></div>
	<div class="gsuiPianoroll-block-env gsuiPianoroll-block-attack">
		<div class="gsuiPianoroll-block-envHandle" data-action="attack"></div>
		<div class="gsuiPianoroll-block-envBg"></div>
	</div>
	<div class="gsuiPianoroll-block-env gsuiPianoroll-block-release">
		<div class="gsuiPianoroll-block-envHandle" data-action="release"></div>
		<div class="gsuiPianoroll-block-envBg"></div>
	</div>
	<div class="gsuiBlocksManager-block-crop gsuiBlocksManager-block-cropB" data-action="cropB"></div>
</div>
<div id="gsuiPatternroll-template" class="gsuiBlocksManager gsuiPatternroll" tabindex="-1"></div>

<div id="gsuiPatternroll-block-template" class="gsuiBlocksManager-block gsuiPatternroll-block" data-action="move">
	<div class="gsuiBlocksManager-block-crop gsuiBlocksManager-block-cropA" data-action="cropA"></div>
	<div class="gsuiBlocksManager-block-crop gsuiBlocksManager-block-cropB" data-action="cropB"></div>
	<div class="gsuiPatternroll-block-header">
		<span class="gsuiPatternroll-block-name"></span>
	</div>
	<div class="gsuiPatternroll-block-content"></div>
	<div class="gsuiPatternroll-block-placeholder">
		<i class="gsuiPatternroll-block-placeholderIcon gsuiIcon" data-icon="file-corrupt"></i>
		<span class="gsuiPatternroll-block-placeholderText">missing data</span>
	</div>
</div>
<script>
"use strict";

if ( navigator.serviceWorker &&
	document.cookie.indexOf( "cookieAccepted" ) > -1
) {
	navigator.serviceWorker.register( "serviceWorker.js" )
		.then( reg => {
			console.log( `Service worker ${
				reg.installing ? "installing" :
				reg.waiting ? "installed" :
				reg.active ? "active" : "" }` );
		}, console.log.bind( console, "Service worker registration failed" ) );
}

if ( !window.AudioContext || !window.customElements ) {
	window.top.location = "https://squencer.netlify.app/unsupported-browsers";
}

const GSUtils = {};

GSUtils.addIfNotEmpty = ( obj, attr, valObj ) => {
	if ( GSUtils.isntEmpty( valObj ) ) {
		if ( attr in obj ) {
			GSUtils.deepAssign( obj[ attr ], valObj );
		} else {
			obj[ attr ] = valObj;
		}
	}
	return obj;
};

GSUtils.castToNumber = ( n, def, min, max, fix ) => {
	const x = Number.isFinite( +n )
			? Math.max( min, Math.min( n, max ) )
			: def;

	return typeof fix === "number"
		? +x.toFixed( 2 )
		: +x;
};

GSUtils.composeUndo = ( data, redo ) => {
	if ( GSUtils.isObject( data ) && GSUtils.isObject( redo ) ) {
		return Object.freeze( Object.entries( redo ).reduce( ( undo, [ k, val ] ) => {
			if ( data[ k ] !== val ) {
				undo[ k ] = GSUtils.composeUndo( data[ k ], val );
			}
			return undo;
		}, {} ) );
	}
	return data;
};

GSUtils.createUpdateDelete = ( dataSrc, fnCreate, fnUpdate, fnDelete, dataChange ) => {
	if ( dataChange ) {
		Object.entries( dataChange ).forEach( ( [ id, obj ] ) => {
			if ( !obj ) {
				if ( id in dataSrc ) {
					fnDelete( id, dataChange );
				}
			} else if ( id in dataSrc ) {
				fnUpdate( id, obj, dataChange );
			} else {
				fnCreate( id, obj, dataChange );
			}
		} );
	}
};

GSUtils.deepAssign = ( a, b ) => {
	if ( b ) {
		Object.entries( b ).forEach( ( [ k, val ] ) => {
			if ( !GSUtils.isObject( val ) ) {
				a[ k ] = val;
			} else if ( !GSUtils.isObject( a[ k ] ) ) {
				a[ k ] = GSUtils.deepCopy( val );
			} else {
				GSUtils.deepAssign( a[ k ], val );
			}
		} );
	}
	return a;
};

GSUtils.deepCopy = obj => {
	if ( GSUtils.isObject( obj ) ) {
		return Object.entries( obj ).reduce( ( cpy, [ k, v ] ) => {
			cpy[ k ] = GSUtils.deepCopy( v );
			return cpy;
		}, {} );
	}
	return obj;
};

GSUtils.deepFreeze = obj => {
	if ( GSUtils.isObject( obj ) ) {
		Object.freeze( obj );
		Object.values( obj ).forEach( GSUtils.deepFreeze );
	}
	return obj;
};

GSUtils.diffAssign = ( a, b ) => {
	if ( b ) {
		Object.entries( b ).forEach( ( [ k, val ] ) => {
			if ( a[ k ] !== val ) {
				if ( val === undefined ) {
					delete a[ k ];
				} else if ( !GSUtils.isObject( val ) ) {
					a[ k ] = val;
				} else if ( !GSUtils.isObject( a[ k ] ) ) {
					a[ k ] = GSUtils.jsonCopy( val );
				} else {
					GSUtils.diffAssign( a[ k ], val );
				}
			}
		} );
	}
	return a;
};

GSUtils.isEmpty = obj => {
	for ( const a in obj ) {
		return false;
	}
	return true;
};

GSUtils.isntEmpty = obj => !GSUtils.isEmpty( obj );

GSUtils.isObject = o => o !== null && typeof o === "object";

GSUtils.jsonCopy = obj => JSON.parse( JSON.stringify( obj ) );

GSUtils.mapCallbacks = ( names, fns ) => {
	const on = {};

	names.forEach( n => on[ n ] = GSUtils.noop );
	Object.assign( Object.seal( on ), fns );
	return Object.freeze( on );
};

GSUtils.noop = () => {};
GSUtils.isNoop = fn => !fn || fn === GSUtils.noop;

GSUtils.panningMerge = ( ...pans ) => {
	const lr = pans.map( GSUtils.panningSplitLR )
		.reduce( ( ret, lr ) => {
			ret[ 0 ] *= lr[ 0 ];
			ret[ 1 ] *= lr[ 1 ];
			return ret;
		}, [ 1, 1 ] );

	return GSUtils.panningMergeLR( ...lr );
};

GSUtils.panningMergeLR = ( l, r ) => {
	return (
		l > r ? -1 + r / l :
		l < r ?  1 - l / r : 0
	);
};

GSUtils.panningSplitLR = pan => {
	return (
		pan < 0 ? [ 1, 1 + pan ] :
		pan > 0 ? [ 1 - pan, 1 ] : [ 1, 1 ]
	);
};

GSUtils.parseBeatsToBeats = ( beats, stepsPerBeat ) => {
	const steps = beats % 1 * stepsPerBeat;

	return [
		`${ beats + 1 | 0 }`,
		`${ steps + 1 | 0 }`.padStart( 2, "0" ),
		`${ steps * 1000 % 1000 | 0 }`.padStart( 3, "0" ),
	];
};

GSUtils.parseBeatsToSeconds = ( beats, bpm ) => {
	const seconds = beats / ( bpm / 60 );

	return [
		`${ seconds / 60 | 0 }`,
		`${ seconds % 60 | 0 }`.padStart( 2, "0" ),
		`${ seconds * 1000 % 1000 | 0 }`.padStart( 3, "0" ),
	];
};

GSUtils.plural = ( nb, word, s ) => {
	const w = word[ word.length - 1 ] === "s"
			? word
			: `${ word }${ nb > 1 ? "s" : "" }`,
		ws = s !== "'s"
			? w
			: `${ w }'${ w[ w.length - 1 ] === "s" ? "" : "s" }`

	return `${ nb } ${ ws }`;
};

GSUtils.trim2 = str => str ? str.trim().replace( /\s+/g, " " ) : "";

GSUtils.uniqueName = ( nameOri, arr ) => {
	const name = GSUtils.trim2( nameOri );

	if ( arr.indexOf( name ) > -1 ) {
		const name2 = /-\d+$/.test( name )
				? name.substr( 0, name.lastIndexOf( "-" ) ).trim()
				: name,
			reg = new RegExp( `^${ name2 }-(\\d+)$` ),
			nb = arr.reduce( ( nb, str ) => {
				const res = reg.exec( str );

				return res ? Math.max( nb, +res[ 1 ] ) : nb;
			}, 1 );

		return `${ name2 }-${ nb + 1 }`;
	}
	return name;
};

GSUtils.uuid = () => {
	const rnd = crypto.getRandomValues( new Uint8Array( 36 ) ),
		uuid = rnd.reduce( ( arr, n ) => {
			arr.push( ( n % 16 ).toString( 16 ) );
			return arr;
		}, [] );

	uuid[ 14 ] = "4";
	uuid[ 19 ] = ( 8 + rnd[ 19 ] % 4 ).toString( 16 );
	uuid[ 8 ] =
	uuid[ 13 ] =
	uuid[ 18 ] =
	uuid[ 23 ] = "-";
	return uuid.join( "" );
};

Object.freeze( GSUtils );

const gsapiClient = {
	url: "https://squencer.netlify.app/",
	headers: Object.freeze( {
		"Content-Type": "application/json; charset=utf-8",
	} ),

	// store
	// ........................................................................
	user: {},

	// ........................................................................
	getMe() {
		return this._fetch( "GET", "getMe.php" )
			.then( me => this._assignMe( me ) );
	},
	getUser( username ) {
		return this._fetch( "GET", `getUser.php?username=${ username }` )
			.then( ( { data } ) => {
				data.usernameLow = data.username.toLowerCase();
				return data;
			} );
	},
	getUserCompositions( iduser ) {
		return this._fetch( "GET", `getUserCompositions.php?id=${ iduser }` )
			.then( ( { data } ) => {
				data.forEach( cmp => cmp.data = JSON.parse( cmp.data ) );
				return data;
			} );
	},
	getComposition( id ) {
		return this._fetch( "GET", `getComposition.php?id=${ id }` )
			.then( ( { data } ) => {
				data.composition.data = JSON.parse( data.composition.data );
				return data;
			} );
	},
	login( email, pass ) {
		return this._fetch( "POST", "login.php", { email, pass } )
			.then( me => this._assignMe( me ) );
	},
	signup( username, email, pass ) {
		return this._fetch( "POST", "createUser.php", { username, email, pass } )
			.then( me => this._assignMe( me ) );
	},
	resendConfirmationEmail() {
		return this._fetch( "POST", "resendConfirmationEmail.php", { email: this.user.email } );
	},
	recoverPassword( email ) {
		return this._fetch( "POST", "recoverPassword.php", { email } );
	},
	resetPassword( email, code, pass ) {
		return this._fetch( "POST", "resetPassword.php", { email, code, pass } );
	},
	logout() {
		return this._fetch( "POST", "logout.php", { confirm: true } )
			.then( res => this._deleteMe( res ) );
	},
	logoutRefresh() {
		return this.logout()
			.then( () => {
				setTimeout( () => location.href =
					location.origin + location.pathname, 500 );
			} );
	},
	updateMyInfo( obj ) {
		return this._fetch( "POST", "updateMyInfo.php", obj )
			.then( me => this._assignMe( me ) );
	},
	saveComposition( cmp ) {
		return this._fetch( "POST", "saveComposition.php",
			{ composition: JSON.stringify( cmp ) } );
	},
	deleteComposition( id ) {
		return this._fetch( "POST", "deleteComposition.php", { id } );
	},

	// private:
	_assignMe( res ) {
		const u = res.data;

		u.usernameLow = u.username.toLowerCase();
		u.emailpublic = u.emailpublic === "1";
		u.emailchecked = u.emailchecked === "1";
		Object.assign( this.user, u );
		return u;
	},
	_deleteMe( res ) {
		Object.keys( this.user ).forEach( k => delete this.user[ k ] );
		return res;
	},
	_fetch( method, url, body ) {
		const obj = {
			method,
			headers: this.headers,
			credentials: "include",
		};

		if ( body ) {
			obj.body = JSON.stringify( body );
		}
		return fetch( this.url + url, obj )
			.then( res => res.text() ) // 1.
			.then( text => {
				try {
					return JSON.parse( text );
				} catch ( e ) {
					return {
						ok: false,
						code: 500,
						msg: text,
					};
				}
			} )
			.then( res => this._fetchThen( res ) );
	},
	_fetchThen( res ) {
		if ( !res.ok ) {
			res.msg = this.errorCode[ res.msg ] || res.msg;
			throw res; // 2.
		}
		return res;
	},

	// ........................................................................
	errorCode: {
		"user:not-connected": "You are not connected",
		"query:bad-format": "The query is incomplete or corrupted",
		"login:fail": "The email/password don't match",
		"pass:too-short": "The password is too short",
		"email:too-long": "The email is too long",
		"email:not-found": "This email is not in the database",
		"email:duplicate": "This email is already used",
		"email:bad-format": "The email is not correct",
		"email:not-verified": "Your email is not verified",
		"username:too-long": "The username is too long",
		"username:too-short": "The username is too short",
		"username:duplicate": "This username is already taken",
		"username:bad-format": "The username can only contains letters, digits and _",
		"password:bad-code": "Can not change the password because the secret code and the email do not match",
		"password:already-recovering": "A recovering email has already been sent to this address less than 1 day ago",
	},
};

/*
1. Why res.text() instead of res.json() ?
   To handle the case where PHP returns a text error/exception with a default 200 code.

2. Every not-ok queries will throw the result instead of return it, why?
   To handle nicely the errors in the UI side, like:
   query().finally().then( OK, KO )
*/

class DAWCore {
	constructor() {
		const ctx = new AudioContext(),
			wadrumrows = new gswaDrumrows();

		this.cb = {};
		this.env = Object.seal( {
			def_bpm: 120,
			def_appGain: 4,
			def_nbTracks: 21,
			def_stepsPerBeat: 4,
			def_beatsPerMeasure: 4,
			analyserFFTsize: 8192,
			analyserEnable: true,
			clockSteps: false,
		} );
		this.cmps = {
			local: new Map(),
			cloud: new Map(),
		};
		this.ctx = ctx;
		this._wadrumrows = wadrumrows;
		this.drums = new DAWCore.Drums( this );
		this.buffers = new DAWCore.Buffers( this );
		this.history = new DAWCore.History( this );
		this.pianoroll = new DAWCore.Pianoroll( this );
		this.composition = new DAWCore.Composition( this );
		this.destination = new DAWCore.Destination( this );
		this._loop = this._loop.bind( this );
		this._loopMs = 1;
		this._focused = this.composition;
		this._focusedStr = "composition";
		this.get = {
			saveMode: () => this.composition.cmp.options.saveMode,
			currentTime: () => this.composition.currentTime,
			composition: ( saveMode, id ) => this.cmps[ saveMode ].get( id ),
			// .................................................................
			ctx: () => this.ctx,
			audioDestination: () => this.destination.getDestination(),
			audioBuffer: id => this.buffers.getBuffer( this.composition.cmp.buffers[ id ] ).buffer,
			audioChanIn: id => this.composition._wamixer.getChanInput( id ),
			audioChanOut: id => this.composition._wamixer.getChanOutput( id ),
			audioEffect: id => this.composition._waeffects._wafxs.get( id ),
			audioSynth: id => this.composition._synths.get( id ),
			// .................................................................
			cmp: () => this.composition.cmp,
			id: () => this.composition.cmp.id,
			bpm: () => this.composition.cmp.bpm,
			name: () => this.composition.cmp.name,
			loopA: () => this.composition.cmp.loopA,
			loopB: () => this.composition.cmp.loopB,
			duration: () => this.composition.cmp.duration,
			beatsPerMeasure: () => this.composition.cmp.beatsPerMeasure,
			stepsPerBeat: () => this.composition.cmp.stepsPerBeat,
			synthOpened: () => this.composition.cmp.synthOpened,
			patternBufferOpened: () => this.composition.cmp.patternBufferOpened,
			patternDrumsOpened: () => this.composition.cmp.patternDrumsOpened,
			patternKeysOpened: () => this.composition.cmp.patternKeysOpened,
			// .................................................................
			block: id => this.composition.cmp.blocks[ id ],
			blocks: () => this.composition.cmp.blocks,
			buffer: id => this.composition.cmp.buffers[ id ],
			buffers: () => this.composition.cmp.buffers,
			channel: id => this.composition.cmp.channels[ id ],
			channels: () => this.composition.cmp.channels,
			drumrow: id => this.composition.cmp.drumrows[ id ],
			drumrows: () => this.composition.cmp.drumrows,
			drums: id => id ? this.composition.cmp.drums[ id ] : this.composition.cmp.drums, // 1.
			effect: id => this.composition.cmp.effects[ id ],
			effects: () => this.composition.cmp.effects,
			keys: id => id ? this.composition.cmp.keys[ id ] : this.composition.cmp.keys, // 1.
			pattern: id => this.composition.cmp.patterns[ id ],
			patterns: () => this.composition.cmp.patterns,
			synth: id => this.composition.cmp.synths[ id ],
			synths: () => this.composition.cmp.synths,
			track: id => this.composition.cmp.tracks[ id ],
			tracks: () => this.composition.cmp.tracks,
		};

		wadrumrows.getAudioBuffer = this.get.audioBuffer;
		wadrumrows.getChannelInput = this.get.audioChanIn;
		wadrumrows.onstartdrum = rowId => this._call( "onstartdrum", rowId );
		wadrumrows.onstartdrumcut = rowId => this._call( "onstopdrumrow", rowId );
		this.setLoopRate( 60 );
		this.setCtx( ctx );
		this.destination.setGain( this.env.def_appGain );
	}

	setCtx( ctx ) {
		this.ctx = ctx;
		this._wadrumrows.setContext( ctx );
		this.destination.setCtx( ctx );
		this.composition.setCtx( ctx );
	}
	envChange( obj ) {
		Object.assign( this.env, obj );
		if ( "clockSteps" in obj ) {
			this._clockUpdate();
		}
	}
	callAction( action, ...args ) {
		const fn = DAWCore.actions[ action ];

		if ( !fn ) {
			console.error( `DAWCore: undefined action "${ action }"` );
		} else {
			const ret = GSUtils.deepFreeze( fn( ...args, this.get ) );

			if ( Array.isArray( ret ) ) {
				this.history.stackChange( ...ret );
			} else if ( ret ) {
				const undo = GSUtils.composeUndo( this.get.cmp(), ret );

				this.composition.change( ret, undo );
			}
		}
	}
	compositionNeedSave() {
		return !this.composition._saved;
	}
	getFocusedObject() {
		return this._focused;
	}
	getFocusedName() {
		return this._focusedStr;
	}
	compositionFocus( force ) {
		if ( this._focused !== this.composition ) {
			this._focusOn( "composition", force );
		}
	}
	pianorollFocus( force ) {
		if ( this._focused !== this.pianoroll && this.get.patternKeysOpened() ) {
			this._focusOn( "pianoroll", force );
		}
	}
	drumsFocus( force ) {
		if ( this._focused !== this.drums && this.get.patternDrumsOpened() ) {
			this._focusOn( "drums", force );
		}
	}
	isPlaying() {
		return this.composition.playing || this.pianoroll.playing || this.drums.playing;
	}
	togglePlay() {
		this.isPlaying() ? this.pause() : this.play();
	}
	play() {
		this._focused.play();
		this._call( "play", this._focusedStr );
	}
	pause() {
		this._focused.pause();
		this._call( "pause", this._focusedStr );
		this._clockUpdate();
	}
	stop() {
		this._focused.stop();
		this._call( "stop", this._focusedStr );
		this._call( "currentTime", this._focused.getCurrentTime(), this._focusedStr );
		this._clockUpdate();
	}
	setLoopRate( fps ) {
		this._loopMs = 1000 / fps | 0;
	}

	// private:
	// .........................................................................
	_startLoop() {
		this._clockUpdate();
		this._loop();
	}
	_stopLoop() {
		clearTimeout( this._frameId );
		cancelAnimationFrame( this._frameId );
	}
	_loop() {
		const anData = this.destination.analyserFillData();

		if ( anData ) {
			this.composition.updateChanAudioData();
			this._call( "analyserFilled", anData );
		}
		if ( this.isPlaying() ) {
			const beat = this._focused.getCurrentTime();

			this._call( "currentTime", beat, this._focusedStr );
			this._clockUpdate();
		}
		this._frameId = this._loopMs < 20
			? requestAnimationFrame( this._loop )
			: setTimeout( this._loop, this._loopMs );
	}
	_clockUpdate() {
		this._call( "clockUpdate", this._focused.getCurrentTime() );
	}
	_focusOn( focusedStr, force ) {
		if ( force === "-f" || !this.isPlaying() ) {
			this.pause();
			this._focused = this[ focusedStr ];
			this._focusedStr = focusedStr;
			this._call( "focusOn", "composition", focusedStr === "composition" );
			this._call( "focusOn", "pianoroll", focusedStr === "pianoroll" );
			this._call( "focusOn", "drums", focusedStr === "drums" );
			this._clockUpdate();
		}
	}
	_call( cbName, ...args ) {
		const fn = this.cb[ cbName ];

		return fn && fn( ...args );
	}
}

DAWCore.json = { effects: {} };
DAWCore.utils = {};
DAWCore.common = {};
DAWCore.actions = {};
DAWCore.controllers = {};
DAWCore.controllersFx = {};

/*
1. The getter 'keys' and 'drums' can't use their singular form like the others getters
   because 'key' and 'drum' are refering to the objects contained in ONE 'keys' or 'drums'.
   So `keys[0]` is a 'keys' not a 'key', a 'key' would be `keys[0][0]`.
*/

DAWCore.Buffers = class {
	constructor( daw ) {
		this.daw = daw;
		this._files = new Map();
	}

	empty() {
		this._files.clear();
	}
	getBuffer( buf ) {
		return this._files.get( buf.hash || buf.url );
	}
	getSize() {
		return this._files.size;
	}
	setBuffer( obj ) {
		const buf = { ...obj },
			url = buf.url,
			key = buf.hash || url;

		this._files.set( key, buf );
		return !url
			? Promise.resolve( buf )
			: fetch( `../assets/samples/${ url }` )
				.then( res => res.arrayBuffer() )
				.then( arr => this.daw.ctx.decodeAudioData( arr ) )
				.then( buffer => {
					buf.buffer = buffer;
					buf.duration = +buffer.duration.toFixed( 4 );
					return buf;
				} );
	}
	loadFiles( files ) {
		return new Promise( res => {
			const newBuffers = [],
				knownBuffers = [],
				failedBuffers = [];
			let nbDone = 0;

			Array.from( files ).forEach( file => {
				this._getBufferFromFile( file )
					.then( ( [ hash, buffer ] ) => {
						const buf = {
								hash,
								buffer,
								type: file.type,
								name: file.name,
								duration: +buffer.duration.toFixed( 4 ),
							},
							old = this.getBuffer( buf );

						if ( !old ) {
							newBuffers.push( buf );
						} else if ( !old.buffer ) {
							knownBuffers.push( buf );
						}
					}, () => {
						failedBuffers.push( {
							type: file.type,
							name: file.name,
						} );
					} )
					.finally( () => {
						if ( ++nbDone === files.length ) {
							newBuffers.forEach( this.setBuffer, this );
							knownBuffers.forEach( this.setBuffer, this );
							res( { newBuffers, knownBuffers, failedBuffers } );
						}
					} );
			} );
		} );
	}

	// private:
	_getBufferFromFile( file ) {
		return new Promise( ( res, rej ) => {
			const reader = new FileReader();

			reader.onload = e => {
				const buf = e.target.result,
					hash = this._hashBuffer_v1( new Uint8Array( buf ) ); // 1.

				this.daw.ctx.decodeAudioData( buf ).then( audiobuf => {
					res( [ hash, audiobuf ] );
				}, rej );
			};
			reader.readAsArrayBuffer( file );
		} );
	}
	_hashBuffer_v1( u8buf ) {
		const hash = new Uint8Array( 19 ),
			len = `${ u8buf.length }`.padStart( 9, "0" );
		let i = 0,
			ind = 0;

		for ( const u8 of u8buf ) {
			hash[ ind ] += u8;
			if ( ++ind >= 19 ) {
				ind = 0;
			}
			if ( ++i >= 1000000 ) {
				break;
			}
		}
		return `1-${ len }-${ Array.from( hash )
			.map( u8 => u8.toString( 16 ).padStart( 2, "0" ) )
			.join( "" ) }`;
	}
};

/*
1. the hash is calculed before the data decoded
   to bypass the "neutered ArrayBuffer" error.
*/

DAWCore.LocalStorage = Object.freeze( {
	put( id, cmp ) {
		const cpy = GSUtils.jsonCopy( cmp );

		DAWCore.Composition.epure( cpy );
		localStorage.setItem( id, JSON.stringify( cpy ) );
	},
	delete( id ) {
		localStorage.removeItem( id );
	},
	has( id ) {
		return id in localStorage;
	},
	get( id ) {
		try {
			const cmp = JSON.parse( localStorage.getItem( id ) );

			return id === cmp.id ? cmp : null;
		} catch ( e ) {
			return null;
		}
	},
	getAll() {
		const cmps = Object.keys( localStorage )
				.reduce( ( arr, id ) => {
					const cmp = this.get( id );

					cmp && arr.push( cmp );
					return arr;
				}, [] );

		cmps.sort( ( a, b ) => a.savedAt < b.savedAt );
		return cmps;
	},
} );

DAWCore.Destination = class {
	constructor( daw ) {
		this.daw = daw;
		this._gain = 1;
		this.empty();
	}

	getDestination() {
		return this._inputNode;
	}
	getGain() {
		return this._gain;
	}
	setGain( v ) {
		this._gain = v;
		this._gainNode.gain.value = v * v;
	}
	empty() {
		this._gainNode && this._gainNode.disconnect();
		this._inputNode && this._inputNode.disconnect();
		this._analyserNode && this._analyserNode.disconnect();
		this._gainNode =
		this._inputNode =
		this._analyserNode =
		this._analyserData = null;
	}
	setCtx( ctx ) {
		const offline = ctx instanceof OfflineAudioContext;

		this.empty();
		this.ctx = ctx;
		this._inputNode = ctx.createGain();
		this._gainNode = ctx.createGain();
		this._gainNode.connect( ctx.destination );
		this._inputNode.connect( this._gainNode );
		this.toggleAnalyser( !offline && this.daw.env.analyserEnable );
	}
	analyserFillData() {
		if ( this._analyserNode ) {
			this._analyserNode.getByteFrequencyData( this._analyserData );
			return this._analyserData;
		}
	}
	toggleAnalyser( b ) {
		if ( this._analyserNode ) {
			this._analyserNode.disconnect();
		}
		if ( b ) {
			const an = this.ctx.createAnalyser(),
				fftSize = this.daw.env.analyserFFTsize;

			this._analyserNode = an;
			this._analyserData = new Uint8Array( fftSize / 2 );
			an.fftSize = fftSize;
			an.smoothingTimeConstant = 0;
			an.connect( this._gainNode );
			this._inputNode.connect( an );
		} else {
			this._analyserNode =
			this._analyserData = null;
			this._inputNode.connect( this._gainNode );
		}
	}
};

DAWCore.History = class {
	constructor( daw ) {
		this.daw = daw;
		this._stack = [];
		this._stackInd = 0;
		this._stackCue = -1;
	}

	empty() {
		const stack = this._stack;

		while ( stack.length ) {
			this.daw._call( "historyDeleteAction", stack.pop() );
		}
		this._stackInd = 0;
	}
	stackChange( redo, msg ) {
		const stack = this._stack,
			undo = GSUtils.composeUndo( this.daw.composition.cmp, redo ),
			act = { redo, undo },
			desc = this.nameAction( act, msg );

		act.desc = desc.t;
		act.icon = desc.i;
		while ( stack.length > this._stackInd ) {
			this.daw._call( "historyDeleteAction", stack.pop() );
		}
		++this._stackInd;
		act.index = stack.push( act );
		this._change( Object.freeze( act ), "redo", "historyAddAction" );
	}
	getCurrentAction() {
		return this._stack[ this._stackInd - 1 ] || null;
	}
	goToAction( act ) {
		let n = act.index - this._stackInd;

		     if ( n < 0 ) { while ( n++ < 0 ) { this.undo(); } }
		else if ( n > 0 ) { while ( n-- > 0 ) { this.redo(); } }
		return false;
	}
	undo() {
		return this._stackInd > 0
			? this._change( this._stack[ --this._stackInd ], "undo", "historyUndo" )
			: false;
	}
	redo() {
		return this._stackInd < this._stack.length
			? this._change( this._stack[ this._stackInd++ ], "redo", "historyRedo" )
			: false;
	}

	// private:
	_change( act, undoredo, cbStr ) {
		const obj = act[ undoredo ],
			prevObj = undoredo === "undo" ? act.redo : act.undo;

		this.daw._call( cbStr, act );
		this.daw.composition.change( obj, prevObj );
		return obj;
	}
};

DAWCore.History.prototype.nameAction = function( act, msg ) {
	const [ part, actionName, ...args ] = msg || [],
		fn = DAWCore.History.actionsToText[ part ]?.[ actionName ],
		[ i, t ] = fn ? fn( ...args ) : [ "close", "undefined" ];

	if ( !fn ) {
		console.error( `DAWCore: description 404 for "${ part }.${ actionName }"` );
	}
	return { i, t };
};

DAWCore.History.actionsToText = {
	cmp: {
		renameComposition: ( old, neww ) => [ "pen", `rename compo "${ old || "untitled" }" to "${ neww }"` ],
		changeTempo: ( bpm, bPM, sPB ) => [ "clock", `new tempo ${ bpm } (${ bPM }/${ sPB })` ],
		changeLoop: ( a, b ) => [ "loop", `change loop ${ a } -> ${ b }` ],
		removeLoop: () => [ "loop", "remove loop" ],
	},
	tracks: {
		renameTrack: ( old, neww ) => [ "pen", `rename track "${ old }" -> "${ neww }"` ],
		toggleTrack: ( tr, b ) => [ b ? "unmute" : "mute", `${ b ? "unmute" : "mute" } track "${ tr }"` ],
		toggleSoloTrack: ( tr, b ) => [ b ? "unmute" : "mute", `${ b ? "unmute all tracks" : `mute all tracks except "${ tr }"` }` ],
	},
	blocks: {
		addBlock: pat => [ "plus", `add a new ${ pat } block` ],
		moveBlocks: len => [ "arrows", `move ${ GSUtils.plural( len, "block" ) }` ],
		selectBlocks: len => [ "mouse", `select ${ GSUtils.plural( len, "block" ) }` ],
		removeBlocks: len => [ "erase", `remove ${ GSUtils.plural( len, "block" ) }` ],
		cropEndBlocks: len => [ "crop", `crop-end ${ GSUtils.plural( len, "block" ) }` ],
		cropStartBlocks: len => [ "crop", `crop-start ${ GSUtils.plural( len, "block" ) }` ],
		unselectBlock: () => [ "mouse", `unselect ${ GSUtils.plural( 1, "block" ) }` ],
		unselectAllBlocks: len => [ "mouse", `unselect ${ GSUtils.plural( len, "block" ) }` ],
		duplicateSelectedBlocks: len => [ "plus", `duplicate ${ GSUtils.plural( len, "block" ) }` ],
	},
	synth: {
		addOscillator: syn => [ "oscillator", `${ syn }: add osc` ],
		removeOscillator: syn => [ "oscillator", `${ syn }: remove osc` ],
		reorderOscillator: syn => [ "sort", `${ syn }: reorder oscs` ],
		changeOscillator: ( syn, prop, val ) => [ "oscillator", `${ syn }: change osc ${ prop } -> ${ val }` ],
		toggleEnv: ( syn, b ) => [ "osc-sine", `${ syn }: ${ b ? "enable" : "disable" } envelope` ],
		changeEnv: ( syn, prop, val ) => [ "osc-sine", `${ syn }: envelope's ${ prop } = ${ val }` ],
		toggleLFO: ( syn, b ) => [ "osc-sine", `${ syn }: ${ b ? "enable" : "disable" } LFO` ],
		changeLFO: ( syn, prop, val ) => [ "osc-sine", `${ syn }: LFO's ${ prop } = ${ val }` ],
	},
	synths: {
		addSynth: syn => [ "oscillator", `add new synth "${ syn }"` ],
		renameSynth: ( old, neww ) => [ "pen", `rename synth "${ old }" -> "${ neww }"` ],
		removeSynth: syn => [ "minus", `remove synth "${ syn }"` ],
		redirectSynth: ( syn, chanDest ) => [ "redirect", `redirect synth "${ syn }" to chan "${ chanDest }"` ],
	},
	channels: {
		addChannel: chan => [ "plus", `mixer: new channel "${ chan }"`, ],
		removeChannel: chan => [ "minus", `mixer: remove "${ chan }"`, ],
		reorderChannel: chan => [ "sort", `mixer: reorder "${ chan }"`, ],
		renameChannel: ( old, neww ) => [ "pen", `mixer: rename "${ old }" -> "${ neww }"` ],
		toggleChannel: ( chan, b ) => [ b ? "unmute" : "mute", `mixer: ${ b ? "unmute" : "mute" } "${ chan }"`, ],
		changeChannel: ( chan, prop, val ) => [ "mixer", `mixer: "${ chan }" ${ prop }: ${ val }`, ],
		redirectChannel: ( chan, chanDest ) => [ "redirect", `mixer: redirect "${ chan }" to "${ chanDest }"`, ],
	},
	patterns: {
		addPattern: ( type, pat ) => [ "plus", `add new ${ type } "${ pat }"` ],
		addPatternKeys: ( pat, syn ) => [ "plus", `add new keys "${ pat }" of synth "${ syn }"` ],
		renamePattern: ( type, old, neww ) => [ "pen", `rename ${ type } "${ old }" -> "${ neww }"` ],
		removePattern: ( type, pat ) => [ "minus", `remove ${ type } "${ pat }"` ],
		reorderPattern: ( type, pat ) => [ "sort", `reorder ${ type } "${ pat }"` ],
		clonePattern: ( type, pat, patSrc ) => [ "clone", `clone ${ type } "${ patSrc }" to "${ pat }"` ],
		redirectPatternBuffer: ( pat, chanDest ) => [ "redirect", `redirect buffer "${ pat }" to chan "${ chanDest }"` ],
		redirectPatternKeys: ( pat, syn ) => [ "redirect", `redirect keys "${ pat }" to synth "${ syn }"` ],
	},
	effects: {
		addEffect: ( dest, type ) => [ "effects", `fx: new ${ type } on ${ dest }`, ],
		toggleEffect: ( dest, type, b ) => [ b ? "unmute" : "mute", `fx: ${ b ? "unmute" : "mute" } ${ type } of ${ dest }`, ],
		removeEffect: ( dest, type ) => [ "minus", `fx: remove ${ type } of ${ dest }`, ],
		changeEffect: ( dest, type, prop ) => [ "effects", `fx: change ${ type }'s ${ prop } of ${ dest }` ],
	},
	drumrows: {
		addDrumrow: row => [ "drums", `drumrows: new "${ row }"` ],
		removeDrumrow: row => [ "drums", `drumrows: remove "${ row }"` ],
		reorderDrumrow: row => [ "drums", `drumrows: reorder "${ row }"` ],
		changeDrumrow: ( row, prop, val ) => [ "drums", `drumrows: "${ row }" ${ prop }: ${ val }` ],
		changeDrumrowPattern: ( row, newPat ) => [ "drums", `drumrows: "${ row }" -> "${ newPat }"` ],
		toggleDrumrow: ( row, b ) => [ "drums", `drumrows: ${ b ? "unmute" : "mute" } "${ row }"` ],
		toggleSoloDrumrow: ( row, b ) => [ "drums", `drumrows: ${ b ? "unmute all" : `mute all except "${ row }"` }` ],
	},
	drums: {
		addDrums: ( pat, row, nb ) => [ "drums", `drums: add ${ nb } "${ row }" in "${ pat }"` ],
		removeDrums: ( pat, row, nb ) => [ "drums", `drums: remove ${ nb } "${ row }" in "${ pat }"` ],
		changeDrumsProps: ( pat, row, prop, nb ) => [ "drums", `drums: set ${ prop } to ${ nb } "${ row }" in "${ pat }"` ],
	},
	keys: {
		addKey: pat => [ "keys", `add a new key in "${ pat }"` ],
		moveKeys: ( pat, len ) => [ "arrows", `keys: move ${ GSUtils.plural( len, "key" ) } in "${ pat }"` ],
		removeKeys: ( pat, len ) => [ "erase", `keys: remove ${ GSUtils.plural( len, "key" ) } in "${ pat }"` ],
		selectKeys: ( pat, len ) => [ "mouse", `keys: select ${ GSUtils.plural( len, "key" ) } in "${ pat }"` ],
		cropEndKeys: ( pat, len ) => [ "crop", `keys: crop ${ GSUtils.plural( len, "key" ) } in "${ pat }"` ],
		redirectKey: ( pat, b ) => [ "glissando", `${ b ? "add" : "remove" } a glissando in "${ pat }"` ],
		unselectKey: pat => [ "mouse", `keys: unselect ${ GSUtils.plural( 1, "key" ) } in "${ pat }"` ],
		unselectAllKeys: ( pat, len ) => [ "mouse", `unselect ${ GSUtils.plural( len, "key" ) } in "${ pat }"` ],
		changeKeysEnv: ( pat, len, prop ) => [ "keys", `keys: change ${ GSUtils.plural( len, "key", "'s" ) } ${ prop } in "${ pat }"` ],
		changeKeysProps: ( pat, prop, len ) => [ "keys", `keys: change ${ GSUtils.plural( len, "key", "'s" ) } ${ prop } in "${ pat }"` ],
		cloneSelectedKeys: ( pat, len ) => [ "keys", `clone ${ GSUtils.plural( len, "key" ) } in "${ pat }"` ],
	},
};

DAWCore.Drums = class {
	constructor( daw ) {
		const waDrums = new gswaDrumsScheduler( daw.ctx );

		this.daw = daw;
		this.looping =
		this.playing = true;
		this.loopA =
		this.loopB = null;
		this.duration = 0;
		this._ctx = daw.ctx;
		this._waDrums = waDrums;
		Object.seal( this );

		waDrums.setDrumrows( daw._wadrumrows );
	}

	change( patObj, drumsObj ) {
		if ( drumsObj ) {
			this._waDrums.change( drumsObj );
		}
		if ( patObj && "duration" in patObj ) {
			this.duration = patObj.duration;
			if ( !this.looping && this.playing ) {
				this._waDrums.scheduler.setLoopBeat( 0, this.duration );
			}
		}
	}
	openPattern( id ) {
		const daw = this.daw,
			wasPlaying = this.playing;

		id ? daw.drumsFocus()
			: daw.compositionFocus( "-f" );
		if ( wasPlaying ) {
			daw.stop();
			daw.stop();
		}
		this._waDrums.scheduler.empty();
		if ( id ) {
			const pat = daw.get.pattern( id );

			this.change( pat, daw.get.drums( pat.drums ) );
			if ( wasPlaying ) {
				daw.play();
			}
		}
	}

	// controls
	// .........................................................................
	getCurrentTime() {
		return this._waDrums.scheduler.getCurrentOffsetBeat();
	}
	setCurrentTime( t ) {
		this._waDrums.scheduler.setCurrentOffsetBeat( t );
		this.daw._call( "currentTime", this.getCurrentTime(), "drums" );
		this.daw._clockUpdate();
	}
	setBPM( bpm ) {
		this._waDrums.scheduler.setBPM( bpm );
	}
	setLoop( a, b ) {
		this.loopA = a;
		this.loopB = b;
		this.looping = true;
		this._waDrums.scheduler.setLoopBeat( a, b );
	}
	clearLoop() {
		this.loopA =
		this.loopB = null;
		this.looping = false;
		this._waDrums.scheduler.setLoopBeat( 0, this.duration || this.daw.get.beatsPerMeasure() );
	}
	changeLiveDrumrow( rowId, prop, val ) {
		this.daw._wadrumrows.change( { drumrows: { [ rowId ]: { [ prop ]: val } } } );
	}
	startLiveDrum( rowId ) {
		this.daw._wadrumrows.startLiveDrum( rowId );
	}
	stopLiveDrum( rowId ) {
		this.daw._wadrumrows.stopLiveDrum( rowId );
		this.daw._call( "onstopdrumrow", rowId );
	}
	play() {
		if ( !this.playing ) {
			const a = this.looping ? this.loopA : 0,
				b = this.looping ? this.loopB : this.duration;

			this.playing = true;
			this._waDrums.scheduler.setLoopBeat( a, b );
			this._waDrums.scheduler.startBeat( 0, this.getCurrentTime() );
		}
	}
	pause() {
		if ( this.playing ) {
			this.playing = false;
			this._waDrums.stop();
		}
	}
	stop() {
		if ( this.playing ) {
			this.pause();
			this.setCurrentTime( this.loopA || 0 );
		} else {
			this.setCurrentTime( 0 );
		}
	}
};

DAWCore.Pianoroll = class {
	constructor( daw ) {
		const waKeys = new gswaKeysScheduler( daw.ctx );

		this.daw = daw;
		this.keys = {};
		this.looping =
		this.playing = false;
		this._synth =
		this.loopA =
		this.loopB = null;
		this.duration = 0;
		this._ctx = daw.ctx;
		this._waKeys = waKeys;
		this._keysStartedLive = {};
	}

	change( patObj, keysObj ) {
		this._waKeys.change( keysObj );
		if ( patObj && "duration" in patObj ) {
			this.duration = patObj.duration;
			if ( !this.looping && this.playing ) {
				this._waKeys.scheduler.setLoopBeat( 0, this.duration );
			}
		}
	}
	setSynth( id ) {
		const syn = id ? this.daw.get.audioSynth( id ) : null,
			wasPlaying = this.playing;

		if ( syn !== this._synth ) {
			if ( wasPlaying ) {
				this.pause();
			}
			this._synth = syn;
			this._waKeys.setSynth( syn );
			if ( wasPlaying ) {
				this.play();
			}
		}
	}
	openPattern( id ) {
		const daw = this.daw,
			wasPlaying = this.playing;

		id ? daw.pianorollFocus()
			: daw.compositionFocus( "-f" );
		if ( wasPlaying ) {
			daw.stop();
			daw.stop();
		}
		this._waKeys.scheduler.empty();
		if ( id ) {
			const pat = daw.get.pattern( id );

			this.setSynth( pat.synth );
			this.change( pat, daw.get.keys( pat.keys ) );
			if ( wasPlaying ) {
				daw.play();
			}
		}
	}

	// controls
	// ........................................................................
	getCurrentTime() {
		return this._waKeys.scheduler.getCurrentOffsetBeat();
	}
	setCurrentTime( t ) {
		this._waKeys.scheduler.setCurrentOffsetBeat( t );
		this.daw._call( "currentTime", this.getCurrentTime(), "pianoroll" );
		this.daw._clockUpdate();
	}
	setBPM( bpm ) {
		this._waKeys.scheduler.setBPM( bpm );
	}
	setLoop( a, b ) {
		this.loopA = a;
		this.loopB = b;
		this.looping = true;
		this._waKeys.scheduler.setLoopBeat( a, b );
	}
	clearLoop() {
		this.loopA =
		this.loopB = null;
		this.looping = false;
		this._waKeys.scheduler.setLoopBeat( 0, this.duration || this.daw.get.beatsPerMeasure() );
	}
	liveKeydown( midi ) {
		if ( !( midi in this._keysStartedLive ) ) {
			this._keysStartedLive[ midi ] = this._synth.startKey( [ [ null, {
				key: midi,
				pan: 0,
				gain: .8,
				lowpass: 1,
				highpass: 1,
			} ] ], this._waKeys.scheduler.currentTime(), 0, Infinity );
		}
	}
	liveKeyup( midi ) {
		if ( this._keysStartedLive[ midi ] ) {
			this._synth.stopKey( this._keysStartedLive[ midi ] );
			delete this._keysStartedLive[ midi ];
		}
	}
	play() {
		if ( !this.playing ) {
			const a = this.looping ? this.loopA : 0,
				b = this.looping ? this.loopB : this.duration;

			this.playing = true;
			this._waKeys.scheduler.setLoopBeat( a, b );
			this._waKeys.scheduler.startBeat( 0, this.getCurrentTime() );
		}
	}
	pause() {
		if ( this.playing ) {
			this.playing = false;
			this._waKeys.stop();
		}
	}
	stop() {
		if ( this.playing ) {
			this.pause();
			this.setCurrentTime( this.loopA || 0 );
		} else {
			this.setCurrentTime( 0 );
		}
	}
};

DAWCore.Composition = class {
	constructor( daw ) {
		const sch = new gswaScheduler(),
			wamix = new gswaMixer(),
			wafxs = new gswaEffects( {
				getChanInput: wamix.getChanInput.bind( wamix ),
				getChanOutput: wamix.getChanOutput.bind( wamix ),
			} );

		this.daw = daw;
		this.cmp = null;
		this.loaded =
		this.playing = false;
		this._saved = true;
		this._sched = sch;
		this._wamixer = wamix;
		this._waeffects = wafxs;
		this._synths = new Map();
		this._startedSched = new Map();
		this._startedBuffers = new Map();
		this._actionSavedOn = null;
		sch.currentTime = () => this.ctx.currentTime;
		sch.ondatastart = this._onstartBlock.bind( this );
		sch.ondatastop = this._onstopBlock.bind( this );
	}

	// un/load, change, save
	// .........................................................................
	setCtx( ctx ) {
		gswaPeriodicWaves.clearCache();
		this.ctx = ctx;
		this._wamixer.setContext( ctx ); // 1.
		this._wamixer.connect( this.daw.get.audioDestination() );
		this._waeffects.setContext( ctx );
		this._synths.forEach( ( syn, synId ) => {
			syn.setContext( ctx );
			syn.output.disconnect();
			syn.output.connect( this.daw.get.audioChanIn( this.cmp.synths[ synId ].dest ) );
		} );
	}
	load( cmpOri ) {
		return new Promise( ( res, rej ) => {
			const cmp = GSUtils.jsonCopy( cmpOri );

			if ( DAWCore.Composition.format( cmp ) ) {
				this.unload();
				res( cmp );
			} else {
				rej();
			}
		} ).then( cmp => {
			this.cmp = cmp;
			this.loaded = true;
			Object.entries( cmp.buffers ).forEach( kv => {
				this.daw.buffers.setBuffer( kv[ 1 ] )
					.then( buf => {
						if ( buf.buffer ) {
							this.daw._call( "buffersLoaded", { [ kv[ 0 ] ]: buf } );
						}
					} );
			} );
			this.change( cmp, {
				keys: {},
				drums: {},
				synths: {},
				blocks: {},
				buffers: {},
				drumrows: {},
				channels: {},
				patterns: {},
			} );
			this._actionSavedOn = null;
			this._saved = cmp.options.saveMode === "cloud" ||
				DAWCore.LocalStorage.has( cmp.id ) || !cmp.savedAt;
			this.daw._call( "compositionSavedStatus", cmp, this._saved );
			return cmp;
		} );
	}
	unload() {
		if ( this.loaded ) {
			const d = this._sched.data;

			this.loaded = false;
			this._waeffects.clear(); // 1.
			this._wamixer.clear();
			this._sched.stop();
			Object.keys( d ).forEach( id => delete d[ id ] );
			this._synths.clear();
			this.daw._wadrumrows.clear();
			this._saved = true;
			this.daw._call( "compositionSavedStatus", this.cmp, true );
			this.cmp = null;
		}
	}
	save() {
		if ( !this._saved ) {
			this._saved = true;
			this._actionSavedOn = this.daw.history.getCurrentAction();
			this.cmp.savedAt = Math.floor( Date.now() / 1000 );
			return true;
		}
	}
	updateChanAudioData() {
		const mix = this._wamixer,
			fn = this.daw._call.bind( this.daw, "channelAnalyserFilled" );

		Object.keys( this.daw.get.channels() ).forEach( chanId => {
			mix.fillAudioData( chanId );
			fn( chanId, mix.audioDataL, mix.audioDataR );
		} );
	}

	// controls
	// .........................................................................
	getCurrentTime() {
		return this._sched.getCurrentOffsetBeat();
	}
	setCurrentTime( t ) {
		this._sched.setCurrentOffsetBeat( t );
		this.daw._call( "currentTime", this.getCurrentTime(), "composition" );
		this.daw._clockUpdate();
	}
	play() {
		if ( !this.playing ) {
			this.playing = true;
			this._start( this.getCurrentTime() );
		}
	}
	pause() {
		if ( this.playing ) {
			this.playing = false;
			this._sched.stop();
		}
	}
	stop() {
		if ( this.playing ) {
			this.pause();
			this.setCurrentTime( this.cmp.loopA || 0 );
		} else {
			this.setCurrentTime( 0 );
		}
	}

	// .........................................................................
	_setLoop( a, b ) {
		if ( Number.isFinite( a ) ) {
			this._sched.setLoopBeat( a, b );
		} else {
			this._sched.setLoopBeat( 0, this.cmp.duration || this.cmp.beatsPerMeasure );
		}
	}
	_start( offset ) {
		const sch = this._sched;

		if ( this.ctx instanceof OfflineAudioContext ) {
			sch.clearLoop();
			sch.enableStreaming( false );
			sch.startBeat( 0 );
		} else {
			this._setLoop( this.cmp.loopA, this.cmp.loopB );
			sch.enableStreaming( true );
			sch.startBeat( 0, offset );
		}
	}

	// .........................................................................
	assignPatternChange( patId, obj ) {
		this._startedSched.forEach( ( [ patId2, sched ] ) => {
			if ( patId2 === patId ) {
				sched.change( obj );
			}
		} );
	}
	redirectPatternBuffer( patId, chanId ) {
		this._startedBuffers.forEach( ( [ patId2, absn ] ) => {
			if ( patId2 === patId ) {
				absn.disconnect();
				absn.connect( this.daw.get.audioChanIn( chanId ) );
			}
		} );
	}

	// .........................................................................
	_onstartBlock( startedId, blcs, when, off, dur ) {
		const cmp = this.cmp,
			blc = blcs[ 0 ][ 1 ];

		if ( cmp.tracks[ blc.track ].toggle ) {
			const patId = blc.pattern,
				pat = cmp.patterns[ patId ];

			switch ( pat.type ) {
				case "buffer": {
					const buf = this.daw.get.audioBuffer( pat.buffer );

					if ( buf ) {
						const absn = this.ctx.createBufferSource();

						absn.buffer = buf;
						absn.connect( this.daw.get.audioChanIn( pat.dest ) );
						absn.start( when, off, dur );
						this._startedBuffers.set( startedId, [ patId, absn ] );
					}
				} break;
				case "keys": {
					const waKeys = new gswaKeysScheduler( this.ctx );

					this._startedSched.set( startedId, [ patId, waKeys ] );
					waKeys.scheduler.setBPM( cmp.bpm );
					waKeys.setSynth( this.daw.get.audioSynth( pat.synth ) );
					waKeys.change( cmp.keys[ pat.keys ] );
					waKeys.start( when, off, dur );
				} break;
				case "drums": {
					const waDrums = new gswaDrumsScheduler( this.ctx );

					this._startedSched.set( startedId, [ patId, waDrums ] );
					waDrums.scheduler.setBPM( cmp.bpm );
					waDrums.setDrumrows( this.daw._wadrumrows );
					waDrums.change( cmp.drums[ pat.drums ] );
					waDrums.start( when, off, dur );
				} break;
			}
		}
	}
	_onstopBlock( startedId ) {
		const objStarted =
				this._startedSched.get( startedId ) ||
				this._startedBuffers.get( startedId );

		if ( objStarted ) {
			objStarted[ 1 ].stop();
			this._startedSched.delete( startedId );
			this._startedBuffers.delete( startedId );
		}
	}
};

/*
1. The order between the mixer and the effects is important.
*/

DAWCore.Composition.epure = function( cmp ) {
	delete cmp.options;
	if ( cmp.loopA == null || cmp.loopB == null ) {
		delete cmp.loopA;
		delete cmp.loopB;
	}
	Object.values( cmp.drumrows ).forEach( row => {
		if ( row.toggle ) { delete row.toggle; }
	} );
	Object.values( cmp.tracks ).forEach( tr => {
		if ( !tr.name ) { delete tr.name; }
		if ( tr.toggle ) { delete tr.toggle; }
	} );
	Object.values( cmp.blocks ).forEach( blc => {
		if ( !blc.offset ) { delete blc.offset; }
		if ( !blc.selected ) { delete blc.selected; }
		if ( !blc.durationEdited ) { delete blc.durationEdited; }
	} );
	Object.values( cmp.keys ).forEach( keys => {
		Object.values( keys ).forEach( key => {
			if ( !key.offset ) { delete key.offset; }
			if ( !key.selected ) { delete key.selected; }
			if ( key.prev == null ) { delete key.prev; }
			if ( key.next == null ) { delete key.next; }
		} );
	} );
	return cmp;
};

DAWCore.Composition.format = function( cmp ) {
	const blcsValues = Object.values( cmp.blocks );
	let orderDefault = 0;

	// loopA/B
	// ..........................................
	if ( Number.isFinite( cmp.loopA ) && Number.isFinite( cmp.loopB ) ) {
		cmp.loopA = Math.max( 0, cmp.loopA );
		cmp.loopB = Math.max( 0, cmp.loopB );
		if ( cmp.loopA === cmp.loopB ) {
			cmp.loopA =
			cmp.loopB = null;
		}
	} else {
		cmp.loopA =
		cmp.loopB = null;
	}

	// ***Opened
	// ..........................................
	cmp.synthOpened = cmp.synthOpened ? `${ cmp.synthOpened }` : null;
	cmp.patternKeysOpened = cmp.patternKeysOpened ? `${ cmp.patternKeysOpened }` : null;
	cmp.patternBufferOpened = cmp.patternBufferOpened ? `${ cmp.patternBufferOpened }` : null;
	delete cmp.patternOpened;

	// buffers
	// ..........................................
	cmp.buffers = cmp.buffers || {};

	// drumrows
	// ..........................................
	cmp.drumrows = cmp.drumrows || {};
	Object.values( cmp.drumrows ).forEach( row => {
		row.toggle = row.toggle !== false;
		row.detune = row.detune ?? 0;
	} );

	// drums
	// ..........................................
	cmp.drums = cmp.drums || {};
	Object.values( cmp.drums ).forEach( drums => {
		Object.values( drums ).forEach( drum => {
			if ( "gain" in drum ) {
				drum.pan = drum.pan ?? 0;
				drum.detune = drum.detune ?? 0;
			}
		} );
	} );

	// channels
	// ..........................................
	if ( !cmp.channels ) {
		cmp.channels = DAWCore.json.channels();
		Object.values( cmp.synths ).forEach( syn => syn.dest = "main" );
	}
	if ( ( !cmp.savedAt || cmp.savedAt < 1574550000 ) && cmp.channels.main.gain > .8 ) { // Sun Nov 24 2019 00:00:00 GMT+0100
		cmp.channels.main.gain = .4;
	}
	delete cmp.channels.main.order;

	// effects
	// ..........................................
	cmp.effects = cmp.effects || {};

	// patterns
	// ..........................................
	Object.values( cmp.patterns ).forEach( pat => {
		if ( !( "order" in pat ) ) {
			pat.order = orderDefault;
		}
		orderDefault = Math.max( pat.order, orderDefault ) + 1;
		if ( pat.type === "keys" ) {
			pat.synth = pat.synth || "0";
		}
	} );

	// synths
	// ..........................................
	if ( !cmp.synths ) {
		cmp.synths = { 0: DAWCore.json.synth() };
	}
	Object.values( cmp.synths ).forEach( syn => {
		delete syn.envelopes;
		syn.env = syn.env || DAWCore.json.env();
		syn.lfo = syn.lfo || DAWCore.json.lfo();
		Object.values( syn.oscillators ).forEach( osc => {
			osc.detune = Math.min( Math.max( -24, Math.round( osc.detune ) ), 24 );
		} );
	} );

	// ..........................................
	Object.values( cmp.tracks ).reduce( ( order, tr ) => {
		tr.name = typeof tr.name === "string" ? tr.name : "";
		tr.order = typeof tr.order === "number" ? tr.order : order;
		tr.toggle = typeof tr.toggle === "boolean" ? tr.toggle : true;
		return tr.order + 1;
	}, 0 );
	blcsValues.sort( ( a, b ) => a.when - b.when );
	cmp.blocks = blcsValues.reduce( ( obj, blc, i ) => {
		blc.offset = blc.offset || 0;
		blc.selected = !!blc.selected;
		blc.durationEdited = !!blc.durationEdited;
		obj[ i ] = blc;
		return obj;
	}, {} );
	Object.values( cmp.keys ).forEach( keys => {
		Object.values( keys ).forEach( k => {
			k.pan = GSUtils.castToNumber( k.pan, 0, -1, 1, 2 );
			k.gain = GSUtils.castToNumber( k.gain, .8, 0, 1, 2 );
			k.attack = GSUtils.castToNumber( k.attack, 0, 0, Infinity, 3 );
			k.release = GSUtils.castToNumber( k.release, 0, 0, Infinity, 3 );
			k.lowpass = GSUtils.castToNumber( k.lowpass, 1, 0, 1, 2 );
			k.highpass = GSUtils.castToNumber( k.highpass, 1, 0, 1, 2 );
			k.selected = !!k.selected;
			if ( typeof k.prev === "number" ) { k.prev += ""; }
			if ( typeof k.next === "number" ) { k.next += ""; }
			k.prev = k.prev || null;
			k.next = k.next || null;
			delete k.durationEdited;
			if ( typeof k.key === "string" ) {
				if ( window.gsuiKeys ) {
					k.key = window.gsuiKeys.keyStrToMidi( k.key );
				} else {
					console.warn( "DAWCore.Composition.format: gsuiKeys is needed to convert an old midi notation" );
					return null;
				}
			}
		} );
	} );
	return cmp;
};

DAWCore.Composition.prototype.change = function( obj, prevObj ) {
	const cmp = this.cmp,
		act = this.daw.history.getCurrentAction(),
		saved = act === this._actionSavedOn && !!cmp.savedAt;

	GSUtils.diffAssign( cmp, obj );
	this._wamixer.change( obj );
	this.daw._wadrumrows.change( obj );
	this._waeffects.change( obj );
	this.change.fn.forEach( ( fn, attr ) => {
		if ( typeof attr === "string" ) {
			if ( attr in obj ) {
				fn.call( this, obj, prevObj );
			}
		} else if ( attr.some( attr => attr in obj ) ) {
			fn.call( this, obj, prevObj );
		}
	} );

	if ( saved !== this._saved ) {
		this._saved = saved;
		this.daw._call( "compositionSavedStatus", cmp, saved );
	}
	this.daw._call( "compositionChanged", obj, prevObj );
	return obj;
};

DAWCore.Composition.prototype.change.fn = new Map( [
	[ "bpm", function( { bpm } ) {
		this._sched.setBPM( bpm );
		this._synths.forEach( syn => syn.setBPM( bpm ) );
		this.daw.drums.setBPM( bpm );
		this.daw.pianoroll.setBPM( bpm );
	} ],
	[ "blocks", function( { blocks } ) {
		this._sched.change( blocks );
	} ],
	[ [ "loopA", "loopB" ], function() {
		if ( this.daw.getFocusedObject() === this ) {
			this._sched.setLoopBeat(
				this.cmp.loopA || 0,
				this.cmp.loopB || this.cmp.duration || this.cmp.beatsPerMeasure );
		}
	} ],
	[ "duration", function() {
		if ( this.daw.getFocusedObject() === this && this.cmp.loopA === null ) {
			this._sched.setLoopBeat( 0, this.cmp.duration || this.cmp.beatsPerMeasure );
		}
	} ],
	[ "synths", function( { synths }, { synths: prevSynths } ) {
		Object.entries( synths ).forEach( ( [ id, synthObj ] ) => {
			if ( !synthObj ) {
				this._synths.get( id ).stopAllKeys();
				this._synths.delete( id );
			} else if ( !prevSynths[ id ] ) {
				const syn = new gswaSynth();

				syn.setContext( this.ctx );
				syn.setBPM( this.cmp.bpm );
				syn.change( synthObj );
				syn.output.connect( this._wamixer.getChanInput( synthObj.dest ) );
				this._synths.set( id, syn );
			} else {
				const syn = this._synths.get( id );

				if ( "oscillators" in synthObj || "lfo" in synthObj ) {
					syn.change( synthObj );
				}
				if ( "dest" in synthObj ) {
					syn.output.disconnect();
					syn.output.connect( this._wamixer.getChanInput( synthObj.dest ) );
				}
			}
		} );
	} ],
	[ "patterns", function( { patterns } ) {
		Object.entries( patterns ).forEach( ( [ patId, patObj ] ) => {
			if ( patObj ) {
				if ( "dest" in patObj && this.cmp.patterns[ patId ].type === "buffer" ) {
					this.redirectPatternBuffer( patId, patObj.dest );
				}
				if ( patId === this.cmp.patternKeysOpened ) {
					this.daw.pianoroll.change( patObj );
				} else if ( patId === this.cmp.patternDrumsOpened ) {
					this.daw.drums.change( patObj );
				}
			}
		} );
	} ],
	[ "keys", function( { keys, patterns } ) {
		const pats = Object.entries( this.cmp.patterns ),
			patOpened = this.cmp.patternKeysOpened;

		Object.entries( keys ).forEach( ( [ keysId, keysObj ] ) => {
			pats.some( ( [ patId, patObj ] ) => {
				if ( patObj.keys === keysId ) {
					this.assignPatternChange( patId, keysObj );
					if ( patId === patOpened ) {
						this.daw.pianoroll.change( patterns && patterns[ patId ], keysObj );
					}
					return true;
				}
			} );
		} );
	} ],
	[ "drums", function( { drums, patterns } ) {
		const pats = Object.entries( this.cmp.patterns ),
			patOpened = this.cmp.patternDrumsOpened;

		Object.entries( drums ).forEach( ( [ drumsId, drumsObj ] ) => {
			pats.some( ( [ patId, patObj ] ) => {
				if ( patObj.drums === drumsId ) {
					this.assignPatternChange( patId, drumsObj );
					if ( patId === patOpened ) {
						this.daw.drums.change( patterns && patterns[ patId ], drumsObj );
					}
					return true;
				}
			} );
		} );
	} ],
	[ "patternKeysOpened", function( obj ) {
		this.daw.pianoroll.openPattern( obj.patternKeysOpened );
	} ],
	[ "patternDrumsOpened", function( obj ) {
		this.daw.drums.openPattern( obj.patternDrumsOpened );
	} ],
	[ "synthOpened", function( obj ) {
		this.daw.pianoroll.setSynth( obj.synthOpened );
	} ],
] );

DAWCore.json.composition = ( env, id ) => {
	const tracks = {},
		sPB = env.def_stepsPerBeat,
		bPM = env.def_beatsPerMeasure;

	for ( let i = 0; i < env.def_nbTracks; ++i ) {
		tracks[ i ] = DAWCore.json.track( { order: i } );
	}
	return {
		id,
		name: "",
		bpm: env.def_bpm,
		stepsPerBeat: sPB,
		beatsPerMeasure: bPM,
		duration: bPM,
		loopA: false,
		loopB: false,
		synthOpened: "0",
		patternKeysOpened: "0",
		patternDrumsOpened: "1",
		patternBufferOpened: null,
		buffers: {
			0: { type: "audio/wav", duration: .1529, url: "kick-00.wav" },
			1: { type: "audio/wav", duration: .256, url: "clap-00.wav" },
			2: { type: "audio/wav", duration: .0357, url: "hat-00.wav" },
			3: { type: "audio/wav", duration: .1151, url: "snare-00.wav" },
			4: { type: "audio/wav", duration: .7, url: "hat-open-00.wav" },
		},
		patterns: {
			0: { order: 0, type: "keys", name: "keys", keys: "0", synth: "0", duration: bPM, },
			1: { order: 0, type: "drums", name: "drums", drums: "0", duration: bPM, },
			2: { order: 0, type: "buffer", dest: "1", buffer: "0", duration: 1, name: "kick" },
			3: { order: 1, type: "buffer", dest: "1", buffer: "1", duration: 1, name: "clap" },
			4: { order: 2, type: "buffer", dest: "1", buffer: "2", duration: 1, name: "hat" },
			6: { order: 3, type: "buffer", dest: "1", buffer: "4", duration: 1, name: "open hat" },
			5: { order: 4, type: "buffer", dest: "1", buffer: "3", duration: 1, name: "snare" },
		},
		channels: DAWCore.json.channels(),
		tracks,
		blocks: {
			0: DAWCore.json.block( { pattern: "0", track: "0", duration: bPM } ),
			1: DAWCore.json.block( { pattern: "1", track: "1", duration: bPM } ),
		},
		synths: { 0: DAWCore.json.synth( { dest: "2" } ) },
		drumrows: {
			0: DAWCore.json.drumrow( { order: 0, pattern: "2" } ),
			1: DAWCore.json.drumrow( { order: 1, pattern: "3" } ),
			2: DAWCore.json.drumrow( { order: 2, pattern: "4" } ),
			4: DAWCore.json.drumrow( { order: 3, pattern: "6" } ),
			3: DAWCore.json.drumrow( { order: 4, pattern: "5" } ),
		},
		drums: { 0: {} },
		keys: { 0: {} },
	};
};

DAWCore.json.block = obj => ( {
	pattern: null,
	duration: 0,
	durationEdited: false,
	selected: false,
	offset: 0,
	when: 0,
	track: null,
	...obj,
} );

DAWCore.json.channel = obj => ( {
	order: 0,
	toggle: true,
	name: "chan",
	dest: "main",
	gain: 1,
	pan: 0,
	...obj,
} );

DAWCore.json.channels = () => {
	const main = DAWCore.json.channel( { name: "main", gain: .4 } );

	delete main.dest;
	delete main.order;
	return {
		main,
		1: DAWCore.json.channel( { order: 0, name: "drums" } ),
		2: DAWCore.json.channel( { order: 1, name: "synth" } ),
		3: DAWCore.json.channel( { order: 2, name: "chan 3" } ),
		4: DAWCore.json.channel( { order: 3, name: "chan 4" } ),
	};
};

DAWCore.json.drum = obj => ( {
	when: 0,
	row: null,
	detune: 0,
	gain: 1,
	pan: 0,
	...obj,
} );

DAWCore.json.drumcut = obj => ( {
	when: 0,
	row: null,
	...obj,
} );

DAWCore.json.drumrow = obj => ( {
	order: 0,
	toggle: true,
	pattern: null,
	detune: 0,
	gain: 1,
	pan: 0,
	...obj,
} );

DAWCore.json.effects.filter = obj => ( {
	type: "lowpass",
	Q: 5,
	gain: -20,
	detune: 0,
	frequency: 500,
	...obj,
} );

DAWCore.json.env = obj => ( {
	toggle: true,
	attack: .15,
	hold: .08,
	decay: .08,
	substain: .5,
	release: .25,
	...obj,
} );

DAWCore.json.key = obj => ( {
	key: 57,
	when: 1,
	duration: 1,
	gain: .8,
	pan: 0,
	highpass: 1,
	lowpass: 1,
	attack: 0,
	release: 0,
	selected: false,
	prev: null,
	next: null,
	...obj,
} );

DAWCore.json.lfo = obj => ( {
	toggle: false,
	type: "sine",
	delay: 0,
	attack: 1,
	speed: 1,
	amp: 1,
	...obj,
} );

DAWCore.json.oscillator = obj => ( {
	order: 0,
	type: "sine",
	pan: 0,
	gain: 1,
	detune: 0,
	...obj,
} );

DAWCore.json.synth = obj => ( {
	name: "synth",
	dest: "main",
	env: DAWCore.json.env(),
	lfo: DAWCore.json.lfo(),
	oscillators: {
		0: DAWCore.json.oscillator( { gain: .75 } ),
		1: DAWCore.json.oscillator( { order: 1, gain: .2, detune: -24 } ),
	},
	...obj,
} );

DAWCore.json.track = obj => ( {
	name: "",
	order: 0,
	toggle: true,
	...obj,
} );

DAWCore.controllers.blocks = class {
	constructor( fns ) {
		this.data = {};
		this.on = GSUtils.mapCallbacks( [
			"addBlock",
			"removeBlock",
			"changeBlockProp",
			"updateBlockViewBox",
		], fns.dataCallbacks );
		this._blocksCrud = GSUtils.createUpdateDelete.bind( null, this.data,
			this._addBlock.bind( this ),
			this._updateBlock.bind( this ),
			this._deleteBlock.bind( this ) );
		Object.freeze( this );
	}

	// .........................................................................
	clear() {
		Object.keys( this.data ).forEach( this._deleteBlock, this );
	}
	change( obj ) {
		this._blocksCrud( obj.blocks );
	}

	// .........................................................................
	_addBlock( id, obj ) {
		const blc = { ...obj };

		this.data[ id ] = blc;
		this.on.addBlock( id, blc );
		this._updateBlock( id, blc );
	}
	_deleteBlock( id ) {
		delete this.data[ id ];
		this.on.removeBlock( id );
	}
	_updateBlock( id, obj ) {
		const dataBlc = this.data[ id ],
			cb = this.on.changeBlockProp.bind( null, id );

		this._setProp( dataBlc, cb, "when", obj.when );
		this._setProp( dataBlc, cb, "duration", obj.duration );
		this._setProp( dataBlc, cb, "offset", obj.offset );
		this._setProp( dataBlc, cb, "track", obj.track );
		this._setProp( dataBlc, cb, "selected", obj.selected );
		if ( "offset" in obj || "duration" in obj ) {
			this.on.updateBlockViewBox( id, dataBlc );
		}
	}
	_setProp( data, cb, prop, val ) {
		if ( val !== undefined ) {
			data[ prop ] = val;
			cb( prop, val );
		}
	}
};

Object.freeze( DAWCore.controllers.blocks );

DAWCore.controllers.drumrows = class {
	constructor( fns ) {
		this.data = Object.freeze( {
			patterns: {},
			drumrows: {},
		} );
		this.on = GSUtils.mapCallbacks( [
			"addDrumrow",
			"removeDrumrow",
			"changeDrumrow",
		], fns.dataCallbacks );
		this._drumrowsCrud = GSUtils.createUpdateDelete.bind( null, this.data.drumrows,
			this._addDrumrow.bind( this ),
			this._updateDrumrow.bind( this ),
			this._deleteDrumrow.bind( this ) );
		this._patternsCrud = GSUtils.createUpdateDelete.bind( null, this.data.patterns,
			this._addPattern.bind( this ),
			this._updatePattern.bind( this ),
			this._deletePattern.bind( this ) );
		Object.freeze( this );
	}
	change( { patterns, drumrows } ) {
		if ( patterns ) { this._patternsCrud( patterns ); }
		if ( drumrows ) { this._drumrowsCrud( drumrows ); }
	}
	clear() {
		Object.keys( this.data.patterns ).forEach( id => delete this.data.patterns[ id ] );
		Object.keys( this.data.drumrows ).forEach( this._deleteDrumrow, this );
	}

	// .........................................................................
	_addPattern( id, { type, name, dest, buffer, duration } ) {
		if ( type === "buffer" ) {
			const pat = Object.seal( { name, dest, buffer, duration } );

			this.data.patterns[ id ] = pat;
			this._updatePattern( id, pat );
		}
	}
	_updatePattern( id, { name, duration, dest } ) {
		if ( name !== undefined || duration !== undefined || dest !== undefined ) {
			const pat = this.data.patterns[ id ],
				rowsEnt = Object.entries( this.data.drumrows )
					.filter( kv => kv[ 1 ].pattern === id );

			this.__updatePattern( pat, rowsEnt, "name", name );
			this.__updatePattern( pat, rowsEnt, "dest", dest );
			this.__updatePattern( pat, rowsEnt, "duration", duration );
		}
	}
	__updatePattern( pat, rowsEnt, prop, val ) {
		if ( val !== undefined ) {
			pat[ prop ] = val;
			rowsEnt.forEach( kv => this.on.changeDrumrow( kv[ 0 ], prop, val ) );
		}
	}
	_deletePattern( id ) {
		delete this.data.patterns[ id ];
	}

	// .........................................................................
	_addDrumrow( id, obj ) {
		const row = Object.seal( { ...obj } );

		this.data.drumrows[ id ] = row;
		this.on.addDrumrow( id, row );
		this.__updateDrumrow( id, row );
	}
	_deleteDrumrow( id ) {
		delete this.data.drumrows[ id ];
		this.on.removeDrumrow( id );
	}
	_updateDrumrow( id, obj ) {
		const row = this.data.drumrows[ id ];

		Object.assign( row, obj );
		this.__updateDrumrow( id, obj );
	}
	__updateDrumrow( id, obj ) {
		const pat = this.data.patterns[ obj.pattern ];

		this.___updateDrumrow( id, "order", obj.order );
		this.___updateDrumrow( id, "toggle", obj.toggle );
		this.___updateDrumrow( id, "detune", obj.detune );
		this.___updateDrumrow( id, "pan", obj.pan );
		this.___updateDrumrow( id, "gain", obj.gain );
		this.___updateDrumrow( id, "pattern", obj.pattern );
		this.___updateDrumrow( id, "name", obj.pattern && pat.name );
		this.___updateDrumrow( id, "duration", obj.pattern && pat.duration );
	}
	___updateDrumrow( id, prop, val ) {
		if ( val !== undefined ) {
			this.on.changeDrumrow( id, prop, val );
		}
	}
};

Object.freeze( DAWCore.controllers.drumrows );

DAWCore.controllers.drums = class {
	constructor( fns ) {
		this.data = {};
		this.on = GSUtils.mapCallbacks( [
			"addDrum",
			"removeDrum",
			"changeDrum",
			"addDrumcut",
			"removeDrumcut",
		], fns.dataCallbacks );
		this._drumsCrud = GSUtils.createUpdateDelete.bind( null, this.data,
			this._addDrum.bind( this ),
			this._changeDrum.bind( this ),
			this._deleteDrum.bind( this ) );
		Object.freeze( this );
	}
	change( obj ) {
		this._drumsCrud( obj );
	}
	clear() {
		Object.keys( this.data ).forEach( this._deleteDrum, this );
	}

	// .........................................................................
	_addDrum( id, obj ) {
		const cpy = { ...obj };

		this.data[ id ] = cpy;
		if ( "gain" in cpy ) {
			this.on.addDrum( id, cpy );
			this._changeDrum( id, cpy );
		} else {
			this.on.addDrumcut( id, cpy );
		}
	}
	_deleteDrum( id ) {
		const fn = "gain" in this.data[ id ]
				? this.on.removeDrum
				: this.on.removeDrumcut;

		delete this.data[ id ];
		fn( id );
	}
	_changeDrum( id, obj ) {
		this._changeDrumProp( id, "detune", obj.detune );
		this._changeDrumProp( id, "gain", obj.gain );
		this._changeDrumProp( id, "pan", obj.pan );
	}
	_changeDrumProp( id, prop, val ) {
		if ( val !== undefined ) {
			this.data[ id ][ prop ] = val;
			this.on.changeDrum( id, prop, val );
		}
	}
};

Object.freeze( DAWCore.controllers.drums );

DAWCore.controllers.effects = class {
	constructor( fns ) {
		this.data = {};
		this.on = GSUtils.mapCallbacks( [
			"changeBPM",
			"addEffect",
			"removeEffect",
			"changeEffect",
			"connectEffectTo",
			"changeEffectData",
		], fns.dataCallbacks );
		this.values = Object.seal( {
			destFilter: null,
			resetting: false,
		} );
		this._effectsCrud = GSUtils.createUpdateDelete.bind( null, this.data,
			this._addEffect.bind( this ),
			this._updateEffect.bind( this ),
			this._deleteEffect.bind( this ) );
		Object.freeze( this );
	}

	// .........................................................................
	clear() {
		Object.keys( this.data ).forEach( id => this._deleteEffect( id ) );
	}
	reset() {
		const ent = Object.entries( this.data );

		this.values.resetting = true;
		ent.forEach( kv => this._deleteEffect( kv[ 0 ] ) );
		this.values.resetting = false;
		ent.forEach( kv => this._addEffect( kv[ 0 ], kv[ 1 ] ) );
	}
	change( obj ) {
		if ( obj.bpm ) {
			this.on.changeBPM( obj.bpm );
		}
		if ( obj.effects ) {
			this._effectsCrud( obj.effects );
		}
	}
	setDestFilter( dest ) {
		const old = this.values.destFilter;

		if ( dest !== old ) {
			this.values.destFilter = dest;
			Object.entries( this.data ).forEach( ( [ id, fx ] ) => {
				if ( fx.dest === old ) {
					this.__deleteEffect( id );
				} else if ( fx.dest === dest ) {
					this.__effectAdd( id, fx );
				}
			} );
		}
	}

	// .........................................................................
	_addEffect( id, obj, diffObj ) {
		const fx = Object.seal( GSUtils.jsonCopy( obj ) );

		this.data[ id ] = fx;
		if ( this._fxDestOk( fx ) ) {
			this.__effectAdd( id, fx, diffObj );
		}
	}
	__effectAdd( id, fx, diffObj ) {
		this.on.addEffect( id, fx );
		this.on.changeEffect( id, "toggle", fx.toggle );
		this.on.changeEffect( id, "order", fx.order );
		this.on.changeEffectData( id, fx.data );
		if ( !GSUtils.isNoop( this.on.connectEffectTo ) ) {
			const [ prevId, nextId ] = this._findSiblingFxIds( id, diffObj );

			this.on.connectEffectTo( fx.dest, id, nextId );
			this.on.connectEffectTo( fx.dest, prevId, id );
		}
	}
	_deleteEffect( id, diffObj ) {
		const fx = this.data[ id ];

		if ( this._fxDestOk( fx ) ) {
			this.__deleteEffect( id, diffObj );
		}
		delete this.data[ id ];
	}
	__deleteEffect( id, diffObj ) {
		if ( !this.values.resetting && !GSUtils.isNoop( this.on.connectEffectTo ) ) {
			const [ prevId, nextId ] = this._findSiblingFxIds( id, diffObj );

			this.on.connectEffectTo( this.data[ id ].dest, prevId, nextId );
		}
		this.on.removeEffect( id );
	}
	_updateEffect( id, fx, diffObj ) {
		const dataObj = this.data[ id ],
			destOk = this._fxDestOk( dataObj );

		if ( "toggle" in fx ) {
			dataObj.toggle = fx.toggle;
			if ( destOk ) {
				this.on.changeEffect( id, "toggle", fx.toggle );
			}
		}
		if ( "data" in fx ) {
			GSUtils.diffAssign( dataObj.data, fx.data );
			if ( destOk ) {
				this.on.changeEffectData( id, fx.data );
			}
		}
		if ( "order" in fx ) {
			if ( destOk && !GSUtils.isNoop( this.on.connectEffectTo ) ) {
				const [ prevId, nextId ] = this._findSiblingFxIds( id, diffObj );

				this.on.connectEffectTo( dataObj.dest, prevId, nextId );
			}
			dataObj.order = fx.order;
			if ( destOk ) {
				this.on.changeEffect( id, "order", fx.order );
				if ( !GSUtils.isNoop( this.on.connectEffectTo ) ) {
					const [ prevId, nextId ] = this._findSiblingFxIds( id, diffObj );

					this.on.connectEffectTo( dataObj.dest, prevId, id );
					this.on.connectEffectTo( dataObj.dest, id, nextId );
				}
			}
		}
	}

	// .........................................................................
	_fxDestOk( fx ) {
		return !this.values.destFilter || fx.dest === this.values.destFilter;
	}
	_findSiblingFxIds( id, diffObj = {} ) {
		const { dest, order } = this.data[ id ];
		let prevId = null,
			nextId = null,
			prevOrder = -Infinity,
			nextOrder = Infinity;

		Object.entries( this.data ).forEach( ( [ fxId, fx ] ) => {
			if ( fxId !== id && fx.dest === dest ) {
				const fxOrder = ( diffObj[ fxId ] || fx ).order;

				if ( prevOrder < fxOrder && fxOrder < order ) {
					prevId = fxId;
					prevOrder = fxOrder;
				}
				if ( order < fxOrder && fxOrder < nextOrder ) {
					nextId = fxId;
					nextOrder = fxOrder;
				}
			}
		} );
		return [ prevId, nextId ];
	}
};

Object.freeze( DAWCore.controllers.effects );

DAWCore.controllers.keys = class {
	constructor( fns ) {
		this.data = {};
		this.on = GSUtils.mapCallbacks( [
			"addKey",
			"removeKey",
			"changeKeyProp",
		], fns.dataCallbacks );
		this._keysCrud = GSUtils.createUpdateDelete.bind( null, this.data,
			this._addKey.bind( this ),
			this._updateKey.bind( this ),
			this._deleteKey.bind( this ) );
		Object.freeze( this );
	}

	// .........................................................................
	clear() {
		Object.keys( this.data ).forEach( this._deleteKey, this );
	}
	change( keysObj ) {
		this._keysCrud( keysObj );
	}

	// .........................................................................
	_addKey( id, obj ) {
		const key = { ...obj };

		this.data[ id ] = key;
		this.on.addKey( id, key );
		this._updateKey( id, key );
	}
	_deleteKey( id ) {
		delete this.data[ id ];
		this.on.removeKey( id );
	}
	_updateKey( id, obj ) {
		const dataKey = this.data[ id ],
			cb = this.on.changeKeyProp.bind( null, id );

		this._setProp( dataKey, cb, "key", obj.key );
		this._setProp( dataKey, cb, "when", obj.when );
		this._setProp( dataKey, cb, "duration", obj.duration );
		this._setProp( dataKey, cb, "attack", obj.attack );
		this._setProp( dataKey, cb, "release", obj.release );
		this._setProp( dataKey, cb, "gain", obj.gain );
		this._setProp( dataKey, cb, "pan", obj.pan );
		this._setProp( dataKey, cb, "lowpass", obj.lowpass );
		this._setProp( dataKey, cb, "highpass", obj.highpass );
		this._setProp( dataKey, cb, "selected", obj.selected );
		this._setProp( dataKey, cb, "prev", obj.prev );
		this._setProp( dataKey, cb, "next", obj.next );
	}
	_setProp( data, cb, prop, val ) {
		if ( val !== undefined ) {
			data[ prop ] = val;
			cb( prop, val );
		}
	}
};

Object.freeze( DAWCore.controllers.keys );

DAWCore.controllers.mixer = class {
	constructor( fns ) {
		this.data = Object.freeze( { channels: {} } );
		this.on = GSUtils.mapCallbacks( [
			"addChannel",
			"removeChannel",
			"toggleChannel",
			"renameChannel",
			"reorderChannel",
			"redirectChannel",
			"changePanChannel",
			"changeGainChannel",
		], fns.dataCallbacks );
		this._chansCrud = GSUtils.createUpdateDelete.bind( null, this.data.channels,
			this._addChannel.bind( this ),
			this._updateChannel.bind( this ),
			this._deleteChannel.bind( this ) );
		Object.freeze( this );
	}

	// .........................................................................
	clear() {
		Object.keys( this.data.channels ).forEach( id => {
			if ( id !== "main" ) {
				this._deleteChannel( id );
			}
		} );
	}
	recall() {
		const ent = Object.entries( this.data.channels );

		ent.forEach( kv => this._deleteChannel( kv[ 0 ] ) );
		ent.forEach( kv => this._addChannel( kv[ 0 ], kv[ 1 ] ) );
	}
	change( { channels } ) {
		this._chansCrud( channels );
	}

	// .........................................................................
	_addChannel( id, obj ) {
		this.data.channels[ id ] = {};
		this.on.addChannel( id, obj );
		this._updateChannel( id, obj );
	}
	_deleteChannel( id ) {
		delete this.data.channels[ id ];
		this.on.removeChannel( id );
	}
	_updateChannel( id, obj ) {
		Object.assign( this.data.channels[ id ], obj );
		this.__updateChannel( id, obj.name, this.on.renameChannel );
		this.__updateChannel( id, obj.order, this.on.reorderChannel );
		this.__updateChannel( id, obj.toggle, this.on.toggleChannel );
		this.__updateChannel( id, obj.dest, this.on.redirectChannel );
		this.__updateChannel( id, obj.pan, this.on.changePanChannel );
		this.__updateChannel( id, obj.gain, this.on.changeGainChannel );
	}
	__updateChannel( id, val, fn ) {
		if ( val !== undefined ) {
			fn( id, val );
		}
	}
};

Object.freeze( DAWCore.controllers.mixer );

DAWCore.controllers.synth = class {
	constructor( fns ) {
		this.data = Object.seal( {
			name: "",
			env: Object.seal( DAWCore.json.env() ),
			lfo: Object.seal( DAWCore.json.lfo() ),
			oscillators: {},
		} );
		this.on = GSUtils.mapCallbacks( [
			"addOsc",
			"removeOsc",
			"changeOsc",
			"changeOscProp",
			"updateOscWave",
			"changeLFO",
			"changeLFOProp",
			"updateLFOWave",
			"changeEnv",
			"changeEnvProp",
			"updateEnvWave",
		], fns.dataCallbacks );
		this._oscsCrud = GSUtils.createUpdateDelete.bind( null, this.data.oscillators,
			this._addOsc.bind( this ),
			this._updateOsc.bind( this ),
			this._deleteOsc.bind( this ) );
		Object.freeze( this );
	}

	// .........................................................................
	clear() {
		Object.keys( this.data.oscillators ).forEach( this._deleteOsc, this );
	}
	recall() {
		const oscs = Object.entries( this.data.oscillators );

		oscs.forEach( kv => this.on.removeOsc( kv[ 0 ] ) );
		oscs.forEach( kv => this.on.addOsc( kv[ 0 ], kv[ 1 ] ) );
	}
	change( obj ) {
		if ( "name" in obj ) {
			this.data.name = obj.name;
		}
		if ( obj.env ) {
			this._updateEnv( obj.env );
		}
		if ( obj.lfo ) {
			this._updateLFO( obj.lfo );
		}
		if ( obj.oscillators ) {
			this._oscsCrud( obj.oscillators );
		}
	}

	// .........................................................................
	_addOsc( id, obj ) {
		const osc = { ...obj };

		this.data.oscillators[ id ] = osc;
		this.on.addOsc( id, osc );
		this._updateOsc( id, osc );
	}
	_deleteOsc( id ) {
		delete this.data.oscillators[ id ];
		this.on.removeOsc( id );
	}
	_updateOsc( id, obj ) {
		const dataOsc = this.data.oscillators[ id ],
			cb = this.on.changeOscProp.bind( null, id );

		this._setProp( dataOsc, cb, "order", obj.order );
		this._setProp( dataOsc, cb, "type", obj.type );
		this._setProp( dataOsc, cb, "pan", obj.pan );
		this._setProp( dataOsc, cb, "gain", obj.gain );
		this._setProp( dataOsc, cb, "detune", obj.detune );
		this.on.updateOscWave( id );
		this.on.changeOsc( id, obj );
	}
	_updateEnv( obj ) {
		const dataEnv = this.data.env,
			cb = this.on.changeEnvProp;

		this._setProp( dataEnv, cb, "toggle", obj.toggle );
		this._setProp( dataEnv, cb, "attack", obj.attack );
		this._setProp( dataEnv, cb, "hold", obj.hold );
		this._setProp( dataEnv, cb, "decay", obj.decay );
		this._setProp( dataEnv, cb, "substain", obj.substain );
		this._setProp( dataEnv, cb, "release", obj.release );
		this.on.updateEnvWave();
		this.on.changeEnv( obj );
	}
	_updateLFO( obj ) {
		const dataLFO = this.data.lfo,
			cb = this.on.changeLFOProp;

		this._setProp( dataLFO, cb, "toggle", obj.toggle );
		this._setProp( dataLFO, cb, "type", obj.type );
		this._setProp( dataLFO, cb, "delay", obj.delay );
		this._setProp( dataLFO, cb, "attack", obj.attack );
		this._setProp( dataLFO, cb, "speed", obj.speed );
		this._setProp( dataLFO, cb, "amp", obj.amp );
		this.on.updateLFOWave();
		this.on.changeLFO( obj );
	}
	_setProp( data, cb, prop, val ) {
		if ( val !== undefined ) {
			data[ prop ] = val;
			cb( prop, val );
		}
	}
};

Object.freeze( DAWCore.controllers.synth );

DAWCore.controllers.tracks = class {
	constructor( fns ) {
		this.data = {};
		this.on = GSUtils.mapCallbacks( [
			"addTrack",
			"removeTrack",
			"toggleTrack",
			"renameTrack",
			"reorderTrack",
		], fns.dataCallbacks );
		this._tracksCrud = GSUtils.createUpdateDelete.bind( null, this.data,
			this._addTrack.bind( this ),
			this._changeTrack.bind( this ),
			this._deleteTrack.bind( this ) );
		Object.freeze( this );
	}
	change( obj ) {
		this._tracksCrud( obj.tracks );
	}
	clear() {
		Object.keys( this.data ).forEach( this._deleteTrack, this );
	}

	// .........................................................................
	_addTrack( id, obj ) {
		this.data[ id ] = { ...obj };
		this.on.addTrack( id );
		this._changeTrack( id, obj );
	}
	_deleteTrack( id ) {
		delete this.data[ id ];
		this.on.removeTrack( id );
	}
	_changeTrack( id, obj ) {
		this._changeTrackProp( id, "toggle", obj.toggle, this.on.toggleTrack );
		this._changeTrackProp( id, "name", obj.name, this.on.renameTrack );
		this._changeTrackProp( id, "order", obj.order, this.on.reorderTrack );
	}
	_changeTrackProp( id, prop, val, fn ) {
		if ( val !== undefined ) {
			this.data[ id ][ prop ] = val;
			fn( id, val );
		}
	}
};

Object.freeze( DAWCore.controllers.drums );

DAWCore.controllersFx.filter = class {
	constructor( fns ) {
		this.on = GSUtils.mapCallbacks( [
			"type",
			"Q",
			"gain",
			"detune",
			"frequency",
			"drawCurve",
		], fns.dataCallbacks );
		this.data = Object.seal( DAWCore.json.effects.filter() );
		Object.freeze( this );
	}

	recall() {
		this.on.type( this.data.type );
		this.on.Q( this.data.Q );
		this.on.gain( this.data.gain );
		this.on.detune( this.data.detune );
		this.on.frequency( this.data.frequency );
		this.on.drawCurve();
	}
	change( obj ) {
		this._changeProp( "type", obj.type, this.on.type );
		this._changeProp( "Q", obj.Q, this.on.Q );
		this._changeProp( "gain", obj.gain, this.on.gain );
		this._changeProp( "detune", obj.detune, this.on.detune );
		this._changeProp( "frequency", obj.frequency, this.on.frequency );
		this.on.drawCurve();
	}

	_changeProp( prop, val, cb ) {
		if ( val !== undefined ) {
			this.data[ prop ] = val;
			cb( val );
		}
	}
};

Object.freeze( DAWCore.controllersFx.filter );

DAWCore.common.calcNewDuration = ( changeObj, get ) => {
	const blocks = changeObj.blocks || {},
		bPM = changeObj.beatsPerMeasure || get.beatsPerMeasure(),
		dur = Object.entries( get.blocks() ).reduce( ( max, [ id, blc ] ) => {
			const blcChange = blocks[ id ];

			if ( blcChange || !( id in blocks ) ) {
				const when = blcChange?.when ?? blc.when,
					dur = blcChange?.duration ?? blc.duration;

				return Math.max( max, when + dur );
			}
			return max;
		}, 0 ),
		dur2 = Object.entries( blocks ).reduce( ( max, [ id, blc ] ) => {
			return blc && !get.block( id )
				? Math.max( max, blc.when + blc.duration )
				: max;
		}, dur );

	return Math.ceil( dur2 / bPM ) * bPM;
};

DAWCore.common.calcNewKeysDuration = ( keysId, keysObj, get ) => {
	const bPM = get.beatsPerMeasure(),
		keys = get.keys( keysId ),
		dur = Object.entries( keys ).reduce( ( max, [ id, key ] ) => {
			const keyChange = keysObj[ id ];

			if ( keyChange || !( id in keysObj ) ) {
				const when = keyChange?.when ?? key.when,
					dur = keyChange?.duration ?? key.duration;

				return Math.max( max, when + dur );
			}
			return max;
		}, 0 ),
		dur2 = Object.entries( keysObj ).reduce( ( max, [ id, key ] ) => {
			return key && !keys[ id ]
				? Math.max( max, key.when + key.duration )
				: max;
		}, dur );

	return Math.max( 1, Math.ceil( dur2 / bPM ) ) * bPM;
};

DAWCore.common.createUniqueName = ( collection, name, get ) => {
	const arr = Object.values( get[ collection ]() );

	return GSUtils.uniqueName( name, arr.map( obj => obj.name ) );
};

DAWCore.common.getDrumrowName = ( rowId, get ) => {
	return get.pattern( get.drumrow( rowId ).pattern ).name;
};

DAWCore.common.getNextIdOf = obj => {
	const id = Object.keys( obj )
		.reduce( ( max, id ) => Math.max( max, +id || 0 ), 0 );

	return `${ id + 1 }`;
};

DAWCore.common.getNextOrderOf = obj => {
	return Object.values( obj )
		.reduce( ( max, item ) => Math.max( max, item.order ), -1 ) + 1;
};

DAWCore.common.toggleSolo = ( soloId, list ) => {
	const entries = Object.entries( list ),
		someOn = entries.some( kv => kv[ 0 ] !== soloId && kv[ 1 ].toggle === true ),
		obj = entries.reduce( ( obj, [ id, item ] ) => {
			const itself = id === soloId;

			if ( ( itself && !item.toggle ) || ( !itself && item.toggle === someOn ) ) {
				obj[ id ] = { toggle: !item.toggle };
			}
			return obj;
		}, {} );

	return [ !someOn, obj ];
};

DAWCore.common.updatePatternDuration = ( obj, patId, duration, get ) => {
	if ( duration !== get.pattern( patId ).duration ) {
		const objBlocks = Object.entries( get.blocks() )
				.reduce( ( obj, [ id, blc ] ) => {
					if ( blc.pattern === patId && !blc.durationEdited ) {
						obj[ id ] = { duration };
					}
					return obj;
				}, {} );

		obj.patterns = { [ patId ]: { duration } };
		GSUtils.addIfNotEmpty( obj, "blocks", objBlocks );
		if ( GSUtils.isntEmpty( objBlocks ) ) {
			const dur = DAWCore.common.calcNewDuration( obj, get );

			if ( dur !== get.duration() ) {
				obj.duration = dur;
			}
		}
	}
};

DAWCore.actions.addBlock = ( pattern, when, track, get ) => {
	const pat = get.pattern( pattern ),
		nId = DAWCore.common.getNextIdOf( get.blocks() ),
		objBlc = DAWCore.json.block( {
			pattern,
			when,
			track,
			duration: pat.duration,
		} ),
		obj = { blocks: { [ nId ]: objBlc } },
		dur = DAWCore.common.calcNewDuration( obj, get );

	if ( dur !== get.duration() ) {
		obj.duration = dur;
	}
	return [
		obj,
		[ "blocks", "addBlock", pat.name ],
	];
};

DAWCore.actions.addBuffers = ( obj, get ) => {
	return [
		obj,
	];
};

DAWCore.actions.addChannel = get => {
	const channels = get.channels(),
		id = DAWCore.common.getNextIdOf( channels ),
		order = DAWCore.common.getNextOrderOf( channels ),
		name = `chan ${ id }`,
		chanObj = DAWCore.json.channel( { order, name } );

	return [
		{ channels: { [ id ]: chanObj } },
		[ "channels", "addChannel", name ],
	];
};

DAWCore.actions.addDrumcuts = ( patternId, rowId, whenFrom, whenTo, get ) => {
	return DAWCore.actions._addDrums( "drumcut", true, patternId, rowId, whenFrom, whenTo, get );
};

DAWCore.actions.addDrumrow = ( pattern, get ) => {
	const pat = get.pattern( pattern );

	if ( pat.type === "buffer" ) {
		const drumrows = get.drumrows(),
			id = DAWCore.common.getNextIdOf( drumrows ),
			order = DAWCore.common.getNextOrderOf( drumrows ),
			rowObj = DAWCore.json.drumrow( { pattern, order } );

		return [
			{ drumrows: { [ id ]: rowObj } },
			[ "drumrows", "addDrumrow", pat.name ],
		];
	}
};

DAWCore.actions.addDrums = ( patternId, rowId, whenFrom, whenTo, get ) => {
	return DAWCore.actions._addDrums( "drum", true, patternId, rowId, whenFrom, whenTo, get );
};

DAWCore.actions._addDrums = ( type, status, patternId, rowId, whenFrom, whenTo, get ) => {
	const stepDur = 1 / get.stepsPerBeat(),
		whenA = Math.round( Math.min( whenFrom, whenTo ) / stepDur ),
		whenB = Math.round( Math.max( whenFrom, whenTo ) / stepDur ),
		pat = get.pattern( patternId ),
		drums = get.drums( pat.drums ),
		patRowId = get.drumrow( rowId ).pattern,
		patRow = get.pattern( patRowId ),
		drumsEnt = Object.entries( drums ),
		drumsMap = drumsEnt.reduce( ( map, [ drumId, drum ] ) => {
			if ( drum.row === rowId && type === "drum" === "gain" in drum ) {
				map.set( Math.round( drum.when / stepDur ), drumId );
			}
			return map;
		}, new Map() ),
		newDrums = {},
		nextDrumId = +DAWCore.common.getNextIdOf( drums ),
		jsonType = DAWCore.json[ type ];
	let nbDrums = 0,
		drumWhenMax = pat.duration;

	for ( let w = whenA; w <= whenB; ++w ) {
		const drmId = drumsMap.get( w );

		if ( drmId ) {
			if ( !status ) {
				newDrums[ drmId ] = undefined;
				++nbDrums;
			}
		} else if ( status ) {
			const when = w * stepDur;

			drumWhenMax = Math.max( drumWhenMax, when + .001 );
			newDrums[ nextDrumId + nbDrums ] = jsonType( { when, row: rowId } );
			++nbDrums;
		}
	}
	if ( nbDrums > 0 && !status ) {
		drumWhenMax = drumsEnt.reduce( ( dur, [ drumId, drum ] ) => {
			return drumId in newDrums
				? dur
				: Math.max( dur, drum.when + .001 );
		}, 0 );
	}
	if ( nbDrums > 0 ) {
		const bPM = get.beatsPerMeasure(),
			duration = Math.max( 1, Math.ceil( drumWhenMax / bPM ) ) * bPM,
			obj = { drums: { [ pat.drums ]: newDrums } };

		DAWCore.common.updatePatternDuration( obj, patternId, duration, get );
		return [
			obj,
			[ "drums", status ? "addDrums" : "removeDrums", pat.name, patRow.name, nbDrums ],
		];
	}
};

DAWCore.actions.addEffect = ( dest, type, get ) => {
	const fxs = get.effects(),
		destFxs = Object.values( fxs ).filter( fx => fx.dest === dest ),
		id = DAWCore.common.getNextIdOf( fxs ),
		fx = {
			dest,
			type,
			toggle: true,
			order: DAWCore.common.getNextOrderOf( destFxs ),
			data: DAWCore.json.effects[ type ](),
		};

	return [
		{ effects: { [ id ]: fx } },
		[ "effects", "addEffect", get.channel( dest ).name, type ],
	];
};

DAWCore.actions.addKey = ( patId, key, when, duration, get ) => {
	const pat = get.pattern( patId ),
		keys = get.keys( pat.keys ),
		id = DAWCore.common.getNextIdOf( keys ),
		keysObj = { [ id ]: DAWCore.json.key( { key, when, duration } ) },
		patDur = DAWCore.common.calcNewKeysDuration( pat.keys, keysObj, get ),
		obj = { keys: { [ pat.keys ]: keysObj } };

	Object.entries( keys ).reduce( ( obj, [ id, key ] ) => {
		if ( key.selected && !( id in obj ) ) {
			obj[ id ] = { selected: false };
		}
		return obj;
	}, keysObj );
	DAWCore.common.updatePatternDuration( obj, patId, patDur, get );
	return [
		obj,
		[ "keys", "addKey", pat.name ],
	];
};

DAWCore.actions.addOscillator = ( synthId, get ) => {
	const oscs = get.synth( synthId ).oscillators,
		id = DAWCore.common.getNextIdOf( oscs ),
		osc = DAWCore.json.oscillator();

	osc.order = DAWCore.common.getNextOrderOf( oscs );
	return [
		{ synths: { [ synthId ]: { oscillators: { [ id ]: osc } } } },
		[ "synth", "addOscillator", get.synth( synthId ).name ],
	];
};

DAWCore.actions.addPatternDrums = get => {
	const pats = get.patterns(),
		drumsId = DAWCore.common.getNextIdOf( get.drums() ),
		patId = DAWCore.common.getNextIdOf( pats ),
		patName = DAWCore.common.createUniqueName( "patterns", "drums", get ),
		order = Object.values( pats ).reduce( ( max, pat ) => {
			return pat.type !== "drums"
				? max
				: Math.max( max, pat.order );
		}, -1 ) + 1,
		obj = {
			drums: { [ drumsId ]: {} },
			patterns: { [ patId ]: {
				order,
				type: "drums",
				name: patName,
				drums: drumsId,
				duration: get.beatsPerMeasure(),
			} },
			patternDrumsOpened: patId,
		};

	return [
		obj,
		[ "patterns", "addPattern", "drums", patName ],
	];
};

DAWCore.actions.addPatternKeys = ( synthId, get ) => {
	const pats = get.patterns(),
		keysId = DAWCore.common.getNextIdOf( get.keys() ),
		patId = DAWCore.common.getNextIdOf( pats ),
		patName = DAWCore.common.createUniqueName( "patterns", "keys", get ),
		synName = get.synth( synthId ).name,
		order = Object.values( pats ).reduce( ( max, pat ) => {
			return pat.synth !== synthId
				? max
				: Math.max( max, pat.order );
		}, -1 ) + 1,
		obj = {
			keys: { [ keysId ]: {} },
			patterns: { [ patId ]: {
				order,
				type: "keys",
				name: patName,
				keys: keysId,
				synth: synthId,
				duration: get.beatsPerMeasure(),
			} },
			patternKeysOpened: patId,
		};

	if ( synthId !== get.synthOpened() ) {
		obj.synthOpened = synthId;
	}
	return [
		obj,
		[ "patterns", "addPatternKeys", patName, synName ],
	];
};

DAWCore.actions.addSynth = get => {
	const id = DAWCore.common.getNextIdOf( get.synths() ),
		name = DAWCore.common.createUniqueName( "synths", "synth", get ),
		obj = {
			synths: { [ id ]: DAWCore.json.synth( { name } ) },
			synthOpened: id,
		};

	if ( get.patternKeysOpened() != null ) {
		obj.patternKeysOpened = null;
	}
	return [
		obj,
		[ "synths", "addSynth", name ],
	];
};

DAWCore.actions.changeChannel = ( id, prop, val, get ) => {
	return [
		{ channels: { [ id ]: { [ prop ]: val } } },
		[ "channels", "changeChannel", get.channel( id ).name, prop, val ],
	];
};

DAWCore.actions.changeDrumrow = ( rowId, prop, val, get ) => {
	const patName = DAWCore.common.getDrumrowName( rowId, get );

	return [
		{ drumrows: { [ rowId ]: { [ prop ]: val } } },
		[ "drumrows", "changeDrumrow", patName, prop, val ],
	];
};

DAWCore.actions.changeDrumrowPattern = ( rowId, pattern, get ) => {
	const row = get.drumrow( rowId ),
		pat = get.pattern( pattern );

	if ( row.pattern !== pattern && pat.type === "buffer" ) {
		const oldPat = DAWCore.common.getDrumrowName( rowId, get );

		return [
			{ drumrows: { [ rowId ]: { pattern } } },
			[ "drumrows", "changeDrumrowPattern", oldPat, pat.name ],
		];
	}
};



DAWCore.actions.changeDrumsProps = ( patId, prop, arr, get ) => {
	const pat = get.pattern( patId ),
		rowId = get.drums( pat.drums )[ arr[ 0 ][ 0 ] ].row,
		patRowName = DAWCore.common.getDrumrowName( rowId, get ),
		obj = arr.reduce( ( obj, [ drmId, val ] ) => {
			obj[ drmId ] = { [ prop ]: val };
			return obj;
		}, {} );

	return [
		{ drums: { [ pat.drums ]: obj } },
		[ "drums", "changeDrumsProps", pat.name, patRowName, prop, arr.length ],
	];
};

DAWCore.actions.changeEffect = ( fxId, prop, val, get ) => {
	const fx = get.effect( fxId );

	return [
		{ effects: { [ fxId ]: { data: { [ prop ]: val } } } },
		[ "effects", "changeEffect", get.channel( fx.dest ).name, fx.type, prop ],
	];
};

DAWCore.actions.changeEnv = ( synthId, prop, val, get ) => {
	return [
		{ synths: { [ synthId ]: { env: { [ prop ]: val } } } },
		[ "synth", "changeEnv", get.synth( synthId ).name, prop, val ],
	];
};

DAWCore.actions.changeKeysEnv = ( patId, keyIds, prop, incr, get ) => {
	const pat = get.pattern( patId ),
		keys = get.keys( pat.keys ),
		keysObj = keyIds.reduce( ( obj, id ) => {
			obj[ id ] = { [ prop ]: +( keys[ id ][ prop ] + incr ).toFixed( 3 ) };
			return obj;
		}, {} );

	return [
		{ keys: { [ pat.keys ]: keysObj } },
		[ "keys", "changeKeysEnv", pat.name, keyIds.length, prop ],
	];
};

DAWCore.actions.changeKeysProps = ( patId, prop, arr, get ) => {
	const pat = get.pattern( patId ),
		obj = arr.reduce( ( obj, [ keyId, val ] ) => {
			obj[ keyId ] = { [ prop ]: val };
			return obj;
		}, {} );

	return [
		{ keys: { [ pat.keys ]: obj } },
		[ "keys", "changeKeysProps", pat.name, prop, arr.length ],
	];
};

DAWCore.actions.changeLFO = ( synthId, prop, val, get ) => {
	return [
		{ synths: { [ synthId ]: { lfo: { [ prop ]: val } } } },
		[ "synth", "changeLFO", get.synth( synthId ).name, prop, val ],
	];
};

DAWCore.actions.changeLoop = ( a, b ) => {
	return Number.isFinite( a )
		? [
			{ loopA: a, loopB: b },
			[ "cmp", "changeLoop", a, b ]
		] : [
			{ loopA: null, loopB: null },
			[ "cmp", "removeLoop" ]
		];
};

DAWCore.actions.changeOscillator = ( synthId, oscId, prop, val, get ) => {
	return [
		{ synths: { [ synthId ]: { oscillators: { [ oscId ]: { [ prop ]: val } } } } },
		[ "synth", "changeOscillator", get.synth( synthId ).name, prop, val ],
	];
};

DAWCore.actions.changeTempo = ( bpm, bPM, sPB, get ) => {
	const bpmChanged = bpm !== get.bpm(),
		signChanged =
			bPM !== get.beatsPerMeasure() ||
			sPB !== get.stepsPerBeat();

	if ( signChanged || bpmChanged ) {
		const obj = {},
			objPatterns = {},
			patts = Object.entries( get.patterns() );

		if ( signChanged ) {
			obj.beatsPerMeasure = bPM;
			obj.stepsPerBeat = sPB;
			patts.forEach( ( [ id, pat ] ) => {
				if ( pat.type === "keys" || pat.type === "drums" ) {
					const duration = Math.max( 1, Math.ceil( pat.duration / bPM ) ) * bPM;

					if ( duration !== pat.duration ) {
						objPatterns[ id ] = { duration };
					}
				}
			} );
		}
		if ( bpmChanged ) {
			obj.bpm = bpm;
			patts.forEach( ( [ id, pat ] ) => {
				if ( pat.type === "buffer" ) {
					const bufDur = get.buffer( pat.buffer ).duration,
						duration = Math.ceil( bufDur * ( bpm / 60 ) );

					if ( duration !== pat.duration ) {
						objPatterns[ id ] = { duration };
					}
				}
			} );
		}
		if ( GSUtils.isntEmpty( objPatterns ) ) {
			const objBlocks = {};

			obj.patterns = objPatterns;
			Object.entries( get.blocks() ).forEach( ( [ id, blc ] ) => {
				const pat = objPatterns[ blc.pattern ];

				if ( pat && !blc.durationEdited ) {
					objBlocks[ id ] = { duration: pat.duration };
				}
			} );
			GSUtils.addIfNotEmpty( obj, "blocks", objBlocks );
			if ( GSUtils.isntEmpty( objBlocks ) ) {
				const dur = DAWCore.common.calcNewDuration( obj, get );

				if ( dur !== get.duration() ) {
					obj.duration = dur;
				}
			}
		}
		return [
			obj,
			[ "cmp", "changeTempo", bpm, bPM, sPB ],
		];
	}
};

DAWCore.actions.clonePattern = ( patId, get ) => {
	const pat = get.pattern( patId ),
		type = pat.type,
		newPat = { ...pat },
		newPatId = DAWCore.common.getNextIdOf( get.patterns() ),
		obj = { patterns: { [ newPatId ]: newPat } };

	newPat.name = DAWCore.common.createUniqueName( "patterns", pat.name, get );
	++newPat.order;
	if ( type === "keys" || type === "drums" ) {
		const newCnt = GSUtils.jsonCopy( get[ type ]( pat[ type ] ) ),
			newCntId = DAWCore.common.getNextIdOf( get[ type ]() );

		newPat[ type ] = newCntId;
		obj[ type ] = { [ newCntId ]: newCnt };
		obj[ type === "keys"
			? "patternKeysOpened"
			: "patternDrumsOpened" ] = newPatId;
		Object.entries( get.patterns() )
			.filter( type === "keys"
				? ( [ , pat ] ) => pat.type === type && pat.order >= newPat.order && pat.synth === newPat.synth
				: ( [ , pat ] ) => pat.type === type && pat.order >= newPat.order )
			.forEach( ( [ id, pat ] ) => obj.patterns[ id ] = { order: pat.order + 1 } );
	}
	return [
		obj,
		[ "patterns", "clonePattern", newPat.type, newPat.name, pat.name ],
	];
};

DAWCore.actions.cloneSelectedKeys = ( patId, keyIds, whenIncr, get ) => {
	const pat = get.pattern( patId ),
		keys = get.keys( pat.keys ),
		nextId = DAWCore.common.getNextIdOf( keys ),
		keysObj = {},
		obj = { keys: { [ pat.keys ]: keysObj } },
		mapIds = keyIds.reduce( ( map, id, i ) => {
			const nId = `${ nextId + i }`,
				nKey = { ...keys[ id ] };

			nKey.when += whenIncr;
			nKey.prev =
			nKey.next = null;
			keysObj[ id ] = { selected: false };
			keysObj[ nId ] = nKey;
			map.set( id, nId );
			return map;
		}, new Map() ),
		dur = DAWCore.common.calcNewKeysDuration( pat.keys, keysObj, get );

	keyIds.forEach( id => {
		const keyNext = keys[ id ].next;

		if ( mapIds.has( keyNext ) ) {
			const nId = mapIds.get( id ),
				nIdNext = mapIds.get( keyNext );

			keysObj[ nId ].next = nIdNext;
			keysObj[ nIdNext ].prev = nId;
		}
	} );
	DAWCore.common.updatePatternDuration( obj, patId, dur, get );
	return [
		obj,
		[ "keys", "cloneSelectedKeys", pat.name, keyIds.length ],
	];
};

DAWCore.actions.closePattern = ( type, get ) => {
	const attr = type === "keys"
			? "patternKeysOpened"
			: type === "drums"
				? "patternDrumsOpened"
				: "patternBufferOpened";

	if ( get[ attr ]() ) {
		return { [ attr ]: null };
	}
};

DAWCore.actions.cropEndBlocks = ( blcIds, whenIncr, get ) => {
	const blocks = blcIds.reduce( ( obj, id ) => {
			obj[ id ] = {
				duration: get.block( id ).duration + whenIncr,
				durationEdited: true,
			};
			return obj;
		}, {} ),
		obj = { blocks },
		dur = DAWCore.common.calcNewDuration( obj, get );

	if ( dur !== get.duration() ) {
		obj.duration = dur;
	}
	return [
		obj,
		[ "blocks", "cropEndBlocks", blcIds.length ],
	];
};

DAWCore.actions.cropEndKeys = ( patId, keyIds, durIncr, get ) => {
	const pat = get.pattern( patId ),
		patKeys = get.keys( pat.keys ),
		keys = keyIds.reduce( ( obj, id ) => {
			const k = patKeys[ id ],
				attRel = k.attack + k.release,
				duration = k.duration + durIncr,
				o = { duration };

			obj[ id ] = o;
			if ( duration < attRel ) {
				o.attack = +( k.attack / attRel * duration ).toFixed( 3 );
				o.release = +( k.release / attRel * duration ).toFixed( 3 );
			}
			return obj;
		}, {} ),
		obj = { keys: { [ pat.keys ]: keys } },
		duration = DAWCore.common.calcNewKeysDuration( pat.keys, keys, get );

	DAWCore.common.updatePatternDuration( obj, patId, duration, get );
	return [
		obj,
		[ "keys", "cropEndKeys", pat.name, keyIds.length ],
	];
};

DAWCore.actions.cropStartBlocks = ( blcIds, whenIncr, get ) => {
	const blocks = blcIds.reduce( ( obj, id ) => {
			const blc = get.block( id );

			obj[ id ] = {
				when: blc.when + whenIncr,
				offset: blc.offset + whenIncr,
				duration: blc.duration - whenIncr,
				durationEdited: true,
			};
			return obj;
		}, {} );

	return [
		{ blocks },
		[ "blocks", "cropStartBlocks", blcIds.length ],
	];
};

DAWCore.actions.duplicateSelectedBlocks = ( whenIncr, get ) => {
	const sel = Object.entries( get.blocks() ).filter( kv => kv[ 1 ].selected ),
		newId = +DAWCore.common.getNextIdOf( get.blocks() ),
		blocks = sel.reduce( ( obj, [ id, blc ], i ) => {
			const cpy = { ...blc };

			cpy.when += whenIncr;
			obj[ id ] = { selected: false };
			obj[ newId + i ] = cpy;
			return obj;
		}, {} ),
		obj = { blocks },
		dur = DAWCore.common.calcNewDuration( obj, get );

	if ( dur !== get.duration() ) {
		obj.duration = dur;
	}
	return [
		obj,
		[ "blocks", "duplicateSelectedBlocks", sel.length ],
	];
};

DAWCore.actions.moveBlocks = ( blcIds, whenIncr, trackIncr, get ) => {
	const blocks = {},
		obj = { blocks },
		tr = Object.entries( get.tracks() ).sort( ( a, b ) => a[ 1 ].order < b[ 1 ].order );

	blcIds.forEach( id => {
		const blc = get.block( id ),
			obj = {};

		blocks[ id ] = obj;
		if ( whenIncr ) {
			obj.when = blc.when + whenIncr;
		}
		if ( trackIncr ) {
			obj.track = tr[ tr.findIndex( kv => kv[ 0 ] === blc.track ) + trackIncr ][ 0 ];
		}
	} );
	if ( whenIncr ) {
		const dur = DAWCore.common.calcNewDuration( obj, get );

		if ( dur !== get.duration() ) {
			obj.duration = dur;
		}
	}
	return [
		obj,
		[ "blocks", "moveBlocks", blcIds.length ],
	];
};

DAWCore.actions.moveKeys = ( patId, keyIds, whenIncr, keyIncr, get ) => {
	const pat = get.pattern( patId ),
		patKeys = get.keys( pat.keys ),
		keys = keyIds.reduce( ( obj, id ) => {
			const k = patKeys[ id ],
				o = {};

			obj[ id ] = o;
			if ( whenIncr ) {
				o.when = k.when + whenIncr;
			}
			if ( keyIncr ) {
				o.key = k.key - keyIncr;
			}
			return obj;
		}, {} ),
		obj = { keys: { [ pat.keys ]: keys } };

	if ( whenIncr ) {
		const duration = DAWCore.common.calcNewKeysDuration( pat.keys, keys, get );

		DAWCore.common.updatePatternDuration( obj, patId, duration, get );
	}
	return [
		obj,
		[ "keys", "moveKeys", pat.name, keyIds.length ],
	];
};

DAWCore.actions.openPattern = ( patId, get ) => {
	const pat = get.pattern( patId );

	switch ( pat.type ) {
		case "drums":
			if ( patId !== get.patternDrumsOpened() ) {
				return { patternDrumsOpened: patId };
			}
			break;
		case "keys":
			if ( patId !== get.patternKeysOpened() ) {
				const obj = { patternKeysOpened: patId };

				if ( pat.synth !== get.synthOpened() ) {
					obj.synthOpened = pat.synth;
				}
				return obj;
			}
			break;
	}
};

DAWCore.actions.openSynth = ( id, get ) => {
	if ( id !== get.synthOpened() ) {
		const pat = Object.entries( get.patterns() ).find( kv => kv[ 1 ].synth === id ),
			patId = pat ? pat[ 0 ] : null,
			obj = { synthOpened: id };

		if ( patId !== get.patternKeysOpened() ) {
			obj.patternKeysOpened = patId;
		}
		return obj;
	}
};

DAWCore.actions.redirectChannel = ( id, dest, get ) => {
	if ( id !== dest ) {
		return [
			{ channels: { [ id ]: { dest } } },
			[ "channels", "redirectChannel", get.channel( id ).name, get.channel( dest ).name ],
		];
	}
};

DAWCore.actions.redirectKey = ( patId, keyId, destKeyId, get ) => {
	const pat = get.pattern( patId ),
		key = get.keys( pat.keys )[ keyId ],
		keys = {};

	if ( destKeyId ) {
		keys[ keyId ] = { next: destKeyId };
		keys[ destKeyId ] = { prev: keyId };
		if ( key.next ) {
			keys[ key.next ] = { prev: null };
		}
	} else {
		keys[ keyId ] = { next: null };
		keys[ key.next ] = { prev: null };
	}
	return [
		{ keys: { [ pat.keys ]: keys } },
		[ "keys", "redirectKey", pat.name, !!destKeyId ],
	];
};

DAWCore.actions.redirectPatternBuffer = ( id, dest, get ) => {
	return [
		{ patterns: { [ id ]: { dest } } },
		[ "patterns", "redirectPatternBuffer", get.pattern( id ).name, get.channel( dest ).name ],
	];
};

DAWCore.actions.redirectPatternKeys = ( patId, synthId, patterns, get ) => {
	const obj = { patterns };

	if ( patId === get.patternKeysOpened() ) {
		obj.synthOpened = synthId;
	}
	return [
		obj,
		[ "patterns", "redirectPatternKeys", get.pattern( patId ).name, get.synth( synthId ).name ],
	];
};

DAWCore.actions.redirectSynth = ( id, dest, get ) => {
	return [
		{ synths: { [ id ]: { dest } } },
		[ "synths", "redirectSynth", get.synth( id ).name, get.channel( dest ).name ],
	];
};

DAWCore.actions.removeBlocks = ( blcIds, get ) => {
	const blocks = blcIds.reduce( ( obj, id ) => {
			obj[ id ] = undefined;
			return obj;
		}, {} ),
		obj = { blocks },
		dur = DAWCore.common.calcNewDuration( obj, get );
	let selLen = 0;

	Object.entries( get.blocks() ).forEach( ( [ id, blc ] ) => {
		if ( blc.selected && !( id in blocks ) ) {
			++selLen;
			blocks[ id ] = { selected: false };
		}
	} );
	if ( dur !== get.duration() ) {
		obj.duration = dur;
	}
	return [
		obj,
		blcIds.length
			? [ "blocks", "removeBlocks", blcIds.length ]
			: [ "blocks", "unselectAllBlocks", selLen ],
	];
};

DAWCore.actions.removeChannel = ( id, get ) => {
	if ( id !== "main" ) {
		const red = DAWCore.actions.removeChannel_redirect,
			destMain = { dest: "main" },
			channels = red( id, get.channels(), { [ id ]: undefined }, destMain ),
			patterns = red( id, get.patterns(), {}, destMain ),
			effects = red( id, get.effects(), {}, undefined ),
			synths = red( id, get.synths(), {}, destMain ),
			obj = { channels };

		GSUtils.addIfNotEmpty( obj, "synths", synths );
		GSUtils.addIfNotEmpty( obj, "effects", effects );
		GSUtils.addIfNotEmpty( obj, "patterns", patterns );
		return [
			obj,
			[ "channels", "removeChannel", get.channel( id ).name ],
		];
	}
};

DAWCore.actions.removeChannel_redirect = ( chanId, list, obj, val ) => {
	return Object.entries( list ).reduce( ( obj, kv ) => {
		if ( kv[ 1 ].dest === chanId ) {
			obj[ kv[ 0 ] ] = val;
		}
		return obj;
	}, obj );
};

DAWCore.actions.removeDrumcuts = ( patternId, rowId, whenFrom, whenTo, get ) => {
	return DAWCore.actions._addDrums( "drumcut", false, patternId, rowId, whenFrom, whenTo, get );
};

DAWCore.actions.removeDrumrow = ( rowId, get ) => {
	const patName = DAWCore.common.getDrumrowName( rowId, get );

	return [
		DAWCore.actions._removeDrumrow( {}, rowId, get ),
		[ "drumrows", "removeDrumrow", patName ],
	];
};

DAWCore.actions._removeDrumrow = ( obj, rowId, get ) => {
	const bPM = get.beatsPerMeasure(),
		blocksEnt = Object.entries( get.blocks() ),
		patternsEnt = Object.entries( get.patterns() ),
		objDrums = {},
		objBlocks = {},
		objPatterns = {};

	obj.drumrows = obj.drumrows || {};
	obj.drumrows[ rowId ] = undefined;
	patternsEnt.forEach( ( [ patId, pat ] ) => {
		if ( pat.type === "drums" ) {
			const drumsObj = {},
				drumWhenMax = Object.entries( get.drums( pat.drums ) )
					.reduce( ( max, [ id, { row, when } ] ) => {
						if ( row === rowId ) {
							drumsObj[ id ] = undefined;
						}
						return row in obj.drumrows ? max : Math.max( max, when + .001 );
					}, 0 );

			if ( GSUtils.isntEmpty( drumsObj ) ) {
				const duration = Math.max( 1, Math.ceil( drumWhenMax / bPM ) ) * bPM;

				objDrums[ pat.drums ] = drumsObj;
				if ( duration !== pat.duration ) {
					objPatterns[ patId ] = { duration };
					blocksEnt.forEach( ( [ blcId, blc ] ) => {
						if ( blc.pattern === patId && !blc.durationEdited ) {
							objBlocks[ blcId ] = { duration };
						}
					} );
				}
			}
		}
	} );
	GSUtils.addIfNotEmpty( obj, "drums", objDrums );
	GSUtils.addIfNotEmpty( obj, "blocks", objBlocks );
	GSUtils.addIfNotEmpty( obj, "patterns", objPatterns );
	if ( GSUtils.isntEmpty( objBlocks ) ) {
		const dur = DAWCore.common.calcNewDuration( obj, get );

		if ( dur !== get.duration() ) {
			obj.duration = dur;
		}
	}
	return obj;
};

DAWCore.actions.removeDrums = ( patternId, rowId, whenFrom, whenTo, get ) => {
	return DAWCore.actions._addDrums( "drum", false, patternId, rowId, whenFrom, whenTo, get );
};

DAWCore.actions.removeEffect = ( id, get ) => {
	const fx = get.effect( id );

	return [
		{ effects: { [ id ]: undefined } },
		[ "effects", "removeEffect", get.channel( fx.dest ).name, fx.type ],
	];
};

DAWCore.actions.removeKeys = ( patId, keyIds, get ) => {
	const pat = get.pattern( patId ),
		keys = get.keys( pat.keys ),
		keysObj = keyIds.reduce( ( obj, id ) => {
			const { prev, next } = keys[ id ];

			obj[ id ] = undefined;
			if ( prev !== null ) {
				const objPrev = obj[ prev ];

				if ( !( prev in obj ) || objPrev !== undefined ) {
					objPrev
						? objPrev.next = null
						: obj[ prev ] = { next: null };
				}
			}
			if ( next !== null ) {
				const objNext = obj[ next ];

				if ( !( next in obj ) || objNext !== undefined ) {
					objNext
						? objNext.prev = null
						: obj[ next ] = { prev: null };
				}
			}
			return obj;
		}, {} ),
		obj = { keys: { [ pat.keys ]: keysObj } },
		patDur = DAWCore.common.calcNewKeysDuration( pat.keys, keysObj, get ),
		selLen = Object.entries( keys ).reduce( ( nb, [ id, key ] ) => {
			if ( key.selected && !( id in keysObj ) ) {
				keysObj[ id ] = { selected: false };
				return nb + 1;
			}
			return nb;
		}, 0 );

	DAWCore.common.updatePatternDuration( obj, patId, patDur, get );
	return [
		obj,
		keyIds.length
			? [ "keys", "removeKeys", pat.name, keyIds.length ]
			: [ "keys", "unselectAllKeys", pat.name, selLen ],
	];
};

DAWCore.actions.removeOscillator = ( synthId, id, get ) => {
	return [
		{ synths: { [ synthId ]: { oscillators: { [ id ]: undefined } } } },
		[ "synth", "removeOscillator", get.synth( synthId ).name ],
	];
};

DAWCore.actions.removePattern = ( patId, get ) => {
	const pat = get.pattern( patId ),
		type = pat.type,
		obj = { patterns: { [ patId ]: undefined } },
		blocks = Object.entries( get.blocks() ).reduce( ( blocks, [ blcId, blc ] ) => {
			if ( blc.pattern === patId ) {
				blocks[ blcId ] = undefined;
			}
			return blocks;
		}, {} );

	if ( type === "buffer" ) {
		Object.entries( get.drumrows() ).forEach( kv => {
			if ( kv[ 1 ].pattern === patId ) {
				GSUtils.deepAssign( obj,
					DAWCore.actions._removeDrumrow( obj, kv[ 0 ], get ) );
			}
		} );
	} else {
		obj[ type ] = { [ pat[ type ] ]: undefined };
	}
	if ( GSUtils.isntEmpty( blocks ) ) {
		const realDur = Object.values( get.blocks() )
				.reduce( ( dur, blc ) => {
					return blc.pattern === patId
						? dur
						: Math.max( dur, blc.when + blc.duration );
				}, 0 ),
			bPM = get.beatsPerMeasure(),
			dur = Math.max( 1, Math.ceil( realDur / bPM ) ) * bPM;

		obj.blocks = blocks;
		if ( dur !== get.duration() ) {
			obj.duration = dur;
		}
	}
	if ( type === "keys" ) {
		if ( patId === get.patternKeysOpened() ) {
			if ( !Object.entries( get.patterns() ).some( ( [ k, v ] ) => {
				if ( k !== patId && v.synth === pat.synth ) {
					obj.patternKeysOpened = k;
					return true;
				}
			} ) ) {
				obj.patternKeysOpened = null;
			}
		}
	} else if ( type === "drums" ) {
		if ( patId === get.patternDrumsOpened() ) {
			if ( !Object.entries( get.patterns() ).some( ( [ k, v ] ) => {
				if ( k !== patId && v.type === "drums" ) {
					obj.patternDrumsOpened = k;
					return true;
				}
			} ) ) {
				obj.patternDrumsOpened = null;
			}
		}
	}
	return [
		obj,
		[ "patterns", "removePattern", pat.type, pat.name ],
	];
};

DAWCore.actions.removeSynth = ( synthId, get ) => {
	const keys = {},
		blocks = {},
		patterns = {},
		cmpBlocks = Object.entries( get.blocks() ),
		cmpPatterns = Object.entries( get.patterns() ),
		obj = { synths: { [ synthId ]: undefined } };

	cmpPatterns.forEach( ( [ patId, pat ] ) => {
		if ( pat.synth === synthId ) {
			keys[ pat.keys ] =
			patterns[ patId ] = undefined;
			cmpBlocks.forEach( ( [ blcId, blc ] ) => {
				if ( blc.pattern === patId ) {
					blocks[ blcId ] = undefined;
				}
			} );
		}
	} );
	GSUtils.addIfNotEmpty( obj, "keys", keys );
	GSUtils.addIfNotEmpty( obj, "patterns", patterns );
	GSUtils.addIfNotEmpty( obj, "blocks", blocks );
	if ( synthId === get.synthOpened() ) {
		if ( !Object.keys( get.synths() ).some( k => {
			if ( k !== synthId ) {
				obj.synthOpened = k;
				if ( !cmpPatterns.some( ( [ patId, pat ] ) => {
					if ( pat.synth === k ) {
						obj.patternKeysOpened = patId;
						return true;
					}
				} ) ) {
					obj.patternKeysOpened = null;
				}
				return true;
			}
		} ) ) {
			obj.synthOpened = null;
		}
	}
	return [
		obj,
		[ "synths", "removeSynth", get.synth( synthId ).name ],
	];
};

DAWCore.actions.renameChannel = ( id, newName, get ) => {
	const name = GSUtils.trim2( newName ),
		chan = get.channel( id );

	if ( name && name !== chan.name ) {
		return [
			{ channels: { [ id ]: { name } } },
			[ "channels", "renameChannel", chan.name, name ],
		];
	}
};

DAWCore.actions.renameComposition = ( nameBrut, get ) => {
	const name = GSUtils.trim2( nameBrut ),
		oldName = get.name();

	if ( name && name !== oldName ) {
		return [
			{ name },
			[ "cmp", "renameComposition", oldName, name ],
		];
	}
};

DAWCore.actions.renamePattern = ( id, newName, get ) => {
	const name = GSUtils.trim2( newName ),
		pat = get.pattern( id );

	if ( name && name !== pat.name ) {
		return [
			{ patterns: { [ id ]: { name } } },
			[ "patterns", "renamePattern", pat.type, pat.name, name ],
		];
	}
};

DAWCore.actions.renameSynth = ( id, newName, get ) => {
	const syn = get.synth( id ),
		name = GSUtils.trim2( newName );

	if ( name && name !== syn.name ) {
		return [
			{ synths: { [ id ]: { name } } },
			[ "synths", "renameSynth", syn.name, name ],
		];
	}
};

DAWCore.actions.renameTrack = ( id, newName, get ) => {
	const oldName = get.track( id ).name,
		name = GSUtils.trim2( newName );

	if ( name !== oldName ) {
		return [
			{ tracks: { [ id ]: { name } } },
			[ "tracks", "renameTrack", oldName, name ],
		];
	}
};

DAWCore.actions.reorderChannel = ( chanId, channels, get ) => {
	return [
		{ channels },
		[ "channels", "reorderChannel", get.channel( chanId ).name ],
	];
};

DAWCore.actions.reorderDrumrow = ( rowId, drumrows, get ) => {
	const patName = DAWCore.common.getDrumrowName( rowId, get );

	return [
		{ drumrows },
		[ "drumrows", "reorderDrumrow", patName ],
	];
};

DAWCore.actions.reorderOscillator = ( synthId, oscillators, get ) => {
	return [
		{ synths: { [ synthId ]: { oscillators } } },
		[ "synth", "reorderOscillator", get.synth( synthId ).name ],
	];
};

DAWCore.actions.reorderPattern = ( patId, patterns, get ) => {
	const pat = get.pattern( patId );

	return [
		{ patterns },
		[ "patterns", "reorderPattern", pat.type, pat.name ],
	];
};

DAWCore.actions.selectBlocks = ( blcIds, get ) => {
	const blocks = blcIds.reduce( ( obj, id ) => {
			obj[ id ] = { selected: true };
			return obj;
		}, {} );

	return [
		{ blocks },
		[ "blocks", "selectBlocks", blcIds.length ],
	];
};

DAWCore.actions.selectKeys = ( patId, keyIds, get ) => {
	const pat = get.pattern( patId ),
		keys = keyIds.reduce( ( obj, id ) => {
			obj[ id ] = { selected: true };
			return obj;
		}, {} );

	return [
		{ keys: { [ pat.keys ]: keys } },
		[ "keys", "selectKeys", pat.name, keyIds.length ],
	];
};

DAWCore.actions.toggleChannel = ( id, get ) => {
	const chan = get.channel( id ),
		toggle = !chan.toggle;

	return [
		{ channels: { [ id ]: { toggle } } },
		[ "channels", "toggleChannel", chan.name, toggle ],
	];
};

DAWCore.actions.toggleDrumrow = ( rowId, get ) => {
	const patName = DAWCore.common.getDrumrowName( rowId, get ),
		toggle = !get.drumrow( rowId ).toggle;

	return [
		{ drumrows: { [ rowId ]: { toggle } } },
		[ "drumrows", "toggleDrumrow", patName, toggle ],
	];
};

DAWCore.actions.toggleEffect = ( fxId, get ) => {
	const fx = get.effect( fxId ),
		toggle = !fx.toggle;

	return [
		{ effects: { [ fxId ]: { toggle } } },
		[ "effects", "toggleEffect", get.channel( fx.dest ).name, fx.type, toggle ],
	];
};

DAWCore.actions.toggleEnv = ( synthId, get ) => {
	const toggle = !get.synth( synthId ).env.toggle;

	return [
		{ synths: { [ synthId ]: { env: { toggle } } } },
		[ "synth", "toggleEnv", get.synth( synthId ).name, toggle ],
	];
};

DAWCore.actions.toggleLFO = ( synthId, get ) => {
	const toggle = !get.synth( synthId ).lfo.toggle;

	return [
		{ synths: { [ synthId ]: { lfo: { toggle } } } },
		[ "synth", "toggleLFO", get.synth( synthId ).name, toggle ],
	];
};

DAWCore.actions.toggleSoloDrumrow = ( rowId, get ) => {
	const patName = DAWCore.common.getDrumrowName( rowId, get ),
		[ someOn, drumrows ] = DAWCore.common.toggleSolo( rowId, get.drumrows() );

	return [
		{ drumrows },
		[ "drumrows", "toggleSoloDrumrow", patName, someOn ],
	];
};

DAWCore.actions.toggleSoloTrack = ( id, get ) => {
	const [ someOn, tracks ] = DAWCore.common.toggleSolo( id, get.tracks() );

	return [
		{ tracks },
		[ "tracks", "toggleSoloTrack", get.track( id ).name, someOn ],
	];
};

DAWCore.actions.toggleTrack = ( id, get ) => {
	const track = get.track( id ),
		toggle = !track.toggle;

	return [
		{ tracks: { [ id ]: { toggle } } },
		[ "tracks", "toggleTrack", track.name, toggle ],
	];
};

DAWCore.actions.unselectAllBlocks = get => {
	let len = 0;
	const blocks = Object.entries( get.blocks() ).reduce( ( obj, [ id, blc ] ) => {
			if ( blc.selected ) {
				++len;
				obj[ id ] = { selected: false };
			}
			return obj;
		}, {} );

	return [
		{ blocks },
		[ "blocks", "unselectAllBlocks", len ],
	];
};

DAWCore.actions.unselectAllKeys = ( patId, get ) => {
	let len = 0;
	const pat = get.pattern( patId ),
		keysObj = Object.entries( get.keys( pat.keys ) ).reduce( ( obj, [ id, key ] ) => {
			if ( key.selected ) {
				++len;
				obj[ id ] = { selected: false };
			}
			return obj;
		}, {} );

	return [
		{ keys: { [ pat.keys ]: keysObj } },
		[ "keys", "unselectAllKeys", pat.name, len ],
	];
};

DAWCore.actions.unselectBlock = id => {
	return [
		{ blocks: { [ id ]: { selected: false } } },
		[ "blocks", "unselectBlock" ],
	];
};

DAWCore.actions.unselectKey = ( patId, keyId, get ) => {
	const pat = get.pattern( patId );

	return [
		{ keys: { [ pat.keys ]: { [ keyId ]: { selected: false } } } },
		[ "keys", "unselectKey", pat.name ],
	];
};

DAWCore.prototype.abortWAVExport = function() {
	if ( this.ctx instanceof OfflineAudioContext ) {
		this.composition.stop();
	}
};

DAWCore.prototype.addComposition = function( cmp, opt ) {
	const cpy = GSUtils.jsonCopy( cmp );

	cpy.options = Object.freeze( {
		saveMode: "local",
		...opt,
	} );
	this.cmps[ cpy.options.saveMode ].set( cpy.id, cpy );
	this._call( "compositionAdded", cpy );
	this._call( "compositionSavedStatus", cpy, true );
	return Promise.resolve( cpy );
};

// a read check is missing somewhere...

DAWCore.prototype.addCompositionByBlob = function( blob, opt ) {
	return new Promise( ( res, rej ) => {
		const rd = new FileReader();

		rd.onload = () => {
			this.addCompositionByJSON( rd.result, opt ).then( res, rej );
		};
		rd.readAsText( blob );
	} );
};

DAWCore.prototype.addCompositionByJSON = function( json, opt ) {
	return new Promise( ( res, rej ) => {
		try {
			const cmp = JSON.parse( json );

			this.addComposition( cmp, opt ).then( res, rej );
		} catch ( e ) {
			rej( e );
		}
	} );
};

DAWCore.prototype.addCompositionByURL = function( url, opt ) {
	return fetch( url )
		.then( res => {
			if ( !res.ok ) {
				throw `The file is not accessible: ${ url }`;
			}
			return res.json();
		} )
		.then(
			cmp => this.addComposition( cmp, opt ),
			e => { throw e; }
		);
};

DAWCore.prototype.addCompositionsFromLocalStorage = function() {
	return Promise.all( DAWCore.LocalStorage
		.getAll().map( cmp => this.addComposition( cmp ) ) );
};

DAWCore.prototype.addNewComposition = function( opt ) {
	return this.addComposition(
		DAWCore.json.composition( this.env, GSUtils.uuid() ), opt );
};

DAWCore.prototype.closeComposition = function() {
	if ( this.composition.loaded ) {
		const cmp = this.cmps[ this.get.saveMode() ].get( this.get.id() );

		this.stop();
		this.pianoroll.clearLoop();
		this.pianoroll.setCurrentTime( 0 );
		this.composition.setCurrentTime( 0 );
		this._stopLoop();
		this._call( "compositionClosed", cmp );
		this.composition.unload();
		this.history.empty();
		this.buffers.empty();
		if ( !cmp.savedAt ) {
			this._deleteComposition( cmp );
		}
	}
};

DAWCore.prototype.deleteComposition = function( saveMode, id ) {
	if ( this.composition.cmp && id === this.get.id() ) {
		this.closeComposition();
	}
	this._deleteComposition( this.cmps[ saveMode ].get( id ) );
};

DAWCore.prototype._deleteComposition = function( cmp ) {
	if ( cmp ) {
		const saveMode = cmp.options.saveMode;

		this.cmps[ saveMode ].delete( cmp.id );
		if ( saveMode === "local" ) {
			DAWCore.LocalStorage.delete( cmp.id );
		}
		this._call( "compositionDeleted", cmp );
	}
};

DAWCore.prototype.dropAudioFiles = function( files ) {
	const order = this.buffers.getSize();

	this.buffers.loadFiles( files ).then( ( { newBuffers, knownBuffers, failedBuffers } ) => {
		if ( newBuffers.length || knownBuffers.length ) {
			const cmpBuffers = this.get.buffers(),
				bufNextId = +DAWCore.common.getNextIdOf( cmpBuffers ),
				patNextId = +DAWCore.common.getNextIdOf( this.get.patterns() ),
				buffersLoaded = {};

			if ( newBuffers.length ) {
				const obj = {};

				obj.buffers = {};
				obj.patterns = {};
				newBuffers.forEach( ( buf, i ) => {
					const dotind = buf.name.lastIndexOf( "." ),
						patname = dotind > -1 ? buf.name.substr( 0, dotind ) : buf.name,
						bufId = bufNextId + i;

					obj.buffers[ bufId ] = {
						type: buf.type,
						duration: buf.duration,
						hash: buf.hash,
					};
					obj.patterns[ patNextId + i ] = {
						type: "buffer",
						dest: "main",
						buffer: `${ bufId }`,
						duration: Math.ceil( buf.duration * ( this.get.bpm() / 60 ) ),
						name: patname,
						order: order + i,
					};
					buffersLoaded[ bufId ] = this.buffers.getBuffer( buf );
				} );
				this.callAction( "addBuffers", obj );
			}
			if ( knownBuffers.length ) {
				const bufmap = Object.entries( cmpBuffers )
						.reduce( ( map, [ idBuf, buf ] ) => {
							map.set( buf.hash, idBuf );
							return map;
						}, new Map() );

				knownBuffers.forEach( buf => {
					const idBuf = bufmap.get( buf.hash );

					buffersLoaded[ idBuf ] = this.buffers.getBuffer( buf );
				} );
			}
			this._call( "buffersLoaded", buffersLoaded );
		}
		if ( failedBuffers.length > 0 ) {
			console.log( "failedBuffers", failedBuffers );
			// show a popup
		}
	} );
};

DAWCore.prototype.exportCompositionToJSON = function( saveMode, id ) {
	const cmp = this.get.composition( saveMode, id );

	if ( cmp ) {
		const cpy = GSUtils.jsonCopy( cmp ),
			cpyFormated = DAWCore.Composition.epure( DAWCore.Composition.format( cpy ) );

		return {
			name: `${ cmp.name || "untitled" }.gs`,
			url: this._exportCompositionToJSON( cpyFormated ),
		};
	}
};

DAWCore._exportJSONTabs = {
	keys: 4,
	synths: 5,
	tracks: 3,
	blocks: 3,
	buffers: 3,
	channels: 3,
	patterns: 3,
	drumrows: 3,
};

DAWCore.prototype._exportCompositionToJSON = function( cmp ) {
	const delTabs = DAWCore._exportJSONTabs,
		reg = /^\t"(\w*)": {$/,
		lines = JSON.stringify( cmp, null, "\t" ).split( "\n" );
	let regTab,
		regTa2,
		delTabCurr;

	if ( DAWCore._URLToRevoke ) {
		URL.revokeObjectURL( DAWCore._URLToRevoke );
	}
	lines.forEach( ( line, i ) => {
		const res = reg.exec( line );

		if ( res ) {
			if ( delTabCurr = delTabs[ res[ 1 ] ] ) {
				regTab = new RegExp( `^\\t{${ delTabCurr }}` );
				regTa2 = new RegExp( `^\\t{${ delTabCurr - 1 }}\\}` );
			}
		}
		if ( delTabCurr ) {
			lines[ i ] = lines[ i ].replace( regTab, "~" ).replace( regTa2, "~}" );
		}
	} );
	return DAWCore._URLToRevoke = URL.createObjectURL( new Blob( [
		lines.join( "\n" ).replace( /\n~/g, " " ) ] ) );
};

DAWCore.prototype.exportCompositionToWAV = function() {
	const ctx = this.ctx,
		gain = this.destination.getGain(),
		dur = Math.ceil( this.get.duration() * 60 / this.get.bpm() ) || 1,
		ctxOff = new OfflineAudioContext( 2, dur * ctx.sampleRate | 0, ctx.sampleRate );

	this.stop();
	if ( DAWCore._URLToRevoke ) {
		URL.revokeObjectURL( DAWCore._URLToRevoke );
	}
	this.setCtx( ctxOff );
	this.destination.setGain( 1 );
	this.composition.play();
	return ctxOff.startRendering().then( buffer => {
		const pcm = gswaEncodeWAV.encode( buffer, { float32: true } ),
			url = URL.createObjectURL( new Blob( [ pcm ] ) );

		this.composition.stop();
		this.setCtx( ctx );
		this.destination.setGain( gain );
		DAWCore._URLToRevoke = url;
		return {
			url,
			name: `${ this.get.name() || "untitled" }.wav`,
		};
	} );
};

DAWCore.prototype.liveChangeChannel = function( id, prop, val ) {
	this.composition._wamixer.change( { channels: { [ id ]: { [ prop ]: val } } } );
};

DAWCore.prototype.liveChangeEffect = function( fxId, prop, val ) {
	this.composition._waeffects.liveChangeFxProp( fxId, prop, val );
};

DAWCore.prototype.liveChangeSynth = function( id, obj ) {
	this.composition._synths.get( id ).change( obj );
};

DAWCore.prototype.newComposition = function( opt ) {
	const cmp = DAWCore.json.composition( this.env, GSUtils.uuid() );

	return this.addComposition( cmp, opt )
		.then( cmp => this.composition.load( cmp ) )
		.then( cmp => this._compositionOpened( cmp ) );
};

DAWCore.prototype.openComposition = function( saveMode, id ) {
	const cmp = this.get.composition( saveMode, id );

	if ( cmp ) {
		if ( this.composition.loaded ) {
			this.closeComposition();
		}
		return ( this.get.composition( saveMode, id ) // 1.
			? Promise.resolve( cmp )
			: this.addNewComposition( { saveMode } ) )
				.then( cmp => this.composition.load( cmp ) )
				.then( cmp => this._compositionOpened( cmp ) );
	}
};

DAWCore.prototype._compositionOpened = function( cmp ) {
	this.compositionFocus();
	this._call( "compositionOpened", cmp );
	this._startLoop();
	return cmp;
};

/*
1. Why don't we use `cmp` instead of recalling .get.composition() ?
   Because the `cmp` could have been delete in .closeComposition()
   if the composition was a new untitled composition.
*/

DAWCore.prototype.saveComposition = function() {
	const actSave = this.composition._actionSavedOn;

	if ( this.composition.save() ) {
		const cmp = this.get.cmp(),
			id = this.get.id();

		if ( this.get.saveMode() === "local" ) {
			this.cmps.local.set( id, cmp );
			DAWCore.LocalStorage.put( id, cmp );
			this._call( "compositionSavedStatus", cmp, true );
		} else {
			this.composition._saved = false;
			this._call( "compositionLoading", cmp, true );
			( this._call( "compositionSavingPromise", cmp )
			|| Promise.resolve( cmp ) )
				.finally( this._call.bind( this, "compositionLoading", cmp, false ) )
				.then( res => {
					this.composition._saved = true;
					this.cmps.cloud.set( id, cmp );
					this._call( "compositionSavedStatus", cmp, true );
					return res;
				}, err => {
					this.composition._actionSavedOn = actSave;
					this._call( "compositionSavedStatus", cmp, false );
					throw err;
				} );
		}
	}
};

class GSDrums {
	constructor() {
		const uiDrums = document.createElement( "gsui-drums" ),
			uiDrumrows = uiDrums.drumrows,
			dataDrums = new DAWCore.controllers.drums( {
				dataCallbacks: {
					addDrum: ( id, drum ) => uiDrums.addDrum( id, drum ),
					addDrumcut: ( id, drumcut ) => uiDrums.addDrumcut( id, drumcut ),
					changeDrum: ( id, prop, val ) => uiDrums.changeDrum( id, prop, val ),
					removeDrum: id => uiDrums.removeDrum( id ),
					removeDrumcut: id => uiDrums.removeDrumcut( id ),
				},
			} ),
			dataDrumrows = new DAWCore.controllers.drumrows( {
				dataCallbacks: {
					addDrumrow: id => {
						uiDrumrows.add( id, uiDrums.createDrumrow( id ) );
						this._setPropFilter( id, "gain" );
					},
					removeDrumrow: id => uiDrumrows.remove( id ),
					changeDrumrow: ( id, prop, val ) => {
						switch ( prop ) {
							default:
								uiDrumrows.change( id, prop, val );
								break;
							case "pattern":
								uiDrumrows.change( id, prop, this._svgManager.createSVG( val ) );
							break;
							case "duration": {
								const patId = this._dawcore.get.drumrow( id ).pattern,
									bufId = this._dawcore.get.pattern( patId ).buffer;

								uiDrumrows.change( id, prop, this._dawcore.get.buffer( bufId ).duration );
							} break;
						}
					},
				},
			} );

		this.rootElement = uiDrums;
		this.timeline = uiDrums._win._elTimeline;
		this._uiDrums = uiDrums;
		this._uiDrumrows = uiDrumrows;
		this._dataDrums = dataDrums;
		this._dataDrumrows = dataDrumrows;
		this._dawcore =
		this._drumsId =
		this._patternId =
		this._svgManager = null;
		Object.seal( this );

		uiDrumrows.addEventListener( "gsuiEvents", e => {
			const d = e.detail;

			switch ( d.eventName ) {
				case "change": this._dawcore.callAction( ...d.args ); break;
				case "propFilter": this._setPropFilter( ...d.args ); break;
				case "propFilters": this._setAllPropFilters( ...d.args ); break;
				case "liveStopDrum": this._dawcore.drums.stopLiveDrum( ...d.args ); break;
				case "liveStartDrum": this._dawcore.drums.startLiveDrum( ...d.args ); break;
				case "liveChangeDrumrow": this._dawcore.drums.changeLiveDrumrow( ...d.args ); break;
				default: return;
			}
			e.stopPropagation();
		} );
		uiDrums.addEventListener( "gsuiEvents", e => {
			const d = e.detail;

			switch ( d.eventName ) {
				case "change": {
					const [ act, ...args ] = d.args;

					this._dawcore.callAction( act, this._patternId, ...args );
				} break;
				case "input":
					this._uiDrumrows.setDrumPropValue( d.args[ 0 ], d.args[ 2 ], d.args[ 3 ] );
					break;
				case "inputEnd":
					this._uiDrumrows.removeDrumPropValue( ...d.args );
					break;
				case "changeLoop": {
					const [ a, b ] = d.args;

					a !== false
						? this._dawcore.drums.setLoop( a, b )
						: this._dawcore.drums.clearLoop();
				} break;
				case "changeCurrentTime":
					this._dawcore.drums.setCurrentTime( d.args[ 0 ] );
					break;
				default: return;
			}
			e.stopPropagation();
		} );
		this._uiDrums.toggleShadow( true );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	selectPattern( id ) {
		if ( id !== this._patternId ) {
			this._patternId = id;
			this._drumsId = null;
			this._dataDrums.clear();
			this._uiDrums.toggleShadow( !id );
			if ( id ) {
				const pat = this._dawcore.get.pattern( id ),
					drums = this._dawcore.get.drums( pat.drums );

				this._drumsId = pat.drums;
				this._dataDrums.change( drums );
			}
		}
	}
	setWaveforms( svgManager ) {
		this._svgManager = svgManager;
	}
	onstartdrum( rowId ) {
		this._uiDrumrows.playRow( rowId );
	}
	onstopdrumrow( rowId ) {
		this._uiDrumrows.stopRow( rowId );
	}
	change( obj ) {
		const drmObj = obj.drums && obj.drums[ this._drumsId ];

		this._dataDrumrows.change( obj );
		if ( obj.drumrows ) {
			this._uiDrums.drumrows.reorderDrumrows( obj.drumrows );
		}
		if ( "beatsPerMeasure" in obj || "stepsPerBeat" in obj ) {
			const bPM = obj.beatsPerMeasure || this._dawcore.get.beatsPerMeasure(),
				sPB = obj.stepsPerBeat || this._dawcore.get.stepsPerBeat();

			this._uiDrums.timeSignature( bPM, sPB );
		}
		if ( drmObj ) {
			this._dataDrums.change( drmObj );
		}
		if ( "patternDrumsOpened" in obj ) {
			this.selectPattern( obj.patternDrumsOpened );
		}
	}
	clear() {
		this.selectPattern( null );
		this._dataDrumrows.clear();
	}

	// .........................................................................
	setFontSize( fs ) {
		this._uiDrums.setFontSize( fs );
	}
	setPxPerBeat( ppb ) {
		this._uiDrums.setPxPerBeat( ppb );
	}
	currentTime( beat ) {
		this._uiDrums.currentTime( beat );
	}
	loop( a, b ) {
		this._uiDrums.loop( a, b );
	}

	// .........................................................................
	_setPropFilter( rowId, prop ) {
		const propValues = Object.entries( this._dawcore.get.drums( this._drumsId ) )
				.filter( ( [, drm ] ) => drm.row === rowId && "gain" in drm )
				.map( ( [ id, drm ] ) => [ id, drm[ prop ] ] );

		this._uiDrumrows.setPropFilter( rowId, prop );
		this._uiDrums.setPropValues( rowId, prop, propValues );
	}
	_setAllPropFilters( prop ) {
		Object.keys( this._dawcore.get.drumrows() )
			.forEach( id => this._setPropFilter( id, prop ) );
	}
}

Object.freeze( GSDrums );

class GSEffects {
	constructor() {
		const uiEffects = new gsuiEffects(),
			ctrlEffects = new DAWCore.controllers.effects( {
				dataCallbacks: {
					addEffect: ( id, obj ) => uiEffects.addEffect( id, obj ),
					removeEffect: id => uiEffects.removeEffect( id ),
					changeEffect: ( id, prop, val ) => uiEffects.changeEffect( id, prop, val ),
					changeEffectData: ( id, obj ) => this._changeEffectData( id, obj ),
				},
			} );

		this.rootElement = uiEffects;
		this._ctrlEffects = ctrlEffects;
		this._dawcore = null;
		this._destFilter = "main";
		Object.seal( this );

		uiEffects.askData = ( fxId, fxType, dataType, ...args ) => {
			if ( fxType === "filter" && dataType === "curve" ) {
				const wafx = this._dawcore.get.audioEffect( fxId );

				return wafx && wafx.updateResponse( args[ 0 ] );
			}
		};
		GSUI.listenEvent( uiEffects, {
			gsuiEffects: {
				liveChangeEffect: d => {
					this._dawcore.liveChangeEffect( ...d.args );
				},
				addEffect: d => {
					d.args.unshift( this._destFilter );
					this._dawcore.callAction( "addEffect", ...d.args );
				},
				default: d => {
					this._dawcore.callAction( d.eventName, ...d.args );
				},
			},
		} );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	getDestFilter() {
		return this._destFilter;
	}
	setDestFilter( dest ) {
		this._destFilter = dest;
		this._ctrlEffects.setDestFilter( dest );
	}
	change( obj ) {
		this._ctrlEffects.change( obj );
		if ( obj.effects ) {
			this.rootElement.reorderEffects( obj.effects );
		}
	}
	clear() {
		this._ctrlEffects.clear();
	}

	// .........................................................................
	_changeEffectData( id, obj ) {
		const uiFx = this.rootElement._fxsHtml.get( id ).uiFx;

		Object.entries( obj ).forEach( kv => GSUI.setAttribute( uiFx, ...kv ) );
		if ( uiFx.updateWave ) {
			uiFx.updateWave();
		}
	}
}

Object.freeze( GSEffects );

class GSMixer {
	constructor() {
		const uiMixer = new gsuiMixer( {
				oninput: this._oninput.bind( this ),
				onchange: this._onchange.bind( this ),
				onselectChan: this._onselectChan.bind( this ),
			} ),
			ctrlMixer = new DAWCore.controllers.mixer( {
				dataCallbacks: {
					addChannel: ( id, chan ) => uiMixer.addChannel( id, chan ),
					removeChannel: id => uiMixer.removeChannel( id ),
					renameChannel: ( id, name ) => uiMixer.renameChannel( id, name ),
					redirectChannel: ( id, dest ) => uiMixer.redirectChannel( id, dest ),
					toggleChannel: ( id, b ) => uiMixer.toggleChannel( id, b ),
					reorderChannel: ( id, n ) => uiMixer.reorderChannel( id, n ),
					changePanChannel: ( id, val ) => uiMixer.changePanChannel( id, val ),
					changeGainChannel: ( id, val ) => uiMixer.changeGainChannel( id, val ),
				},
			} );

		this.rootElement = uiMixer.rootElement;
		this.onselectChan = null;
		this._uiMixer = uiMixer;
		this._ctrlMixer = ctrlMixer;
		this._dawcore = null;
		Object.seal( this );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	clear() {
		this._ctrlMixer.clear();
	}
	change( obj ) {
		this._ctrlMixer.change( obj );
		if ( obj.channels ) {
			this._uiMixer.reorderChannels( obj.channels );
		}
	}
	resize() {
		this._uiMixer.resized();
	}
	resizing() {
		this._uiMixer.resized();
	}
	attached() {
		this._uiMixer.attached();
	}
	updateAudioData( chanId, ldata, rdata ) {
		this._uiMixer.updateAudioData( chanId, ldata, rdata );
	}
	selectChannel( id ) {
		this._uiMixer.selectChannel( id );
	}
	getSelectedChannelId() {
		return this._uiMixer.getSelectedChannelId();
	}

	// .........................................................................
	_oninput( id, prop, val ) {
		this._dawcore.liveChangeChannel( id, prop, val );
	}
	_onchange( act, ...args ) {
		this._dawcore.callAction( act, ...args );
	}
	_onselectChan( id ) {
		if ( this.onselectChan ) {
			this.onselectChan( id );
		}
	}
}

Object.freeze( GSMixer );

class GSPatternroll {
	constructor() {
		const uiPatternroll = new gsuiPatternroll( {
				getData: () => dataBlocks.data,
				onchange: this._onchange.bind( this ),
				onaddBlock: this._onaddBlock.bind( this ),
				oneditBlock: this._oneditBlock.bind( this ),
			} ),
			dataTracks = new DAWCore.controllers.tracks( {
				dataCallbacks: {
					addTrack: id => uiPatternroll.addTrack( id ),
					removeTrack: id => uiPatternroll.removeTrack( id ),
					toggleTrack: ( id, b ) => uiPatternroll.toggleTrack( id, b ),
					renameTrack: ( id, s ) => uiPatternroll.renameTrack( id, s ),
					reorderTrack: ( id, n ) => uiPatternroll.reorderTrack( id, n ),
				}
			} ),
			dataBlocks = new DAWCore.controllers.blocks( {
				dataCallbacks: {
					addBlock: ( id, blc ) => uiPatternroll.addBlock( id, blc ),
					removeBlock: id => uiPatternroll.removeBlock( id ),
					changeBlockProp: ( id, prop, val ) => uiPatternroll.changeBlockProp( id, prop, val ),
					updateBlockViewBox: ( id, blc ) => uiPatternroll.updateBlockViewBox( id, blc ),
				},
			} );

		this.rootElement = uiPatternroll.rootElement;
		this.timeline = uiPatternroll.timeline;
		this._uiRoll = uiPatternroll;
		this._dataTracks = dataTracks;
		this._dataBlocks = dataBlocks;
		this._dawcore =
		this._svgForms = null;
		Object.seal( this );

		this.rootElement.addEventListener( "gsuiEvents", this._ongsuiEvents.bind( this ) );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	setSVGForms( svgForms ) {
		this._svgForms = svgForms;
	}
	change( obj ) {
		this._dataTracks.change( obj );
		this._dataBlocks.change( obj );
		if ( "loopA" in obj || "loopB" in obj ) {
			this._uiRoll.loop(
				this._dawcore.get.loopA(),
				this._dawcore.get.loopB() );
		}
		if ( "beatsPerMeasure" in obj || "stepsPerBeat" in obj ) {
			this._uiRoll.timeSignature(
				this._dawcore.get.beatsPerMeasure(),
				this._dawcore.get.stepsPerBeat() );
		}
	}
	clear() {
		this._dataBlocks.clear();
		this._dataTracks.clear();
	}

	// .........................................................................
	attached() {
		this._uiRoll.attached();
	}
	resized() {
		this._uiRoll.resized();
	}
	currentTime( t ) {
		this._uiRoll.currentTime( t );
	}
	loop( a, b ) {
		this._uiRoll.loop( a, b );
	}
	getBlocks() {
		return this._uiRoll.getBlocks();
	}

	// .........................................................................
	_ongsuiEvents( e ) {
		const d = e.detail;

		switch ( d.component ) {
			case "gsuiTracklist":
				this._dawcore.callAction( d.eventName, ...d.args );
				break;
			case "gsuiTimeline":
				switch ( d.eventName ) {
					case "changeLoop":
						this._dawcore.callAction( "changeLoop", ...d.args );
						break;
					case "changeCurrentTime":
						this._dawcore.composition.setCurrentTime( d.args[ 0 ] );
						break;
				}
				break;
		}
		e.stopPropagation();
	}

	// .........................................................................
	_onchange( obj, ...args ) {
		switch ( obj ) { // tmp
			case "add": this._dawcore.callAction( "addBlock", ...args ); break;
			case "move": this._dawcore.callAction( "moveBlocks", ...args ); break;
			case "cropEnd": this._dawcore.callAction( "cropEndBlocks", ...args ); break;
			case "cropStart": this._dawcore.callAction( "cropStartBlocks", ...args ); break;
			case "duplicate": this._dawcore.callAction( "duplicateSelectedBlocks", ...args ); break;
			case "deletion": this._dawcore.callAction( "removeBlocks", ...args ); break;
			case "selection": this._dawcore.callAction( "selectBlocks", ...args ); break;
			case "unselection": this._dawcore.callAction( "unselectAllBlocks", ...args ); break;
			case "unselectionOne": this._dawcore.callAction( "unselectBlock", ...args ); break;
		}
	}
	_oneditBlock( _id, obj, blc ) {
		if ( blc._gsuiSVGform ) {
			const pat = this._dawcore.get.pattern( obj.pattern );

			this._svgForms[ pat.type ].setSVGViewbox( blc._gsuiSVGform, obj.offset, obj.duration, this._dawcore.get.bpm() / 60 );
		}
	}
	_onaddBlock( id, obj, blc ) {
		const pat = this._dawcore.get.pattern( obj.pattern ),
			SVGs = this._svgForms[ pat.type ],
			svg = SVGs.createSVG( obj.pattern );

		blc._gsuiSVGform = svg;
		blc.children[ 3 ].append( svg );
		SVGs.setSVGViewbox( svg, obj.offset, obj.duration, this._dawcore.get.bpm() / 60 );
		blc.ondblclick = () => this._dawcore.callAction( "openPattern", obj.pattern );
		blc.querySelector( ".gsuiPatternroll-block-name" ).textContent = pat.name;
	}
}

Object.freeze( GSPatternroll );

class GSPatterns {
	constructor() {
		const uiPatterns = GSUI.createElement( "gsui-patterns" ),
			svgForms = Object.freeze( {
				keys: new gsuiKeysforms(),
				drums: new gsuiDrumsforms(),
				buffer: new gsuiWaveforms(),
				bufferHD: new gsuiWaveforms(),
			} );

		uiPatterns.onpatternDataTransfer = elPat => {
			const id = elPat.dataset.id;

			return `${ id }:${ this._dawcore.get.pattern( id ).duration }`;
		};
		uiPatterns.onchange = ( act, ...args ) => {
			if ( act in DAWCore.actions ) {
				this._dawcore.callAction( act, ...args );
			} else {
				lg( "GSPatterns.onchange", act, ...args );
			}
		};
		this.data = Object.freeze( {
			synths: {},
			patterns: {},
			channels: {},
		} );
		this.rootElement = uiPatterns;
		this.svgForms = svgForms;
		this._buffers = {};
		this._dawcore = null;
		this._uiPatterns = uiPatterns;
		this._synthsCrud = GSUtils.createUpdateDelete.bind( null, this.data.synths,
			this._createSynth.bind( this ),
			this._updateSynth.bind( this ),
			this._deleteSynth.bind( this ) );
		this._patternsCrud = GSUtils.createUpdateDelete.bind( null, this.data.patterns,
			this._createPattern.bind( this ),
			this._updatePattern.bind( this ),
			this._deletePattern.bind( this ) );
		this._channelsCrud = GSUtils.createUpdateDelete.bind( null, this.data.channels,
			this._createChannel.bind( this ),
			this._updateChannel.bind( this ),
			this._deleteChannel.bind( this ) );
		Object.seal( this );

		svgForms.bufferHD.hdMode( true );
		svgForms.bufferHD.setDefaultViewbox( 260, 48 );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	clear() {
		Object.keys( this.data.patterns ).forEach( this._deletePattern, this );
		Object.keys( this.data.synths ).forEach( this._deleteSynth, this );
		Object.keys( this._buffers ).forEach( id => delete this._buffers[ id ] );
		this.svgForms.keys.empty();
		this.svgForms.drums.empty();
		this.svgForms.buffer.empty();
		this.svgForms.bufferHD.empty();
	}
	bufferLoaded( buffers ) {
		const pats = Object.entries( this._dawcore.get.patterns() ),
			bufToPat = pats.reduce( ( map, [ id, pat ] ) => {
				map[ pat.buffer ] = id;
				return map;
			}, {} );

		Object.entries( buffers ).forEach( ( [ idBuf, buf ] ) => {
			this._buffers[ idBuf ] = buf;
			this.svgForms.buffer.update( bufToPat[ idBuf ], buf.buffer );
			this.svgForms.bufferHD.update( bufToPat[ idBuf ], buf.buffer );
		} );
	}
	change( obj ) {
		this._synthsCrud( obj.synths );
		this._patternsCrud( obj.patterns );
		this._channelsCrud( obj.channels );
		if ( obj.keys || obj.drums || obj.drumrows || obj.patterns ) {
			Object.entries( this._dawcore.get.patterns() ).forEach( ( [ id, pat ] ) => {
				if (
					( pat.type === "drums" && ( obj.drumrows || obj.drums?.[ pat.drums ] || obj.patterns?.[ id ]?.duration ) ) ||
					( pat.type === "keys" && ( obj.keys?.[ pat.keys ] || obj.patterns?.[ id ]?.duration ) )
				) {
					this._updatePatternContent( id );
				}
			} );
		}
		if ( obj.patterns ) {
			this._uiPatterns.reorderPatterns( obj.patterns );
		}
		if ( "synthOpened" in obj ) {
			this._uiPatterns.selectSynth( obj.synthOpened );
		}
		if ( "patternDrumsOpened" in obj ) {
			this._uiPatterns.selectPattern( "drums", obj.patternDrumsOpened );
		}
		if ( "patternKeysOpened" in obj ) {
			this._uiPatterns.selectPattern( "keys", obj.patternKeysOpened );
		}
	}

	// .........................................................................
	_updatePatternContent( id ) {
		const get = this._dawcore.get,
			pat = get.pattern( id ),
			elPat = this._uiPatterns._getPattern( id );

		if ( elPat ) {
			const type = pat.type;

			if ( type === "keys" ) {
				this.svgForms.keys.update( id, get.keys( pat.keys ), pat.duration );
			} else if ( type === "drums" ) {
				this.svgForms.drums.update( id, get.drums( pat.drums ), get.drumrows(), pat.duration, get.stepsPerBeat() );
			} else if ( type === "buffer" ) {
				const buf = this._buffers[ pat.buffer ];

				if ( buf ) {
					this.svgForms.buffer.update( id, buf.buffer );
					this.svgForms.bufferHD.update( id, buf.buffer );
				}
			}
			if ( type !== "buffer" ) {
				this.svgForms[ type ].setSVGViewbox( elPat.querySelector( "svg" ), 0, pat.duration );
			}
		}
	}

	// .........................................................................
	_createSynth( id, obj ) {
		this.data.synths[ id ] = GSUtils.jsonCopy( obj );
		this._uiPatterns.addSynth( id );
		this._updateSynth( id, obj );
	}
	_updateSynth( id, obj ) {
		const dat = this.data.synths[ id ];

		Object.entries( obj ).forEach( ( [ prop, val ] ) => {
			dat[ prop ] = val;
			this._uiPatterns.changeSynth( id, prop, val );
		} );
		if ( "dest" in obj ) {
			this._uiPatterns.changeSynth( id, "destName", this._dawcore.get.channel( obj.dest ).name );
		}
	}
	_deleteSynth( id ) {
		delete this.data.synths[ id ];
		this._uiPatterns.deleteSynth( id );
	}

	// .........................................................................
	_createPattern( id, obj ) {
		const isBuf = obj.type === "buffer",
			SVG = this.svgForms[ isBuf ? "bufferHD" : obj.type ];

		this.data.patterns[ id ] = GSUtils.jsonCopy( obj );
		SVG.add( id );
		if ( isBuf ) {
			const buf = this._buffers[ obj.buffer ];

			this.svgForms.buffer.add( id );
			if ( buf ) {
				this.svgForms.buffer.update( id, buf.buffer );
				SVG.update( id, buf.buffer );
			}
		}
		this._uiPatterns.addPattern( id, obj );
		this._updatePattern( id, obj );
		this._uiPatterns.appendPatternSVG( id, SVG.createSVG( id ) );
	}
	_updatePattern( id, obj ) {
		const dat = this.data.patterns[ id ];

		Object.entries( obj ).forEach( ( [ prop, val ] ) => {
			dat[ prop ] = val;
			this._uiPatterns.changePattern( id, prop, val );
		} );
		if ( "dest" in obj ) {
			this._uiPatterns.changePattern( id, "destName", this._dawcore.get.channel( obj.dest ).name );
		}
	}
	_deletePattern( id ) {
		const pat = this.data.patterns[ id ];

		delete this.data.patterns[ id ];
		this.svgForms[ pat.type ].delete( id );
		if ( pat.type === "buffer" ) {
			this.svgForms.bufferHD.delete( id );
		}
		this._uiPatterns.deletePattern( id );
	}

	// .........................................................................
	_createChannel( id, obj ) {
		this.data.channels[ id ] = obj.name;
		this._uiPatterns.addChannel( id, obj.name );
	}
	_updateChannel( id, obj ) {
		if ( "name" in obj ) {
			this._uiPatterns.updateChannel( id, obj.name );
		}
	}
	_deleteChannel( id ) {
		delete this.data.channels[ id ];
		this._uiPatterns.deleteChannel( id );
	}
}

Object.freeze( GSPatterns );

class GSPianoroll {
	constructor() {
		const uiPianoroll = new gsuiPianoroll( {
				getData: () => this._dataKeys.data,
				onchange: this._onchange.bind( this ),
			} ),
			dataKeys = new DAWCore.controllers.keys( {
				dataCallbacks: {
					addKey: ( id, blc ) => uiPianoroll.addKey( id, blc ),
					removeKey: id => uiPianoroll.removeKey( id ),
					changeKeyProp: ( id, prop, val ) => uiPianoroll.changeKeyProp( id, prop, val ),
				},
			} );

		this.rootElement = uiPianoroll.rootElement;
		this.timeline = uiPianoroll.timeline;
		this._uiRoll = uiPianoroll;
		this._dataKeys = dataKeys;
		this._dawcore =
		this._keysId =
		this._patternId = null;
		Object.seal( this );

		uiPianoroll.uiKeys.onkeydown = midi => this._dawcore.pianoroll.liveKeydown( midi );
		uiPianoroll.uiKeys.onkeyup = midi => this._dawcore.pianoroll.liveKeyup( midi );
		this.rootElement.addEventListener( "gsuiEvents", this._ongsuiEvents.bind( this ) );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	selectPattern( id ) {
		if ( id !== this._patternId ) {
			this._patternId = id;
			this._keysId = null;
			this._dataKeys.clear();
			this._uiRoll.reset();
			// this._uiRoll.toggleShadow( !id );
			if ( id ) {
				const pat = this._dawcore.get.pattern( id ),
					keys = this._dawcore.get.keys( pat.keys );

				this._keysId = pat.keys;
				this._dataKeys.change( keys );
				this._uiRoll.scrollToKeys();
			}
		}
	}
	change( obj ) {
		if ( "beatsPerMeasure" in obj || "stepsPerBeat" in obj ) {
			this._uiRoll.timeSignature(
				this._dawcore.get.beatsPerMeasure(),
				this._dawcore.get.stepsPerBeat() );
		}
		if ( "patternKeysOpened" in obj ) {
			this.selectPattern( obj.patternKeysOpened );
		} else {
			const keys = obj.keys && obj.keys[ this._keysId ];

			if ( keys ) {
				this._dataKeys.change( keys );
			}
		}
	}
	clear() {
		this._keysId =
		this._patternId = null;
		this._dataKeys.clear();
		this._uiRoll.reset();
	}
	getUIKeys() {
		return this._uiRoll.uiKeys;
	}

	// .........................................................................
	attached() {
		this._uiRoll.attached();
		this._uiRoll.octaves( 1, 7 );
	}
	currentTime( t ) {
		this._uiRoll.currentTime( t );
	}
	loop( a, b ) {
		this._uiRoll.loop( a, b );
	}

	// .........................................................................
	_ongsuiEvents( e ) {
		const d = e.detail;

		switch ( d.component ) {
			case "gsuiPianoroll":
				switch ( d.eventName ) {
					case "changeKeysProps":
						this._dawcore.callAction( "changeKeysProps", this._patternId, ...d.args );
						break;
				}
				break;
			case "gsuiTimeline":
				switch ( d.eventName ) {
					case "changeLoop":
						d.args[ 0 ] !== false
							? this._dawcore.pianoroll.setLoop( ...d.args )
							: this._dawcore.pianoroll.clearLoop();
						break;
					case "changeCurrentTime":
						this._dawcore.pianoroll.setCurrentTime( d.args[ 0 ] );
						break;
				}
				break;
		}
		e.stopPropagation();
	}

	// .........................................................................
	_onchange( obj, ...args ) {
		switch ( obj ) { // tmp
			case "add": this._dawcore.callAction( "addKey", this._patternId, ...args ); break;
			case "move": this._dawcore.callAction( "moveKeys", this._patternId, ...args ); break;
			case "clone": this._dawcore.callAction( "cloneSelectedKeys", this._patternId, ...args ); break;
			case "remove": this._dawcore.callAction( "removeKeys", this._patternId, ...args ); break;
			case "cropEnd": this._dawcore.callAction( "cropEndKeys", this._patternId, ...args ); break;
			case "redirect": this._dawcore.callAction( "redirectKey", this._patternId, ...args ); break;
			case "changeEnv": this._dawcore.callAction( "changeKeysEnv", this._patternId, ...args ); break;
			case "selection": this._dawcore.callAction( "selectKeys", this._patternId, ...args ); break;
			case "unselection": this._dawcore.callAction( "unselectAllKeys", this._patternId, ...args ); break;
			case "unselectionOne": this._dawcore.callAction( "unselectKey", this._patternId, ...args ); break;
		}
	}
}

Object.freeze( GSPianoroll );

class GSSynth {
	constructor() {
		const uiSynth = document.createElement( "gsui-synthesizer" ),
			uiEnv = document.createElement( "gsui-envelope" ),
			uiLFO = document.createElement( "gsui-lfo" ),
			dataSynth = new DAWCore.controllers.synth( {
				dataCallbacks: {
					addOsc: ( id, osc ) => uiSynth.addOscillator( id, osc ),
					removeOsc: id => uiSynth.removeOscillator( id ),
					changeEnvProp: ( k, v ) => uiEnv.setAttribute( k, v ),
					changeLFOProp: ( k, v ) => uiLFO.setAttribute( k, v ),
					changeOscProp: ( id, k, v ) => uiSynth.getOscillator( id ).setAttribute( k, v ),
					updateEnvWave: () => uiEnv.updateWave(),
					updateLFOWave: () => uiLFO.updateWave(),
					updateOscWave: id => uiSynth.getOscillator( id ).updateWave(),
				},
			} );

		this.rootElement = uiSynth;
		this._uiEnv = uiEnv;
		this._uiLFO = uiLFO;
		this._dataSynth = dataSynth;
		this._dawcore =
		this._synthId = null;
		Object.seal( this );

		uiSynth.setEnvelope( uiEnv );
		uiSynth.setLFO( uiLFO );
		uiSynth.addEventListener( "gsuiEvents", e => {
			const d = e.detail,
				a = d.args,
				id = this._synthId,
				dc = this._dawcore;

			switch ( d.component ) {
				case "gsuiEnvelope":
					switch ( d.eventName ) {
						case "toggle": dc.callAction( "toggleEnv", id ); break;
						case "change": dc.callAction( "changeEnv", id, ...a ); break;
						case "liveChange": dc.liveChangeSynth( id, { env: { [ a[ 0 ] ]: a[ 1 ] } } ); break;
					}
					break;
				case "gsuiLFO":
					switch ( d.eventName ) {
						case "toggle": dc.callAction( "toggleLFO", id ); break;
						case "change": dc.callAction( "changeLFO", id, ...a ); break;
						case "liveChange": dc.liveChangeSynth( id, { lfo: { [ a[ 0 ] ]: a[ 1 ] } } ); break;
					}
					break;
				case "gsuiSynthesizer":
					switch ( d.eventName ) {
						case "addOscillator": dc.callAction( "addOscillator", id ); break;
						case "reorderOscillator": dc.callAction( "reorderOscillator", id, a[ 0 ] ); break;
					}
					break;
				case "gsuiOscillator": {
					const oscId = e.target.dataset.id;

					switch ( d.eventName ) {
						case "remove": dc.callAction( "removeOscillator", id, oscId ); break;
						case "change": dc.callAction( "changeOscillator", id, oscId, ...a ); break;
						case "liveChange": dc.liveChangeSynth( id, { oscillators: { [ oscId ]: { [ a[ 0 ] ]: a[ 1 ] } } } ); break;
					}
				} break;
			}
			e.stopPropagation();
		} );
	}

	// .........................................................................
	setDAWCore( core ) {
		this._dawcore = core;
	}
	setWaveList( arr ) {
		this.rootElement.setWaveList( arr );
	}
	selectSynth( id ) {
		if ( id !== this._synthId ) {
			this._synthId = id;
			this._dataSynth.clear();
			if ( id ) {
				this._dataSynth.change( this._dawcore.get.synth( id ) );
			}
		}
	}
	change( obj ) {
		const synObj = obj.synths && obj.synths[ this._synthId ],
			get = this._dawcore.get;

		if ( "beatsPerMeasure" in obj || "stepsPerBeat" in obj ) {
			this._uiEnv.timeSignature( get.beatsPerMeasure(), get.stepsPerBeat() );
			this._uiLFO.timeSignature( get.beatsPerMeasure(), get.stepsPerBeat() );
		}
		if ( synObj ) {
			this._dataSynth.change( synObj );
			if ( synObj.oscillators ) {
				this.rootElement.reorderOscillators( synObj.oscillators );
			}
		}
		if ( "synthOpened" in obj ) {
			this.selectSynth( obj.synthOpened );
		}
	}
	clear() {
		this._dataSynth.clear();
	}
}

Object.freeze( GSSynth );

class gswaLFO {
	constructor( ctx ) {
		const node = ctx.createGain();

		this.ctx = ctx;
		this.node = node;
		this._oscNode =
		this._ampNode = null;
		this.data = Object.seal( {
			toggle: false,
			when: 0,
			whenStop: 0,
			offset: 0,
			type: "",
			delay: 0,
			attack: 0,
			amp: 0,
			speed: 0,
		} );
		Object.seal( this );
	}

	// .........................................................................
	start( d ) {
		const data = this.data;

		data.toggle = d.toggle || false;
		data.when = d.when || this.ctx.currentTime;
		data.whenStop = d.whenStop
			? Math.max( d.when + d.delay + d.attack + .1, d.whenStop )
			: 0;
		data.offset = d.offset || 0;
		data.type = d.type || "sine";
		data.delay = d.delay || 0;
		data.attack = d.attack || 0;
		data.amp = "amp" in d ? d.amp : 1;
		data.speed = "speed" in d ? d.speed : 4;
		if ( data.toggle && !this._oscNode ) {
			this._start();
		}
	}
	destroy() {
		if ( this._oscNode ) {
			this._stop( 0 );
			this._oscNode.disconnect();
			this._ampNode.disconnect();
			this._oscNode =
			this._ampNode = null;
		}
	}
	change( obj ) {
		Object.assign( this.data, obj );
		if ( this.data.toggle ) {
			if ( !this._oscNode ) {
				this._start();
			} else {
				this._change( obj );
			}
		} else if ( this._oscNode ) {
			this.destroy();
		}
	}

	// .........................................................................
	_start() {
		const d = this.data,
			osc = this.ctx.createOscillator(),
			amp = this.ctx.createGain();

		this._oscNode = osc;
		this._ampNode = amp;
		this._setAmp();
		this._setType();
		this._setSpeed();
		osc.connect( amp ).connect( this.node.gain );
		osc.start( d.when + d.delay - d.offset );
		if ( d.whenStop > 0 ) {
			this._stop( d.whenStop );
		}
	}
	_stop( when ) {
		this._oscNode.frequency.cancelScheduledValues( when );
		this._ampNode.gain.cancelScheduledValues( when );
		this._oscNode.stop( when );
	}
	_change( obj ) {
		if ( "type" in obj ) {
			this._setType();
		}
		if ( "speed" in obj ) {
			this._oscNode.frequency.cancelScheduledValues( 0 );
			this._setSpeed();
		}
		if ( "when" in obj || "offset" in obj ||
			"delay" in obj || "attack" in obj || "amp" in obj
		) {
			this._ampNode.gain.cancelScheduledValues( 0 );
			this._setAmp();
		}
	}
	_setType() {
		this._oscNode.type = this.data.type;
	}
	_setSpeed() {
		this._oscNode.frequency.setValueAtTime( this.data.speed, this.ctx.currentTime );
	}
	_setAmp() {
		const d = this.data,
			now = this.ctx.currentTime,
			atTime = d.when + d.delay - d.offset;

		if ( now <= atTime && d.attack > 0 ) {
			this._ampNode.gain.setValueAtTime( 0, atTime );
			this._ampNode.gain.setValueCurveAtTime( new Float32Array( [ 0, d.amp ] ), atTime, d.attack );
		} else {
			this._ampNode.gain.setValueAtTime( d.amp, now );
		}
	}
}

Object.freeze( gswaLFO );

class gswaMixer {
	constructor() {
		this.ctx =
		this.connectedTo = null;
		this._chans = {};
		this._fftSize = 4096;
		this.audioDataL = new Uint8Array( this._fftSize / 2 );
		this.audioDataR = new Uint8Array( this._fftSize / 2 );
		this._ctrlMixer = new DAWCore.controllers.mixer( {
			dataCallbacks: {
				addChannel: this._addChan.bind( this ),
				removeChannel: this._removeChan.bind( this ),
				toggleChannel: this._toggleChan.bind( this ),
				redirectChannel: this._redirectChan.bind( this ),
				changePanChannel: this._updateChanPan.bind( this ),
				changeGainChannel: this._updateChanGain.bind( this ),
			},
		} );
		Object.seal( this );
	}

	setContext( ctx ) {
		this.disconnect();
		this.ctx = ctx;
		if ( "main" in this._ctrlMixer.data.channels ) {
			this._ctrlMixer.recall();
		} else {
			this._ctrlMixer.change( {
				channels: {
					main: {
						toggle: true,
						name: "main",
						gain: 1,
						pan: 0,
					},
				},
			} );
		}
	}
	change( obj ) {
		this._ctrlMixer.change( obj );
	}
	clear() {
		this._ctrlMixer.clear();
		this._ctrlMixer.change( {
			channels: {
				main: {
					toggle: true,
					name: "main",
					gain: 1,
					pan: 0,
				},
			},
		} );
	}
	connect( dest ) {
		this.disconnect();
		this._chans.main.output.connect( dest );
		this.connectedTo = dest;
	}
	disconnect() {
		if ( this._chans.main ) {
			this._chans.main.output.disconnect();
			this.connectedTo = null;
		}
	}
	getChanInput( id ) {
		return this._chans[ id ]?.input;
	}
	getChanOutput( id ) {
		return this._chans[ id ]?.pan.getInput();
	}
	fillAudioData( chanId ) {
		const nodes = this._chans[ chanId ];

		nodes.analyserL.getByteFrequencyData( this.audioDataL );
		nodes.analyserR.getByteFrequencyData( this.audioDataR );
	}

	// chan:
	_addChan( id ) {
		const ctx = this.ctx,
			pan = new gswaStereoPanner( ctx ),
			gain = ctx.createGain(),
			input = ctx.createGain(),
			output = ctx.createGain(),
			splitter = ctx.createChannelSplitter( 2 ),
			analyserL = ctx.createAnalyser(),
			analyserR = ctx.createAnalyser();

		analyserL.fftSize =
		analyserR.fftSize = this._fftSize;
		analyserL.smoothingTimeConstant =
		analyserR.smoothingTimeConstant = 0;
		input.connect( pan.getInput() );
		pan.connect( gain );
		gain.connect( output );
		gain.connect( splitter );
		splitter.connect( analyserL, 0 );
		splitter.connect( analyserR, 1 );
		this._chans[ id ] = {
			input, pan, gain, output, splitter, analyserL, analyserR,
			analyserData: new Uint8Array( analyserL.frequencyBinCount )
		};
		Object.entries( this._ctrlMixer.data.channels ).forEach( kv => {
			if ( kv[ 1 ].dest === id ) {
				this._redirectChan( kv[ 0 ], id );
			}
		} );
	}
	_redirectChan( id, val ) {
		this._chans[ id ].output.disconnect();
		if ( val in this._ctrlMixer.data.channels ) {
			this._chans[ id ].output.connect( this.getChanInput( val ) );
		}
	}
	_toggleChan( id, val ) {
		this._chans[ id ].gain.gain.setValueAtTime( val ? this._ctrlMixer.data.channels[ id ].gain : 0, this.ctx.currentTime );
	}
	_updateChanPan( id, val ) {
		this._chans[ id ].pan.setValueAtTime( val, this.ctx.currentTime );
	}
	_updateChanGain( id, val ) {
		this._chans[ id ].gain.gain.setValueAtTime( val, this.ctx.currentTime );
	}
	_removeChan( id ) {
		const nodes = this._chans[ id ];

		nodes.pan.disconnect();
		nodes.gain.disconnect();
		nodes.input.disconnect();
		nodes.output.disconnect();
		nodes.splitter.disconnect();
		delete this._chans[ id ];
	}
}

class gswaSynth {
	constructor() {
		const gsdata = new DAWCore.controllers.synth( {
				dataCallbacks: {
					addOsc: this._addOsc.bind( this ),
					removeOsc: this._removeOsc.bind( this ),
					changeOsc: this._changeOsc.bind( this ),
					changeLFO: this._changeLFO.bind( this ),
				},
			} );

		this._bps = 1;
		this.gsdata = gsdata;
		this.ctx =
		this.output = null;
		this.nyquist = 24000;
		this._startedKeys = new Map();
		Object.seal( this );
	}

	// Context, dis/connect
	// .........................................................................
	setContext( ctx ) {
		this.stopAllKeys();
		this.ctx = ctx;
		this.nyquist = ctx.sampleRate / 2;
		this.output = ctx.createGain();
		this.gsdata.recall();
	}
	setBPM( bpm ) {
		this._bps = bpm / 60;
	}
	change( obj ) {
		this.gsdata.change( obj );
	}

	// add/remove/update oscs
	// .........................................................................
	_removeOsc( id ) {
		this._startedKeys.forEach( key => {
			this._destroyOscNode( key.oscNodes.get( id ) );
			key.oscNodes.delete( id );
		} );
	}
	_addOsc( id, osc ) {
		this._startedKeys.forEach( k => k.oscNodes.set( id, this._createOscNode( k, id ) ) );
	}
	_changeOsc( id, obj ) {
		const now = this.ctx.currentTime,
			objEnt = Object.entries( obj );

		this._startedKeys.forEach( key => {
			const nodes = key.oscNodes.get( id );

			objEnt.forEach( ( [ prop, val ] ) => {
				switch ( prop ) {
					case "type": this._nodeOscSetType( nodes.oscNode, val ); break;
					case "pan": nodes.panNode.pan.setValueAtTime( val, now ); break;
					case "gain": nodes.gainNode.gain.setValueAtTime( val, now ); break;
					case "detune": nodes.oscNode.detune.setValueAtTime( val * 100, now ); break;
				}
			} );
		} );
	}
	_changeLFO( obj ) {
		const nobj = { ...obj };

		if ( "delay" in nobj ) { nobj.delay /= this._bps; }
		if ( "attack" in nobj ) { nobj.attack /= this._bps; }
		if ( "speed" in nobj ) { nobj.speed *= this._bps; }
		this._startedKeys.forEach( key => key.LFONode.change( nobj ) );
	}

	// start
	// .........................................................................
	startKey( blocks, when, off, dur ) {
		const id = ++gswaSynth._startedMaxId.value,
			blcsLen = blocks.length,
			blc0 = blocks[ 0 ][ 1 ],
			blcLast = blocks[ blcsLen - 1 ][ 1 ],
			blc0when = blc0.when,
			atTime = when - off,
			ctx = this.ctx,
			bps = this._bps,
			lfo = this.gsdata.data.lfo,
			oscs = this.gsdata.data.oscillators,
			key = Object.freeze( {
				when,
				off,
				dur,
				pan: blc0.pan,
				midi: blc0.key,
				gain: blc0.gain,
				lowpass: blc0.lowpass,
				highpass: blc0.highpass,
				attack: blc0.attack / bps || .005,
				release: blcLast.release / bps || .005,
				variations: [],
				oscNodes: new Map(),
				LFONode: new gswaLFO( ctx ),
				envGainNode: ctx.createGain(),
				gainNode: ctx.createGain(),
				panNode: ctx.createStereoPanner(),
				lowpassNode: ctx.createBiquadFilter(),
				highpassNode: ctx.createBiquadFilter(),
			} );

		if ( blcsLen > 1 ) {
			blocks.reduce( ( prev, [ , blc ] ) => {
				if ( prev ) {
					const prevWhen = prev.when - blc0when,
						when = ( prevWhen + prev.duration ) / bps;

					key.variations.push( {
						when,
						duration: ( blc.when - blc0when ) / bps - when,
						pan: [ prev.pan, blc.pan ],
						midi: [ prev.key, blc.key ],
						gain: [ prev.gain, blc.gain ],
						lowpass: [
							this._calcLowpass( prev.lowpass ),
							this._calcLowpass( blc.lowpass ),
						],
						highpass: [
							this._calcHighpass( prev.highpass ),
							this._calcHighpass( blc.highpass ),
						],
					} );
				}
				return blc;
			}, null );
		}
		key.lowpassNode.type = "lowpass";
		key.highpassNode.type = "highpass";
		key.panNode.pan.setValueAtTime( key.pan, atTime );
		key.gainNode.gain.setValueAtTime( key.gain, atTime );
		key.lowpassNode.frequency.setValueAtTime( this._calcLowpass( key.lowpass ), atTime );
		key.highpassNode.frequency.setValueAtTime( this._calcHighpass( key.highpass ), atTime );
		key.LFONode.start( {
			toggle: lfo.toggle,
			when: key.when,
			whenStop: Number.isFinite( key.dur ) ? key.when + key.dur : 0,
			offset: key.offset,
			type: lfo.type,
			delay: lfo.delay / this._bps,
			attack: lfo.attack / this._bps,
			speed: lfo.speed * this._bps,
			amp: lfo.amp,
		} );
		Object.keys( oscs ).forEach( id => key.oscNodes.set( id, this._createOscNode( key, id ) ) );
		this._scheduleKeyEnv( key );
		this._scheduleVariations( key );
		key.LFONode.node
			.connect( key.envGainNode )
			.connect( key.gainNode )
			.connect( key.panNode )
			.connect( key.lowpassNode )
			.connect( key.highpassNode )
			.connect( this.output );
		this._startedKeys.set( id, key );
		return id;
	}

	// stop
	// .........................................................................
	stopAllKeys() {
		this._startedKeys.forEach( ( _key, id ) => this.stopKey( id ) );
	}
	stopKey( id ) {
		const key = this._startedKeys.get( id );

		if ( key ) {
			if ( Number.isFinite( key.dur ) ) {
				this._stopKey( id );
			} else {
				key.envGainNode.gain.cancelScheduledValues( 0 );
				key.envGainNode.gain.setValueCurveAtTime(
					new Float32Array( [ key.gain, 0 ] ), this.ctx.currentTime + .01, .02 );
				setTimeout( this._stopKey.bind( this, id ), .4 * 1000 );
			}
		} else {
			console.error( "gswaSynth: stopKey id invalid", id );
		}
	}
	_stopKey( id ) {
		const key = this._startedKeys.get( id );

		key.oscNodes.forEach( this._destroyOscNode, this );
		key.LFONode.destroy();
		this._startedKeys.delete( id );
	}

	// private:
	_calcLowpass( val ) {
		return this._calcExp( val, this.nyquist, 2 );
	}
	_calcHighpass( val ) {
		return this._calcExp( 1 - val, this.nyquist, 3 );
	}
	_calcExp( x, total, exp ) {
		return exp === 0
			? x
			: Math.expm1( x ) ** exp / ( ( Math.E - 1 ) ** exp ) * total;
	}

	// default gain envelope
	_scheduleKeyEnv( key ) {
		const par = key.envGainNode.gain,
			{ when, off, dur, attack, release } = key;

		par.cancelScheduledValues( 0 );
		if ( off < .0001 ) {
			par.setValueAtTime( 0, when );
			par.setValueCurveAtTime( new Float32Array( [ 0, 1 ] ), when, attack );
		}
		if ( Number.isFinite( dur ) && dur - ( off < .0001 ? attack : 0 ) >= release ) {
			par.setValueCurveAtTime( new Float32Array( [ 1, 0 ] ), when + dur - release, release );
		}
	}

	// keys linked, variations
	_scheduleVariations( key ) {
		key.variations.forEach( va => {
			const when = key.when - key.off + va.when,
				dur = va.duration,
				freqArr = new Float32Array( [
					gswaSynth.midiKeyToHz[ va.midi[ 0 ] ],
					gswaSynth.midiKeyToHz[ va.midi[ 1 ] ]
				] );

			if ( when > this.ctx.currentTime && dur > 0 ) {
				key.oscNodes.forEach( nodes => nodes.oscNode.frequency.setValueCurveAtTime( freqArr, when, dur ) );
				key.panNode.pan.setValueCurveAtTime( new Float32Array( va.pan ), when, dur );
				key.gainNode.gain.setValueCurveAtTime( new Float32Array( va.gain ), when, dur );
				key.lowpassNode.frequency.setValueCurveAtTime( new Float32Array( va.lowpass ), when, dur );
				key.highpassNode.frequency.setValueCurveAtTime( new Float32Array( va.highpass ), when, dur );
			}
		} );
	}

	// createOscNode
	_createOscNode( key, id ) {
		const atTime = key.when - key.off,
			osc = this.gsdata.data.oscillators[ id ],
			oscNode = this.ctx.createOscillator(),
			panNode = this.ctx.createStereoPanner(),
			gainNode = this.ctx.createGain(),
			nodes = Object.freeze( {
				oscNode,
				panNode,
				gainNode,
			} );

		this._nodeOscSetType( oscNode, osc.type );
		oscNode.detune.setValueAtTime( osc.detune * 100, atTime );
		oscNode.frequency.setValueAtTime( gswaSynth.midiKeyToHz[ key.midi ], atTime );
		panNode.pan.setValueAtTime( osc.pan, atTime );
		gainNode.gain.setValueAtTime( osc.gain, atTime );
		oscNode
			.connect( panNode )
			.connect( gainNode )
			.connect( key.LFONode.node );
		oscNode.start( key.when );
		if ( Number.isFinite( key.dur ) ) {
			oscNode.stop( key.when + key.dur );
		}
		return nodes;
	}
	_destroyOscNode( nodes ) {
		nodes.oscNode.stop();
		nodes.oscNode.disconnect();
	}
	_nodeOscSetType( oscNode, type ) {
		if ( gswaSynth.nativeTypes.indexOf( type ) > -1 ) {
			oscNode.type = type;
		} else {
			oscNode.setPeriodicWave( gswaPeriodicWaves.get( this.ctx, type ) );
		}
	}
}

gswaSynth._startedMaxId = Object.seal( { value: 0 } );
gswaSynth.nativeTypes = Object.freeze( [ "sine", "triangle", "sawtooth", "square" ] );
gswaSynth.midiKeyToHz = [];

Object.freeze( gswaSynth );

/*
This midi array start from 0, this means C#3's frequency is gswaSynth.midiKeyToHz[ 12 * 3 + 1 ].
*/

gswaSynth.midiKeyToHz.push(
	   0, // [0] -> C0 (unused)
	   0,
	   0,
	   0,
	   0,
	   0,
	   0,
	   0,
	   0,
	   0,
	   0,
	   0,

	  32.7032, // [12] -> C1
	  34.6479,
	  36.7081,
	  38.8909,
	  41.2035,
	  43.6536,
	  46.2493,
	  48.9995,
	  51.9130,
	  55,
	  58.2705,
	  61.7354,

	  65.4064, // [24] -> C2
	  69.2957,
	  73.4162,
	  77.7817,
	  82.4069,
	  87.3071,
	  92.4986,
	  97.9989,
	 103.826,
	 110,
	 116.541,
	 123.471,

	 130.813, // [36] -> C3
	 138.591,
	 146.832,
	 155.563,
	 164.814,
	 174.614,
	 184.997,
	 195.998,
	 207.652,
	 220,
	 233.082,
	 246.942,

	 261.626, // [48] -> C4
	 277.183,
	 293.665,
	 311.127,
	 329.628,
	 349.228,
	 369.994,
	 391.995,
	 415.305,
	 440,
	 466.164,
	 493.883,

	 523.251, // [60] -> C5
	 554.365,
	 587.33,
	 622.254,
	 659.255,
	 698.456,
	 739.989,
	 783.991,
	 830.609,
	 880,
	 932.328,
	 987.767,

	1046.5, // [72] -> C6
	1108.73,
	1174.66,
	1244.51,
	1318.51,
	1396.91,
	1479.98,
	1567.98,
	1661.22,
	1760,
	1864.66,
	1975.53,

	2093, // [84] -> C7
	2217.46,
	2349.32,
	2489.02,
	2637.02,
	2793.83,
	2959.96,
	3135.96,
	3322.44,
	3520,
	3729.31,
	3951.07,

	4186.01, // [96] -> C8
);

Object.freeze( gswaSynth.midiKeyToHz );

class gswaKeysScheduler {
	constructor( ctx ) {
		this.scheduler = new gswaScheduler();
		this._synth = null;
		this._startedKeys = new Map();
		Object.seal( this );

		this.scheduler.currentTime = () => ctx.currentTime;
		this.scheduler.ondatastart = this._onstartKey.bind( this );
		this.scheduler.ondatastop = this._onstopKey.bind( this );
		this.scheduler.enableStreaming( !( ctx instanceof OfflineAudioContext ) );
	}

	setSynth( synth ) {
		this._synth = synth;
	}
	change( obj ) {
		this.scheduler.change( obj );
	}
	start( when, off, dur ) {
		this.scheduler.start( when, off, dur );
	}
	stop() {
		this.scheduler.stop();
	}

	_onstartKey( startedId, blcs, when, off, dur ) {
		this._startedKeys.set( startedId,
			this._synth.startKey( blcs, when, off, dur ) );
	}
	_onstopKey( startedId ) {
		this._synth.stopKey( this._startedKeys.get( startedId ) );
		this._startedKeys.delete( startedId );
	}
}

class gswaDrumsScheduler {
	constructor( ctx ) {
		const sch = new gswaScheduler();

		this.scheduler = sch;
		this._drumrows = null;
		this._startedDrums = new Map();
		Object.seal( this );

		sch.currentTime = () => ctx.currentTime;
		sch.ondatastart = this._onstartDrum.bind( this );
		sch.ondatastop = this._onstopDrum.bind( this );
		sch.ondatapropchange = this._onchangeDrum.bind( this );
		sch.enableStreaming( !( ctx instanceof OfflineAudioContext ) );
	}

	setDrumrows( drumrows ) {
		this._drumrows = drumrows;
	}
	change( obj ) {
		const cpy = GSUtils.deepCopy( obj );

		Object.values( cpy ).forEach( drum => {
			if ( drum && "when" in drum ) { // 1.
				drum.duration = this._drumrows.getPatternDurationByRowId( drum.row );
			}
		} );
		this.scheduler.change( cpy );
	}
	start( when, off, dur ) {
		this.scheduler.start( when, off, dur );
	}
	stop() {
		this.scheduler.stop();
	}

	_onstartDrum( startedId, [ [ , drum ] ], when, off, _dur ) {
		if ( "gain" in drum ) {
			this._startedDrums.set( startedId,
				this._drumrows.startDrum( drum, when, off, drum.duration ) );
		} else {
			this._drumrows.startDrumcut( drum, when );
		}
	}
	_onstopDrum( startedId ) {
		this._drumrows.stopDrum( this._startedDrums.get( startedId ) );
		this._startedDrums.delete( startedId );
	}
	_onchangeDrum( startedId, prop, val ) {
		this._drumrows.changeDrumProp( startedId, prop, val );
	}
}

/*
1. The `if` check if the `drum` is new and not updating.
*/

const gswaBPMTap = {
	_stack: [],
	_timeBefore: 0,
	_stackLimit: 10,

	reset() {
		this._timeBefore =
		this._stack.length = 0;
	},
	tap() {
		const time = Date.now(),
			timeBefore = this._timeBefore;

		this._timeBefore = time;
		if ( timeBefore ) {
			const bpm = 60000 / ( time - timeBefore ),
				stack = this._stack,
				lastBpm = stack.length
					? stack[ stack.length - 1 ]
					: 0;

			if ( lastBpm && ( bpm < lastBpm / 1.5 || bpm > lastBpm * 1.5 ) ) {
				stack.length = 0;
			} else {
				if ( stack.unshift( bpm ) > this._stackLimit ) {
					stack.length = this._stackLimit;
				}
				return stack.reduce( ( sum, bpm ) => sum + bpm, 0 ) / stack.length;
			}
		}
		return 0;
	},
};

class gswaEffects {
	constructor( fns ) {
		this.ctx = null;
		this._getChanInput = fns.getChanInput;
		this._getChanOutput = fns.getChanOutput;
		this._wafxs = new Map();
		this.gsdata = new DAWCore.controllers.effects( {
			dataCallbacks: {
				changeBPM: bpm => this._wafxs.forEach( fx => fx.setBPM && fx.setBPM( bpm ) ),
				addEffect: this._addEffect.bind( this ),
				removeEffect: this._removeEffect.bind( this ),
				changeEffect: this._changeEffect.bind( this ),
				connectEffectTo: this._connectEffectTo.bind( this ),
				changeEffectData: ( id, data ) => this._wafxs.get( id ).change( data ),
			},
		} );
		Object.seal( this );
	}

	// .........................................................................
	setContext( ctx ) {
		this.ctx = ctx;
		this.gsdata.reset();
	}
	change( obj ) {
		this.gsdata.change( obj );
	}
	clear() {
		this.gsdata.clear();
	}
	liveChangeFxProp( id, prop, val ) {
		this._wafxs.get( id ).liveChange( prop, val );
	}

	// .........................................................................
	_addEffect( id, fx ) {
		const wafx = new ( gswaEffects.fxsMap.get( fx.type ) )();

		this._wafxs.set( id, wafx );
		wafx.setContext( this.ctx );
	}
	_removeEffect( id ) {
		const wafx = this._wafxs.get( id );

		wafx.output.disconnect();
		this._wafxs.delete( id );
	}
	_changeEffect( id, prop, val ) {
		if ( prop === "toggle" ) {
			this._wafxs.get( id ).toggle( val );
		}
	}
	_connectEffectTo( chanId, fxId, nextFxId ) {
		const dest = nextFxId
				? this._wafxs.get( nextFxId ).input
				: this._getChanOutput( chanId ),
			node = fxId
				? this._wafxs.get( fxId ).output
				: this._getChanInput( chanId );

		if ( node ) {
			node.disconnect();
			node.connect( dest );
		}
	}
}

gswaEffects.fxsMap = new Map();
Object.freeze( gswaEffects );

class gswaFxFilter {
	constructor() {
		this.ctx =
		this.input =
		this.output =
		this._filter =
		this.responseHzIn =
		this.responseMagOut =
		this.responsePhaseOut = null;
		this._respSize = -1;
		this._enable = false;
		this._ctrl = new DAWCore.controllersFx.filter( {
			dataCallbacks: {
				type: this._changeType.bind( this ),
				Q: this._changeProp.bind( this, "Q" ),
				gain: this._changeProp.bind( this, "gain" ),
				detune: this._changeProp.bind( this, "detune" ),
				frequency: this._changeProp.bind( this, "frequency" ),
			},
		} );
		Object.seal( this );
	}

	// .........................................................................
	setContext( ctx ) {
		if ( this.ctx ) {
			this.input.disconnect();
			this.output.disconnect();
			this._filter.disconnect();
		}
		this.ctx = ctx;
		this.input = ctx.createGain();
		this.output = ctx.createGain();
		this._filter = ctx.createBiquadFilter();
		this._ctrl.recall();
		this.toggle( this._enable );
	}
	toggle( b ) {
		this._enable = b;
		if ( this.ctx ) {
			if ( b ) {
				this.input.disconnect();
				this.input.connect( this._filter );
				this._filter.connect( this.output );
			} else {
				this._filter.disconnect();
				this.input.connect( this.output );
			}
		}
	}
	change( obj ) {
		this._ctrl.change( obj );
	}
	liveChange( prop, val ) {
		this._changeProp( prop, val );
	}
	clear() {
		this._ctrl.clear();
		this._respSize = -1;
		this.responseHzIn =
		this.responseMagOut =
		this.responsePhaseOut = null;
	}
	updateResponse( size ) {
		this._createResponseArrays( size );
		this._filter.getFrequencyResponse(
			this.responseHzIn,
			this.responseMagOut,
			this.responsePhaseOut );
		return this.responseMagOut;
	}

	// .........................................................................
	_changeType( type ) {
		this._filter.type = type;
	}
	_changeProp( prop, val ) {
		this._filter[ prop ].setValueAtTime( val, this.ctx.currentTime );
	}
	_createResponseArrays( w ) {
		if ( w !== this._respSize ) {
			const nyquist = this.ctx.sampleRate / 2,
				Hz = new Float32Array( w );

			this._respSize = w;
			this.responseHzIn = Hz;
			this.responseMagOut = new Float32Array( w );
			this.responsePhaseOut = new Float32Array( w );
			for ( let i = 0; i < w; ++i ) {
				Hz[ i ] = nyquist * ( 2 ** ( i / w * 11 - 11 ) );
			}
		}
	}
}

Object.freeze( gswaFxFilter );

if ( typeof gswaEffects !== "undefined" ) {
	gswaEffects.fxsMap.set( "filter", gswaFxFilter );
}

class gswaDrumrows {
	constructor() {
		const ctrl = new DAWCore.controllers.drumrows( {
				dataCallbacks: {
					addDrumrow: GSUtils.noop,
					removeDrumrow: this._removeDrumrow.bind( this ),
					changeDrumrow: this._changeDrumrow.bind( this ),
				},
			} );

		this.ctx =
		this.onstartdrum =
		this.onstartdrumcut = null;
		this.getAudioBuffer =
		this.getChannelInput = GSUtils.noop;
		this._startedDrums = new Map();
		this._bps = 1;
		this._ctrl = ctrl;
		Object.seal( this );
	}

	// .........................................................................
	setContext( ctx ) {
		this.stopAllDrums();
		this.ctx = ctx;
	}
	setBPM( bpm ) {
		this._bps = bpm / 60;
	}
	change( obj ) {
		this._ctrl.change( obj );
	}
	clear() {
		this._ctrl.clear();
	}
	getPatternDurationByRowId( rowId ) {
		const d = this._ctrl.data;

		return d.patterns[ d.drumrows[ rowId ].pattern ].duration;
	}

	// start/stop
	// .........................................................................
	startLiveDrum( rowId ) {
		const drum = {
				row: rowId,
				detune: 0,
				gain: 1,
				pan: 0,
			};

		return this._startDrum( drum, this.ctx.currentTime, 0, null, true );
	}
	stopLiveDrum( rowId ) {
		this._startedDrums.forEach( ( nodes, id ) => {
			// if ( nodes.live && nodes.rowId === rowId ) {
			if ( nodes.rowId === rowId ) {
				this.stopDrum( id, "-f" );
			}
		} );
	}
	startDrumcut( drumcut, when ) {
		const cutDur = .001,
			whenCutStart = when - cutDur;

		this._startedDrums.forEach( ( nodes, id ) => {
			if ( nodes.absn && nodes.rowId === drumcut.row && nodes.when < whenCutStart && when < nodes.endAt ) {
				nodes.endAt = when;
				nodes.gainCut.gain.setValueCurveAtTime( new Float32Array( [ 1, 0 ] ), whenCutStart, cutDur );
				nodes.absn.stop( when + cutDur );
				if ( this.onstartdrumcut ) {
					const fn = this.onstartdrumcut.bind( null, nodes.rowId ),
						time = whenCutStart - this.ctx.currentTime;

					nodes.startDrumcutTimeoutId = setTimeout( fn, time * 1000 );
				}
			}
		} );
	}
	startDrum( drum, when, off, dur ) {
		return this._startDrum( drum, when, off, dur, false );
	}
	_startDrum( drum, when, off, durUser, live ) {
		const data = this._ctrl.data,
			rowId = drum.row,
			row = data.drumrows[ rowId ],
			pat = data.patterns[ row.pattern ],
			buffer = this.getAudioBuffer( pat.buffer ),
			dur = durUser !== null ? durUser : buffer ? buffer.duration : 0,
			id = ++gswaDrumrows._startedMaxId.value,
			nodes = {
				rowId, live, when, dur,
				endAt: when + dur,
				pan: drum.pan,
				gain: drum.gain,
				detune: drum.detune,
			};

		if ( buffer ) {
			const absn = this.ctx.createBufferSource(),
				gainRow = this.ctx.createGain(),
				gainCut = this.ctx.createGain(),
				panRow = this.ctx.createStereoPanner(),
				dest = this.getChannelInput( pat.dest );

			nodes.absn = absn;
			nodes.gainCut = gainCut;
			nodes.gainRow = gainRow;
			nodes.panRow = panRow;
			absn.buffer = buffer;
			absn.detune.setValueAtTime( ( row.detune + drum.detune ) * 100, this.ctx.currentTime );
			gainRow.gain.setValueAtTime( row.toggle ? row.gain * drum.gain : 0, this.ctx.currentTime );
			panRow.pan.setValueAtTime( GSUtils.panningMerge( row.pan, drum.pan ), this.ctx.currentTime );
			absn.connect( gainCut ).connect( gainRow ).connect( panRow ).connect( dest );
			absn.start( when, off, dur );
			if ( this.onstartdrum ) {
				const timeoutMs = ( when - this.ctx.currentTime ) * 1000;

				nodes.startDrumTimeoutId = setTimeout( () => this.onstartdrum( rowId ), timeoutMs );
			}
		}
		this._startedDrums.set( id, nodes );
		this._startedDrums.forEach( ( nodes, id ) => {
			if ( nodes.when + nodes.dur <= this.ctx.currentTime ) {
				this._stopDrum( id, nodes );
			}
		} );
		return id;
	}
	stopAllDrums() {
		this._startedDrums.forEach( ( _nodes, id ) => this.stopDrum( id, "-f" ) );
	}
	stopDrum( id, force ) {
		const nodes = this._startedDrums.get( id );

		if ( nodes && ( force === "-f" ||
			nodes.when + nodes.dur <= this.ctx.currentTime ||
			nodes.when >= this.ctx.currentTime
		) ) {
			this._stopDrum( id, nodes );
		}
	}
	_stopDrum( id, nodes ) {
		this._startedDrums.delete( id );
		clearTimeout( nodes.startDrumTimeoutId );
		clearTimeout( nodes.startDrumcutTimeoutId );
		if ( nodes.absn ) {
			nodes.absn.stop();
			nodes.gainCut.disconnect();
			nodes.gainRow.disconnect();
			nodes.panRow.disconnect();
			if ( this.onstopdrum ) {
				this.onstopdrum( nodes.rowId, id );
			}
		}
	}
	changeDrumProp( id, prop, val ) {
		const nodes = this._startedDrums.get( +id );

		if ( nodes ) {
			const row = this._ctrl.data.drumrows[ nodes.rowId ];

			switch ( prop ) {
				case "detune":
					nodes.detune = val;
					nodes.absn.detune.setValueAtTime( ( val + row.detune ) * 100, this.ctx.currentTime );
					break;
				case "gain":
					nodes.gain = val;
					nodes.gainRow.gain.setValueAtTime( row.toggle ? val * row.gain : 0, this.ctx.currentTime );
					break;
				case "pan": {
					nodes.pan = val;
					nodes.panRow.pan.setValueAtTime( GSUtils.panningMerge( val, row.pan ), this.ctx.currentTime );
				} break;
			}
		}
	}

	// add/remove/update
	// .........................................................................
	_removeDrumrow( id ) {
		this._startedDrums.forEach( ( nodes, startedId ) => {
			if ( nodes.rowId === id ) {
				this.stopDrum( startedId, "-f" );
			}
		} );
	}
	_changeDrumrow( id, prop, val ) {
		const row = this._ctrl.data.drumrows[ id ];

		switch ( prop ) {
			case "toggle":
				this.__changeDrumrow( id, nodes => {
					nodes.gainRow.gain.setValueAtTime( val ? row.gain : 0, this.ctx.currentTime );
				} );
				break;
			case "dest":
				this.__changeDrumrow( id, nodes => {
					nodes.gainRow.disconnect();
					nodes.gainRow.connect( this.getChannelInput( val ) );
				} );
				break;
			case "detune":
				this.__changeDrumrow( id, nodes => {
					nodes.absn.detune.setValueAtTime( ( val + nodes.detune ) * 100, this.ctx.currentTime );
				} );
				break;
			case "gain":
				this.__changeDrumrow( id, nodes => {
					nodes.gainRow.gain.setValueAtTime( val * nodes.gain, this.ctx.currentTime );
				} );
				break;
			case "pan":
				this.__changeDrumrow( id, nodes => {
					nodes.panRow.pan.setValueAtTime( GSUtils.panningMerge( val, nodes.pan ), this.ctx.currentTime );
				} );
				break;
		}
	}
	__changeDrumrow( rowId, fn ) {
		this._startedDrums.forEach( nodes => {
			if ( nodes.rowId === rowId && nodes.absn ) {
				fn( nodes );
			}
		} );
	}
}

gswaDrumrows._startedMaxId = Object.seal( { value: 0 } );

Object.freeze( gswaDrumrows );

class gswaScheduler {
	constructor() {
		this.ondatastart =
		this.ondatastop =
		this.ondatapropchange =
		this.onended =
		this.currentTime = () => {};
		this.bpm = 60;
		this.bps = 1;
		this.started = false;
		this.duration =
		this._startDur =
		this._startOff =
		this._startWhen =
		this._startFixedDur = 0;
		this._timeoutIdEnded = null;
		this.data = {};
		this._sortedData = [];
		this._dataScheduled = {};
		this._dataScheduledPerBlock = {};
		this._lastBlockId = null;
		this.loopA =
		this.loopB = null;
		this.looping = false;
		this.loopDuration = 0;
		this.isStreaming = true;
		this._streamloop = this._streamloop.bind( this );
		this._streamloopId = null;
		this._crud = GSUtils.createUpdateDelete.bind( null, this.data,
			this._dataAddBlock.bind( this ),
			this._dataUpdateBlock.bind( this ),
			this._dataDeleteBlock.bind( this ) );
		Object.seal( this );
	}

	// BPM
	// .........................................................................
	setBPM( bpm ) {
		if ( this.bpm !== bpm ) {
			const ratio = this.bpm / bpm,
				currTime = this.getCurrentOffset() * ratio;

			this.bpm = bpm;
			this.bps = bpm / 60;
			this.duration *= ratio;
			if ( this.looping ) {
				this.loopA *= ratio;
				this.loopB *= ratio;
				this.loopDuration = this.loopB - this.loopA;
				this.setCurrentOffset( this.loopB > currTime ? currTime : this.loopA );
			} else {
				this.setCurrentOffset( currTime );
			}
		}
	}

	// Empty
	// .........................................................................
	empty() {
		this._sortedData.forEach( kv => this._dataDeleteBlock( kv[ 0 ] ) );
		this.clearLoop();
	}

	// Loop
	// .........................................................................
	setLoopBeat( a, b ) {
		return this.setLoop( a / this.bps, b / this.bps );
	}
	setLoop( a, b ) {
		const off = this.started && this.getCurrentOffset();

		this.looping = true;
		this.loopA = Math.min( a, b );
		this.loopB = Math.max( a, b );
		this.loopDuration = this.loopB - this.loopA;
		if ( this.started ) {
			this.setCurrentOffset( this.loopB > off ? off : this.loopA );
		}
	}
	clearLoop() {
		if ( this.looping ) {
			const off = this.getCurrentOffset();

			this.looping = false;
			this.setCurrentOffset( off );
		}
	}

	// set/getCurrentOffset
	// .........................................................................
	setCurrentOffsetBeat( off ) {
		this.setCurrentOffset( off / this.bps );
	}
	setCurrentOffset( off ) {
		this._startOff = off;
		this.started && this.start( 0, off );
	}
	getCurrentOffsetBeat() {
		return this.getCurrentOffset() * this.bps;
	}
	getCurrentOffset() {
		return this.started
			? this.getFutureOffsetAt( this.currentTime() )
			: this._startOff;
	}
	getFutureOffsetAt( futureTime ) {
		let t = this._startOff + futureTime - this._startWhen;

		if ( this.looping && t > this.loopB - .001 ) {
			t = this.loopA + ( t - this.loopA ) % this.loopDuration;
			if ( t > this.loopB - .001 ) {
				t = this.loopA;
			}
		}
		return t;
	}

	// Start / stop
	// .........................................................................
	enableStreaming( b = true ) {
		this.isStreaming = b;
	}
	startBeat( when, off = 0, dur ) {
		return this.start( when, off / this.bps,
			Number.isFinite( dur )
				? dur / this.bps
				: dur );
	}
	start( when, off = 0, dur ) {
		const currTime = this.currentTime();

		if ( this.started ) {
			this.stop();
		}
		this.started = true;
		this._startFixedDur = Number.isFinite( dur );
		this._startWhen = Math.max( currTime, when );
		this._startOff = off;
		this._startDur = this._startFixedDur
			? dur
			: this.duration - off;
		if ( this.isStreaming && !this.looping ) {
			this._timeoutIdEnded = setTimeout(
				this.onended.bind( this ),
				this._startDur * 1000 );
		}
		this.isStreaming
			? this._streamloopOn()
			: this._fullStart();
	}
	stop() {
		if ( this.started ) {
			this._startOff = this.getCurrentOffset();
			this.started = false;
			clearTimeout( this._timeoutIdEnded );
			this._streamloopOff();
			Object.keys( this._dataScheduledPerBlock ).forEach( this._blockStop, this );
		}
	}
	_getOffsetEnd() {
		return this.looping ? this.loopB : this._startOff + this._startDur;
	}
	_updateDuration( dur ) {
		if ( dur !== this.duration ) {
			this.duration = dur;
			if ( this.started && !this._startFixedDur ) {
				this._startDur = dur;
			}
			if ( this.looping || !this._startFixedDur ) {
				clearTimeout( this._timeoutIdEnded );
			}
			if ( this.started && this.isStreaming && !this.looping ) {
				this._timeoutIdEnded = setTimeout( this.onended.bind( this ),
					( dur - this._startOff - this.currentTime() + this._startWhen ) * 1000 );
			}
		}
	}

	// Full start
	// .........................................................................
	_fullStart() {
		const when = this._startWhen,
			from = this._startOff,
			to = from + this._startDur;

		this._sortedData.forEach( kv => this._blockStart( when, from, to, to, ...kv ) );
	}

	// Stream loop
	// .........................................................................
	_streamloopOn() {
		if ( !this._streamloopId ) {
			this._streamloopId = setInterval( this._streamloop, 100 );
			this._streamloop();
		}
	}
	_streamloopOff() {
		if ( this._streamloopId ) {
			clearInterval( this._streamloopId );
			this._streamloopId = null;
		}
	}
	_streamloop() {
		const currTime = this.currentTime();
		let stillSomethingToPlay;

		Object.entries( this._dataScheduled ).forEach( ( [ id, obj ] ) => {
			if ( obj.whenEnd < currTime ) {
				delete this._dataScheduled[ id ];
				delete this._dataScheduledPerBlock[ obj.blockId ].started[ id ];
				this.ondatastop( id );
			}
		} );
		this._sortedData.forEach( kv => {
			if ( this._blockSchedule( kv[ 0 ] ) ) {
				stillSomethingToPlay = true;
			}
		} );
		if ( !this.looping && !stillSomethingToPlay ) {
			this._streamloopOff();
		}
	}

	// Block functions
	// .........................................................................
	_blockStop( id ) {
		const dataScheduled = this._dataScheduled,
			blcSchedule = this._dataScheduledPerBlock[ id ];

		Object.keys( blcSchedule.started ).forEach( id => {
			this.ondatastop( id );
			delete dataScheduled[ id ];
			delete blcSchedule.started[ id ];
		} );
		blcSchedule.scheduledUntil = 0;
	}
	_blockSchedule( id ) {
		if ( this.started ) {
			const currTime = this.currentTime(),
				currTimeEnd = currTime + 1,
				blcSchedule = this._dataScheduledPerBlock[ id ];
			let until = Math.max( currTime, blcSchedule.scheduledUntil || 0 );

			if ( until < currTimeEnd ) {
				const offEnd = this._getOffsetEnd(),
					blc = this.data[ id ];

				do {
					const from = this.getFutureOffsetAt( until ),
						to = Math.min( from + 1, offEnd );

					until += this._blockStart( until, from, to, offEnd, id, blc );
				} while ( this.looping && until < currTimeEnd );
				blcSchedule.scheduledUntil = until;
			}
			return blcSchedule.scheduledUntil <= this._startWhen + this._startDur;
		}
	}
	_blockStart( when, from, to, offEnd, blockId, block ) {
		if ( block.prev == null ) {
			const bps = this.bps,
				blcs = [];
			let bWhn = block.when / bps,
				bOff = block.offset / bps,
				bDur = 0;

			for ( let id = blockId, blc = block; blc; ) {
				blcs.push( [ id, blc ] );
				bDur = blc.when / bps - bWhn + blc.duration / bps;
				id = blc.next;
				blc = id != null ? this.data[ id ] : null;
			}
			if ( from <= bWhn + bDur && bWhn < to ) {
				const startWhen = this._startWhen;

				if ( bWhn + bDur > offEnd ) {
					bDur -= bWhn + bDur - offEnd;
				}
				if ( bWhn < from ) {
					bOff += from - bWhn;
					bDur -= from - bWhn;
					bWhn = from;
				}
				bWhn = when + bWhn - from;
				if ( bWhn < startWhen ) {
					bOff += startWhen - bWhn;
					bDur -= startWhen - bWhn;
					bWhn = startWhen;
				}
				if ( bDur > .000001 ) {
					const id = `${ ++gswaScheduler._startedMaxId.value }`;

					this._dataScheduledPerBlock[ blockId ].started[ id ] =
					this._dataScheduled[ id ] = {
						block,
						blockId,
						when: bWhn,
						whenEnd: bWhn + bDur,
					};
					this.ondatastart( id, blcs, bWhn, bOff, bDur );
				}
				return offEnd - from;
			}
		}
		return to - from;
	}
	_isLastBlock( id ) {
		if ( this._lastBlockId === id ) {
			this._findLastBlock();
		} else {
			const blc = this.data[ id ],
				whnEnd = ( blc.when + blc.duration ) / this.bps;

			if ( whnEnd > this.duration ) {
				this._lastBlockId = id;
				this._updateDuration( whnEnd );
			}
		}
	}
	_findLastBlock() {
		this._updateDuration( Object.entries( this.data )
			.reduce( ( max, [ id, blc ] ) => {
				const whnEnd = ( blc.when + blc.duration ) / this.bps;

				if ( whnEnd > max ) {
					this._lastBlockId = id;
					return whnEnd;
				}
				return max;
			}, 0 ) );
	}

	// Data
	// .........................................................................
	change( obj ) {
		this._crud( obj );
		this._sortedData = Object.entries( this.data ).sort( ( a, b ) => a[ 1 ].when - b[ 1 ].when );
	}
	_dataDeleteBlock( id ) {
		if ( !( id in this.data ) ) {
			console.warn( "gswaScheduler: data delete unknown id", id );
		} else {
			delete this.data[ id ];
			if ( this.started ) {
				this._blockStop( id );
			}
			if ( this._lastBlockId === id ) {
				this._findLastBlock();
			}
			delete this._dataScheduledPerBlock[ id ];
		}
	}
	_dataAddBlock( id, obj ) {
		this._dataScheduledPerBlock[ id ] = {
			started: {},
			scheduledUntil: 0,
		};
		this.data[ id ] = {
			when: 0,
			offset: 0,
			duration: 0,
			...obj,
		};
		this._isLastBlock( id );
		this._blockSchedule( id );
	}
	_dataUpdateBlock( id, obj ) {
		Object.entries( obj ).forEach( kv => this._dataUpdateBlockProp( id, ...kv ) );
	}
	_dataUpdateBlockProp( id, prop, val ) {
		const propTime = prop === "when" || prop === "offset" || prop === "duration",
			propLink = prop === "prev" || prop === "next";

		if ( val === undefined ) {
			delete this.data[ id ][ prop ];
		} else {
			this.data[ id ][ prop ] = val;
		}
		if ( propTime ) {
			this._isLastBlock( id );
		}
		if ( this.started ) {
			if ( propTime || propLink ) {
				this._blockStop( id );
				this._blockSchedule( id );
			} else {
				Object.keys( this._dataScheduledPerBlock[ id ].started ).forEach( startedId => {
					this.ondatapropchange( startedId, prop, val );
				} );
			}
		}
	}
}

gswaScheduler._startedMaxId = Object.seal( { value: 0 } );

Object.freeze( gswaScheduler );

class gswaEncodeWAV {
	static encode( buffer, opt ) {
		const nbChannels = buffer.numberOfChannels,
			sampleRate = buffer.sampleRate,
			format = opt && opt.float32 ? 3 : 1,
			bitsPerSample = format === 3 ? 32 : 16,
			bytesPerSample = bitsPerSample / 8,
			bytesPerbloc = nbChannels * bytesPerSample,
			samples = nbChannels === 2
				? gswaEncodeWAV._interleave( buffer.getChannelData( 0 ), buffer.getChannelData( 1 ) )
				: buffer.getChannelData( 0 ),
			dataSize = samples.length * bytesPerSample,
			arrBuffer = new ArrayBuffer( 44 + dataSize ),
			data = new DataView( arrBuffer );

		gswaEncodeWAV._setString( data, 0, "RIFF" );           // FileTypeBlocID(4) : "RIFF"
		data.setUint32( 4, 36 + dataSize, true );              // FileSize(4)       : headerSize + dataSize - 8
		gswaEncodeWAV._setString( data, 8, "WAVE" );           // FileFormatID(4)   : "WAVE"
		gswaEncodeWAV._setString( data, 12, "fmt " );          // FormatBlocID(4)   : "fmt "
		data.setUint32( 16, 16, true );                        // BlocSize(4)       : 16
		data.setUint16( 20, format, true );                    // AudioFormat(2)    : Format du stockage dans le fichier (1: PCM, ...)
		data.setUint16( 22, nbChannels, true );                // nbChannels(2)     : 1, 2, ..., 6
		data.setUint32( 24, sampleRate, true );                // sampleRate(4)     : 11025, 22050, 44100
		data.setUint32( 28, sampleRate * bytesPerbloc, true ); // bytesPerSec(4)    : sampleRate * bytesPerbloc
		data.setUint16( 32, bytesPerbloc, true );              // bytesPerbloc(2)   : nbChannels * bitsPerSample / 8
		data.setUint16( 34, bitsPerSample, true );             // bitsPerSample(2)  : 8, 16, 24
		gswaEncodeWAV._setString( data, 36, "data" );          // DataBlocID(4)     : "data"
		data.setUint32( 40, dataSize, true );                  // dataSize(4)       : fileSize - 44

		( format === 1
			? gswaEncodeWAV._bufToInt16
			: gswaEncodeWAV._bufToFloat32
		)( data, 44, samples );
		return arrBuffer;
	}

	// private:
	static _interleave( ldata, rdata ) {
		const len = ldata.length + rdata.length,
			arr = new Float32Array( len );

		for ( let i = 0, j = 0; i < len; ++j ) {
			arr[ i++ ] = ldata[ j ];
			arr[ i++ ] = rdata[ j ];
		}
		return arr;
	}
	static _setString( data, offset, str ) {
		for ( let i = 0; i < str.length; ++i ) {
			data.setUint8( offset + i, str.charCodeAt( i ) );
		}
	}
	static _bufToInt16( data, offset, samples ) {
		for ( let i = 0; i < samples.length; ++i ) {
			const s = Math.max( -1, Math.min( samples[ i ], 1 ) );

			data.setInt16( offset + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true );
		}
	}
	static _bufToFloat32( data, offset, samples ) {
		for ( let i = 0; i < samples.length; ++i ) {
			data.setFloat32( offset + i * 4, samples[ i ], true );
		}
	}
}

class gswaStereoPanner {
	constructor( ctx ) {
		this._splitter = ctx.createChannelSplitter( 2 );
		this._left = ctx.createGain();
		this._right = ctx.createGain();
		this._merger = ctx.createChannelMerger( 2 );
		this._splitter.connect( this._left, 0 );
		this._splitter.connect( this._right, 1 );
		this._left.connect( this._merger, 0, 0 );
		this._right.connect( this._merger, 0, 1 );
	}

	connect( ...args ) {
		return this._merger.connect( ...args );
	}
	disconnect( ...args ) {
		return this._merger.disconnect( ...args );
	}
	getInput() {
		return this._splitter;
	}
	getValue() {
		return this._right.gain.value - this._left.gain.value;
	}
	setValueAtTime( value, when ) {
		this._left.gain.setValueAtTime( Math.min( 1 - value, 1 ), when );
		this._right.gain.setValueAtTime( Math.min( 1 + value, 1 ), when );
	}
}

const gswaPeriodicWaves = Object.freeze( {
	list: new Map(),
	_cache: new Map(),

	clearCache() {
		this._cache.clear();
	},
	get( ctx, name ) {
		let p = this._cache.get( name );

		if ( !p ) {
			const w = gswaPeriodicWaves.list.get( name );

			p = ctx.createPeriodicWave( w.real, w.imag );
			this._cache.set( name, p );
		}
		return p;
	},
} );

// Thanks to:
// https://github.com/lukehorvat/web-audio-oscillators
// (and https://github.com/mohayonao/wave-tables)

[
	// natives:
	[ "sine",     { imag: Array.from( { length: 2048 }, ( _, n ) => n === 1 ? 1 : 0 ) } ],
	[ "triangle", { imag: Array.from( { length: 2048 }, ( _, n ) => 8 * Math.sin( n * Math.PI / 2 ) / ( n * Math.PI ) ** 2 ) } ],
	[ "sawtooth", { imag: Array.from( { length: 2048 }, ( _, n ) => 2 / ( n * Math.PI ) * ( -1 ) ** ( n + 1 ) ) } ],
	[ "square",   { imag: Array.from( { length: 2048 }, ( _, n ) => 2 / ( n * Math.PI ) * ( 1 - ( -1 ) ** n ) ) } ],

	// customs simple:
	[ "bass",     { real: [ 0, .5154639175257731, 1, .8144329896907216, .20618556701030927, .020618556701030927 ] } ],
	[ "brass",    { real: [ 0, .4, 1, 1, 1, .3, .7, .6, .5, .9, .8 ] } ],
	[ "organ",    { imag: [ 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1 ] } ],
	[ "organ2",   { real: [ 0, .4, .8, .6, .6, .7, .6, 0, .8, .3, 1 ] } ],

	// customs complex:
	[ "chiptune",    { real: Array.from( { length: 2048 },  ( _, n ) => 4 / ( n * Math.PI ) * Math.sin( Math.PI * n * .18 ) ) } ],
	[ "organ3",      { real: [ 0, 0, -.042008, .010474, -.138038, .002641, -.001673, .001039, -.021054, .000651, -.000422, .000334, -.000236, .000191, -.000161, .000145, -.018478, .000071, -.000066, .000047, -.000044, .000041, -.000034, .000031, -.00003, .000028, -.000025, .000024, -.000022, .00002, -.000015, .000013, -.01157, .000004, -.000003, .000003, -.000003, .000003, -.000003, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000001, .000001, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000898, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000245, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],  imag: [ 0, .196487, 0, 0, -.000003, 0, 0, 0, -.000002, 0, 0, 0, 0, 0, 0, 0, -.000007, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.00001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] } ],
	[ "organ4",      { real: [ 0, 0, -.06072, .030357, -.015136, .006684, -.003512, .002544, -.002455, .002315, -.001264, .004643, -.000089, .000353, -.000165, .000152, -.000145, .000184, -.000123, .000216, -.000135, .000222, -.000219, .000066, -.000701, .000387, -.000125, .000341, -.000117, .004817, -.000568, .003995, -.000035, .000438, -.00028, .000426, -.000038, .000078, -.000108, .000272, -.000161, .000111, -.000165, .000191, -.000156, .000209, -.000072, .000054, -.000111, .001741, -.000161, .001192, -.000127, .000053, -.000044, .000062, -.000095, .00002, -.000102, .000148, -.000051, .00015, -.0001, .000096, -.000095, .000115, -.000081, .000062, -.000022, .000134, -.00008, .000184, -.000018, .000023, -.000044, .000049, -.000057, .000024, -.000033, .000035, -.000057, .000031, -.000044, .000043, -.00001, .000004, -.000062, .000016, -.00005, .000062, -.000051, .00009, -.000036, .000029, -.00005, .000029, -.000025, .000035, -.000036, .000031, -.000028, .000038, -.000064, .000014, -.000031, .000025, -.000042, .000032, -.000045, .000076, -.000025, .000021, -.000029, .000057, -.000019, .000003, -.000039, .000062, -.000035, .000027, -.000024, .000003, -.000051, .000041, -.000047, .000043, -.000039, .000036, -.000045, .000025, -.000067, .000029, -.000021, .000022, -.000038, .000047, -.000029, .000021, -.000037, .000022, -.000047, .000017, -.000051, .000041, -.000031, .000025, -.000013, .000018, -.000041, .000015, -.000018, .000015, -.000022, .00003, -.00003, .000021, -.000027, .000044, -.000023, .000019, -.000024, .00001, -.00002, .000045, -.000038, .000014, -.000017, .000022, -.000025, .00002, -.00001, .000025, -.000004, .000008, -.000013, .000012, -.000028, .000023, -.000022, .000027, -.000008, .000021, -.000016, .000007, -.000022, .000025, -.000008, .000005, -.000005, .000024, -.000025, .000015, -.000017, .000015, -.000012, .000027, -.000023, .000033, -.000004, .000018, -.000026, .000013, -.000012, .000017, -.000021, .000004, -.000015, .000013, -.000002, .000018, -.000011, .000009, -.000016, .000007, -.000009, .000007, -.000009, .00001, -.000018, .000027, -.000011, .000009, -.000012, .000015, -.000019, .000006, -.000008, .00001, -.000007, .000013, -.000005, .000008, -.000018, .000016, -.000015, .000007, -.000011, .000018, -.000012, .00001, -.000019, .000008, -.000008, .000005, -.000001, .000016, -.000008, .000011, -.000002, .000008, -.000013, .000019, -.000005, .00001, -.000012, .000015, -.000016, .000017, -.000013, .000007, -.000013, .000022, -.000012, .000015, -.000012, .00001, -.000009, .000016, -.000012, .000007, -.000008, .000011, -.000007, .000015, -.000005, .000008, -.000001, .000009, -.000015, .000001, -.000012, .000013, -.000012, .000007, -.000013, .000011, -.000013, .000006, -.000008, .000012, -.000005, .000004, -.000005, .000006, -.000013, .000012, -.00001, .000006, -.000007, .000016, -.00001, .000006, -.000006, .000007, -.000007, .000009, -.000009, .000009, -.000008, .000009, -.000008, .000008, -.000008, .000007, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002 ],  imag: [ 0, .168526, 0, 0, 0, 0, 0, 0, 0, 0, 0, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000001, 0, 0, 0, 0, .000006, -.000001, .000006, 0, .000001, 0, .000001, 0, 0, 0, .000001, 0, 0, 0, .000001, 0, .000001, 0, 0, 0, .000006, -.000001, .000005, -.000001, 0, 0, 0, 0, 0, -.000001, .000001, 0, .000001, -.000001, .000001, -.000001, .000001, -.000001, 0, 0, .000001, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, -.000001, 0, 0, 0, 0, 0, -.000001, 0, -.000001, .000001, -.000001, .000001, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, .000001, -.000001, 0, -.000001, 0, -.000001, .000001, -.000001, .000001, 0, 0, -.000001, .000001, 0, 0, -.000001, .000001, -.000001, .000001, -.000001, 0, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000002, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000002, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, -.000001, 0, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000001, .000001, -.000001, 0, -.000001, .000002, -.000002, .000001, -.000001, .000001, -.000001, .000001, 0, .000001, 0, 0, -.000001, .000001, -.000001, .000001, -.000001, .000001, 0, .000001, -.000001, 0, -.000001, .000001, 0, 0, 0, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000001, .000002, 0, .000001, -.000002, .000001, -.000001, .000001, -.000001, 0, -.000001, .000001, 0, .000001, -.000001, .000001, -.000001, 0, -.000001, 0, -.000001, .000001, -.000001, .000002, -.000001, .000001, -.000001, .000001, -.000001, 0, -.000001, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000001, .000001, -.000002, .000001, -.000001, 0, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000002, -.000001, .000001, -.000001, .000001, -.000002, .000002, -.000001, .000001, -.000001, .000002, -.000001, .000002, -.000001, .000001, -.000001, .000002, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000001, .000001, 0, .000001, -.000002, 0, -.000001, .000001, -.000001, .000001, -.000002, .000001, -.000002, .000001, -.000001, .000001, -.000001, 0, -.000001, .000001, -.000002, .000002, -.000001, .000001, -.000001, .000002, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000003, .000002, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] } ],
	[ "organ5",      { real: [ 0, 0, -.265053, .031303, -.066069, .013133, -.009975, .007226, -.031381, .005814, -.004185, .00364, -.002811, .002464, -.002233, .002158, -.021544, .001203, -.001169, .00089, -.000868, .000847, -.000732, .000716, -.000701, .000687, -.000653, .000641, -.00061, .000564, -.000434, .000118, -.013082, .000114, -.000112, .000111, -.000109, .000108, -.000106, .00008, -.000079, .000078, -.000077, .000076, -.000075, .000074, -.000073, .000072, -.000072, .000071, -.00007, .00007, -.000069, .000068, -.000068, .000067, -.000049, .000048, -.000048, .000048, -.000047, .000047, -.000046, .000046, -.007244, .000045, -.000045, .000045, -.000044, .000044, -.000044, .000043, -.000043, .000043, -.000043, .000042, -.000042, .000042, -.000041, .000034, -.000034, .000034, -.000034, .000033, -.000033, .000033, -.000033, .000033, -.000032, .000032, -.000032, .000032, -.000032, .000032, -.000031, .000031, -.000031, .000031, -.00003, .00003, -.00003, .000029, -.000029, .000029, -.000029, .000029, -.000029, .000029, -.000028, .000028, -.000028, .000028, -.000028, .000028, -.000028, .000028, -.000027, .000026, -.000026, .000026, -.000026, .000026, -.000026, .000026, -.000026, .000026, -.000026, .000025, -.003235, .000025, -.000025, .000025, -.000025, .000025, -.000025, .000025, -.00002, .00002, -.00002, .00002, -.00002, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000021, -.000021, .000027, -.000027, .000027, -.000027, .000027, -.000027, .000027, -.000027, .000027, -.000027, .000027, -.000027, .000027, -.000027, .000027, -.000024, .000024, -.000024, .000024, -.000024, .000024, -.000024, .000024, -.000024, .000024, -.000024, .000024, -.000024, .000024, -.000023, .000023, -.000023, .000023, -.000023, .000023, -.000023, .000023, -.000023, .000023, -.000023, .000023, -.000023, .000023, -.001577, .000023, -.000023, .000023, -.000023, .000023, -.000023, .000022, -.000022, .000022, -.000022, .000022, -.000022, .000022, -.000022, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.000021, .000021, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .00002, -.00002, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000019, -.000019, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000018, .000018, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000018, -.000018, .000018, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000017, -.000017, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000388, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000016, -.000016, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000015, -.000015, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000014, -.000014, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000013, -.000013, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],  imag: [ 0, .163431, -.000002, 0, -.000002, 0, -.000001, .000001, -.000003, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000008, .000001, -.000001, 0, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, 0, -.00002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000044, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000079, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000155, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000003, -.000003, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000004, .000004, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000005, -.000005, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000006, -.000006, .000007, -.000007, .000007, -.000007, .000007, -.000161, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000007, .000007, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000008, .000008, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .000009, -.000009, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .000009, -.000009, .000009, -.000009, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.00001, .00001, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000011, .000011, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, -.000012, .000012, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] } ],
	[ "bass2",       { real: [ 0, -.000001, -.085652, .034718, -.036957, .014576, -.005792, .003677, -.002998, .001556, -.000486, .0015, -.000809, .000955, -.000169, .000636, -.000682, .000663, -.000166, .000509, -.00042, .000194, -.000025, .000267, -.000299, .000226, -.000038, .000163, -.000273, .000141, -.000047, .000109, -.000162, .000088, -.000035, .000115, -.000157, .000079, -.000035, .000099, -.000064, .000104, -.00002, .000056, -.0001, .000053, -.000039, .000065, -.000082, .000065, -.000051, .000054, -.00006, .000035, -.000011, .000047, -.000049, .000033, -.00002, .000037, -.000041, .000056, -.000004, .000025, -.000048, .000022, -.000008, .000015, -.000052, .000013, -.000011, .000017, -.000029, .000023, -.000003, .000017, -.000031, .000027, -.000008, .000016, -.000033, .000025, -.000013, .00002, -.000021, .000022, -.000004, .000019, -.000024, .00001, -.000006, .000009, -.000019, .000018, -.000006, .000015, -.000018, .000013, -.000009, .000017, -.000022, .000013, -.000001, .000014, -.000013, .000013, -.000006, .000012, -.000015, .000013, -.000001, .000014, -.000012, .000012, -.000003, .000011, -.000014, .000009, -.000004, .000009, -.000011, .000005, -.000001, .000008, -.00001, .000009, -.000003, .000009, -.000012, .000007, -.000002, .000007, -.000008, .000007, -.000003, .000008, -.000009, .000007, -.000003, .000007, -.000008, .000006, -.000003, .000005, -.000009, .000006, -.000001, .000005, -.000007, .000005, -.000001, .000005, -.000008, .000004, -.000001, .000005, -.000006, .000005, -.000001, .000006, -.000007, .000003, -.000002, .000004, -.000006, .000004, -.000002, .000004, -.000005, .000004, -.000002, .000004, -.000006, .000003, -.000001, .000005, -.000005, .000004, -.000002, .000004, -.000004, .000003, -.000001, .000004, -.000005, .000003, -.000001, .000004, -.000004, .000003, -.000002, .000003, -.000004, .000003, -.000002, .000003, -.000004, .000003, -.000001, .000003, -.000004, .000002, -.000002, .000003, -.000003, .000002, -.000001, .000003, -.000003, .000002, -.000001, .000002, -.000003, .000002, -.000002, .000002, -.000003, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000002, .000002, -.000001, .000002, -.000002, .000002, -.000001, .000002, -.000003, .000002, 0, .000002, -.000004, .000003, -.000001, .000003, -.000005, .000005, -.000003, .000004, -.000007, .000007, -.000006, .000006, -.000008, .000009, -.000008, .000007, -.000009, .00001, -.000009, .000007, -.000008, .000009, -.000009, .000007, -.000007, .000008, -.000008, .000006, -.000005, .000006, -.000007, .000005, -.000003, .000005, -.000005, .000004, -.000002, .000004, -.000004, .000003, -.000002, .000003, -.000004, .000003, -.000002, .000003, -.000004, .000003, -.000001, .000003, -.000003, .000002, -.000001, .000003, -.000003, .000002, -.000001, .000003, -.000003, .000002, -.000001, .000002, -.000003, .000002, -.000001, .000002, -.000003, .000002, -.000001, .000002, -.000003, .000002, -.000001, .000002, -.000003, .000002, -.000001, .000002, -.000003, .000002, -.000001, .000002, -.000002, .000002, -.000001, .000002, -.000002, .000002, -.000001, .000002, -.000002, .000002, -.000001, .000002, -.000002, .000001, -.000001, .000002, -.000002, .000001, -.000001, .000002, -.000002, .000001, 0, .000002, -.000002, .000001, 0, .000002, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000002, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, .000001, 0, .000001, -.000001, 0, 0, .000001, -.000001, 0, 0, .000001, -.000001, 0, 0, .000001, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],  imag: [ 0, .5, -.000001, 0, -.000001, .000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, -.000001, .000001, 0, .000001, -.000001, 0, 0, 0, -.000001, 0, 0, 0, -.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
